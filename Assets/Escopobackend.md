Okay, this is an ambitious and exciting project! An omnichannel API built with Hono and Supabase is a great choice for flexibility and performance. Here's a design proposal, keeping in mind your requirements for isolation and use in frameworks like Next.js/Nuxt.js.

**Core Principles:**

1.  **Stateless:** The API will be stateless, relying on JWTs (from Supabase Auth) for authentication.
2.  **RESTful:** Follow REST principles for resource naming and HTTP methods.
3.  **JSON:** Use JSON for request and response bodies.
4.  **Supabase Integration:**
    *   **Auth:** Supabase Auth for user management and JWT generation.
    *   **Database:** Supabase Postgres for storing all data (channels, messages, leads, analytics, etc.).
    *   **RLS (Row Level Security):** Crucial for multi-tenancy (if applicable) and ensuring users only access their own data.
    *   **Storage:** For media attachments in messages.
    *   **Edge Functions (Optional):** Some Hono routes could potentially be deployed as Supabase Edge Functions if desired for proximity or specific scaling needs, though a dedicated Hono server is also fine.
5.  **Hono:**
    *   Lightweight and fast router.
    *   Middleware for auth, validation (e.g., Zod), logging.
6.  **Modularity:** Design endpoints in a modular way, grouping by functionality.

---

**I. Authentication & Authorization**

*   **Method:** JWT Bearer Tokens issued by Supabase Auth.
*   **Hono Middleware:**
    *   Verify JWT.
    *   Extract `user_id` (and potentially `org_id` or `tenant_id` if you have multi-tenancy) from the token.
    *   Make user information available in the Hono context (`c.get('user')`).
*   **Endpoints:**
    *   Supabase handles `/auth/v1/signup`, `/auth/v1/token?grant_type=password`, `/auth/v1/user`, `/auth/v1/logout` etc., directly. Your Next/Nuxt frontend will interact with these.
    *   Your API will simply *consume* the JWTs generated by Supabase.

```typescript
// Example Hono Auth Middleware (simplified)
import { createMiddleware } from 'hono/factory'
import { verify } from 'hono/jwt' // Or use Supabase's own libraries

const authMiddleware = createMiddleware(async (c, next) => {
  const authHeader = c.req.header('Authorization');
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return c.json({ error: 'Unauthorized', message: 'Bearer token missing' }, 401);
  }
  const token = authHeader.substring(7);
  try {
    // Replace with your Supabase JWT secret
    const decodedPayload = await verify(token, process.env.SUPABASE_JWT_SECRET!);
    // You might want to fetch user details from Supabase DB based on decodedPayload.sub (user_id)
    // to ensure the user still exists and has appropriate permissions.
    // For simplicity, we'll just pass the decoded payload.
    c.set('user', decodedPayload); // Contains { sub: 'user_id', role: 'authenticated', ... }
    await next();
  } catch (err) {
    return c.json({ error: 'Unauthorized', message: 'Invalid token' }, 401);
  }
});

// Apply middleware to protected routes
// app.use('/api/v1/*', authMiddleware);
```

---

**II. API Endpoint Design (Versioned: `/api/v1/*`)**

**A. Channels Management** (WhatsApp, Telegram, Instagram)

*   `POST /api/v1/channels`: Configure/Connect a new channel.
    *   Body: `{ type: "whatsapp" | "telegram" | "instagram", name: "My Business WhatsApp", credentials: { /* api_key, app_secret, bot_token etc. */ } }`
    *   Response: Channel details.
*   `GET /api/v1/channels`: List connected channels for the authenticated user/organization.
*   `GET /api/v1/channels/{channel_id}`: Get specific channel details.
*   `PUT /api/v1/channels/{channel_id}`: Update channel configuration.
*   `DELETE /api/v1/channels/{channel_id}`: Disconnect a channel.

**B. Omnichannel Messaging**

*   `POST /api/v1/channels/{channel_id}/messages`: Send an outgoing message.
    *   Body: `{ contact_identifier: "whatsapp:+1234567890" | "telegram_chat_id:123" | "ig_user_id:456", content: { type: "text" | "image" | "template", text?: "Hello", media_url?: "...", template_name?: "..." } }`
    *   Response: Sent message details.
*   `GET /api/v1/contacts/{contact_id}/messages`: List messages for a specific contact (across channels or filtered by channel).
    *   Query params: `?channel_id=...&limit=20&offset=0&sort=timestamp:desc`
*   `GET /api/v1/messages`: List all messages (admin view, requires proper RLS).
    *   Query params: `?channel_id=...&contact_id=...&direction=inbound|outbound`

**C. Contacts/Users Management**

*   `GET /api/v1/contacts`: List contacts.
    *   Query params for filtering, searching, pagination.
*   `POST /api/v1/contacts`: Create a contact manually (often auto-created on first inbound message).
    *   Body: `{ name: "John Doe", identifiers: [{ type: "whatsapp", value: "+123..."}, { type: "email", value: "john@example.com"}], custom_fields: { ... } }`
*   `GET /api/v1/contacts/{contact_id}`: Get contact details.
*   `PUT /api/v1/contacts/{contact_id}`: Update contact details (add tags, custom fields).
*   `DELETE /api/v1/contacts/{contact_id}`: Delete a contact.

**D. Leads Manager**

*   `POST /api/v1/leads`: Create a new lead (can be linked to a contact or standalone).
    *   Body: `{ contact_id?: "...", name: "Potential Client", email: "...", phone: "...", source: "Website Form", status: "new", value: 1000, notes: "..." }`
*   `GET /api/v1/leads`: List leads.
    *   Query params: `?status=open&assigned_to=user_id&source=...`
*   `GET /api/v1/leads/{lead_id}`: Get lead details.
*   `PUT /api/v1/leads/{lead_id}`: Update lead (status, assignment, notes).
*   `DELETE /api/v1/leads/{lead_id}`: Delete a lead.

**E. Analytics & Tracking**

1.  **Proprietary Event Tracker Endpoint:**
    *   `POST /api/v1/track/event`: Endpoint for your client-side JS tracker to send data.
        *   Body: `{ event_name: "button_click", page_url: "...", user_cookie_id: "...", properties: { button_id: "cta-subscribe", campaign: "summer_sale", ... }, gtm_event_data?: { ... }, facebook_pixel_data?: { ... } }`
        *   This endpoint will:
            1.  Validate and sanitize data.
            2.  Store in a Supabase table (`tracked_events`).
            3.  Optionally, forward to Facebook CAPI / GTM Server-Side if not already done client-side.
2.  **Analytics Data Retrieval:**
    *   `GET /api/v1/analytics/events`: Retrieve tracked events (with filtering).
    *   `GET /api/v1/analytics/segment/{segment_id}/users`: Get users belonging to a pre-defined segment.
    *   `GET /api/v1/analytics/reports/user-journey/{user_cookie_id_or_contact_id}`: Example report.
    *   These would query the `tracked_events`, `contacts`, `messages` tables.

**F. Multimodal AI (Gemini, Anthropic)**

*   `POST /api/v1/ai/generate/text`:
    *   Body: `{ provider: "gemini" | "anthropic", model: "gemini-pro" | "claude-2", prompt: "Summarize this conversation: ...", context_messages?: [{role: "user", content: "..."}, {role: "assistant", content: "..."}], max_tokens?: 200 }`
    *   Response: `{ result: "Generated text..." }`
*   `POST /api/v1/ai/generate/image` (if applicable):
    *   Body: `{ provider: "gemini" | "stability-ai", prompt: "A photo of...", ... }`
*   (Consider storing API keys for these services securely, perhaps encrypted in Supabase or using a vault service).

**G. WP-Headless Integration**

*   `GET /api/v1/content/wp/posts`: List posts.
    *   Query params: `?category=...&tag=...&search=...&per_page=10&page=1`
*   `GET /api/v1/content/wp/posts/{post_slug_or_id}`: Get a single post.
*   `GET /api/v1/content/wp/pages`: List pages.
*   `GET /api/v1/content/wp/pages/{page_slug_or_id}`: Get a single page.
*   (This API would act as a proxy/cache to your WP-Headless instance to avoid exposing WP directly and to potentially add caching or transformation logic).

**H. Project Manager**

*   `POST /api/v1/projects`: Create a project.
    *   Body: `{ name: "New Website Build", description: "...", due_date: "..." }`
*   `GET /api/v1/projects`: List projects.
*   `GET /api/v1/projects/{project_id}`: Get project details.
*   `PUT /api/v1/projects/{project_id}`: Update project.
*   `POST /api/v1/projects/{project_id}/tasks`: Create a task within a project.
    *   Body: `{ title: "Design Homepage", assigned_to_user_id: "...", due_date: "..." }`
*   `GET /api/v1/tasks`: List all tasks (filterable by project, assignee, status).
*   `GET /api/v1/tasks/{task_id}`: Get task details.
*   `PUT /api/v1/tasks/{task_id}`: Update task (status, assignment).

**I. Live Chat** (Agent-facing functionality)

*   `GET /api/v1/live-chat/sessions`: List active/pending chat sessions.
    *   Query params: `?status=pending&agent_id=...`
*   `POST /api/v1/live-chat/sessions/{session_id}/assign`: Assign a session to an agent (current user or specified).
*   `POST /api/v1/live-chat/sessions/{session_id}/messages`: Agent sends a message in a live chat.
    *   (This might internally use the same mechanism as `POST /api/v1/channels/{channel_id}/messages`)
*   `PUT /api/v1/live-chat/sessions/{session_id}/status`: Update session status (e.g., 'closed', 'resolved').
*   (Supabase Realtime can be very useful here to push updates to agent dashboards).

**J. Metrics & Dashboards**

*   These endpoints will typically aggregate data from other tables.
*   `GET /api/v1/metrics/overview`: General stats (total messages, new leads, active chats).
*   `GET /api/v1/metrics/channel-performance`: Performance per channel.
*   `GET /api/v1/metrics/agent-performance`: Agent-specific metrics.
*   (These can be complex and might involve SQL views or Supabase Functions for aggregation).

---

**III. Webhooks (Inbound from External Services)**

These are public-facing endpoints that external services (WhatsApp, Telegram, GTM Server-Side) will call. They should NOT require JWT auth but should have some form of signature verification or secret token check.

*   `/webhooks/whatsapp`: Receives inbound messages and status updates from WhatsApp Cloud API / Twilio etc.
    *   Verifies WhatsApp signature.
    *   Processes message, creates/updates contact, stores message.
    *   May trigger notifications or AI responses.
*   `/webhooks/telegram`: Receives inbound messages from Telegram Bot API.
    *   Verifies request (e.g., using a secret path or token).
    *   Processes message.
*   `/webhooks/instagram`: Receives inbound messages/mentions from Instagram Graph API.
    *   Verifies Instagram signature.
    *   Processes message.
*   `/webhooks/gtm-server`: Endpoint for your GTM Server-Side container to send data to your backend.
    *   Body: Data payload from GTM SS.
    *   Processes and stores data, potentially linking it to contacts or leads.

**Example Hono Webhook Route (Conceptual):**

```typescript
// In your Hono app
// import { Hono } from 'hono';
// const app = new Hono();

app.post('/webhooks/whatsapp', async (c) => {
  // 1. Verify WhatsApp Signature (critical!)
  //    const signature = c.req.header('X-Hub-Signature-256');
  //    const body = await c.req.raw.clone().text(); // Need raw body for signature
  //    if (!verifyWhatsappSignature(body, signature, process.env.WHATSAPP_APP_SECRET)) {
  //      return c.text('Invalid signature', 403);
  //    }

  const payload = await c.req.json();
  console.log('Received WhatsApp Webhook:', payload);

  // 2. Process the payload
  //    - Identify contact
  //    - Store message in Supabase
  //    - Trigger workflows (e.g., AI auto-reply, notify agent)
  //    const { messages, contacts } = payload.entry[0].changes[0].value;
  //    if (messages && messages[0]) {
  //        const incomingMessage = messages[0];
  //        const from = incomingMessage.from; // phone number
  //        const text = incomingMessage.text?.body;
  //        // ... logic to find/create contact, save message ...
  //    }

  return c.text('OK', 200); // WhatsApp expects a 200 OK
});
```

---

**IV. Supabase Database Schema (High-Level Ideas)**

*   `organizations` (if multi-tenant: id, name)
*   `users` (from Supabase Auth, extended with `organization_id`, `role_in_org`)
*   `api_credentials` (id, service_name, encrypted_credentials, user_id, organization_id)
*   `channels` (id, organization_id, type, name, config_json, status, created_at, updated_at)
*   `contacts` (id, organization_id, name, email, created_at, updated_at, custom_fields_jsonb)
*   `contact_identifiers` (id, contact_id, channel_type, identifier_value, is_primary) - e.g. (contact_123, 'whatsapp', '+12345', true)
*   `messages` (id, organization_id, channel_id, contact_id, direction, content_type, text_content, media_url, template_name, metadata_jsonb, status, timestamp, external_message_id)
*   `leads` (id, organization_id, contact_id, name, email, phone, source, status, value, assigned_to_user_id, notes, created_at, updated_at)
*   `tracked_events` (id, organization_id, contact_id, user_cookie_id, event_name, page_url, properties_jsonb, timestamp)
*   `ai_interactions_log` (id, organization_id, user_id, provider, model, prompt_tokens, completion_tokens, request_payload_jsonb, response_payload_jsonb, timestamp)
*   `wp_content_cache` (id, organization_id, source_url_or_slug, content_type, data_jsonb, last_fetched_at)
*   `projects` (id, organization_id, name, description, status, due_date, created_at, updated_at)
*   `tasks` (id, organization_id, project_id, title, description, status, assigned_to_user_id, due_date, created_at, updated_at)
*   `live_chat_sessions` (id, organization_id, contact_id, channel_id, agent_user_id, status, start_time, end_time, last_message_at)

**RLS Policies:**
Extensive use of RLS is critical. For example:
*   A user can only see channels belonging to their `organization_id`.
*   An agent can only see leads/tasks assigned to them, or unassigned ones if they have permission.
*   `SELECT ... FROM messages WHERE organization_id = current_setting('request.jwt.claims', true)::jsonb ->> 'app_metadata'::text ->> 'organization_id'::text;` (This is a common pattern for RLS with custom JWT claims).

---

**V. Project Structure (Hono Example)**

```
/src
  /api
    /v1
      auth.ts         // Middleware
      channels.ts     // Channel routes
      messages.ts     // Message routes
      contacts.ts
      leads.ts
      analytics.ts
      ai.ts
      content.ts
      projects.ts
      livechat.ts
      metrics.ts
    index.ts          // Main v1 router
  /webhooks
    whatsapp.ts
    telegram.ts
    instagram.ts
    gtm.ts
    index.ts          // Main webhooks router
  /core               // Core logic, Supabase client, utils
    supabase.ts
    validators.ts     // Zod schemas
    // ... other services
  index.ts            // Main Hono app setup
.env
package.json
tsconfig.json
```

---

**VI. Considerations & Next Steps:**

1.  **Error Handling:** Implement consistent error responses (e.g., `{ "error": "code", "message": "description" }`).
2.  **Validation:** Use Zod for robust request body and parameter validation in Hono.
3.  **Logging:** Implement comprehensive logging (requests, errors, important events).
4.  **Rate Limiting:** Essential for public-facing webhooks and overall API stability.
5.  **Scalability:** Supabase scales well. Your Hono application can be deployed on various platforms (Fly.io, Vercel Serverless, Cloud Run, Supabase Edge Functions).
6.  **Security:**
    *   HTTPS always.
    *   Input sanitization.
    *   Securely store external API keys (Supabase Vault if available, or encrypted in DB with careful key management).
    *   Regularly review RLS policies.
7.  **Documentation:** Use OpenAPI (Swagger) to document your API. Hono has adaptors for this.
8.  **Client-Side Tracker JS:** You'll need to develop the JavaScript snippet that users will embed on their sites for the proprietary tracker. This script will:
    *   Set/read a unique user cookie.
    *   Attach event listeners (e.g., to buttons with specific attributes).
    *   On event, gather data (page URL, element clicked, etc.).
    *   Optionally trigger FB Pixel, GTM `dataLayer.push`.
    *   Send data to your `POST /api/v1/track/event` endpoint.
9.  **GTM Server-Side Integration:**
    *   Your GTM SS container can use its built-in HTTP request tag or a custom template to send data to `/webhooks/gtm-server`.
    *   Alternatively, your API could send data *to* GTM SS via its event data collection endpoint if you want to trigger tags in GTM SS from your backend events.

This design provides a solid foundation. You'll iterate and refine as you build. Start with a core module (e.g., Channels & Messaging) and expand from there. Good luck!