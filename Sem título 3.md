/**
 * You'll need a Firebase project and the `firebase-ai` dependency to run this
 * code. Learn how to set up your environment: https://firebase.google.com/docs/ai-logic/get-started
 */

import { FirebaseApp } from "firebase/app";
import {
  ChatSession,
  FileDataPart,
  GenerationConfig,
  GenerativeModel,
  Content,
  getGenerativeModel,
  getAI,
  HarmBlockThreshold,
  HarmCategory,
  InlineDataPart,
  Part,
  SafetySetting,
} from "firebase/ai";

async function generateContent(firebaseApp: FirebaseApp) {
  const generationConfig: GenerationConfig = {
    topK: 40,
    responseMimeType: "text/plain",
  };

  const ai = getAI(firebaseApp);
  const model = getGenerativeModel(ai, {
    model: "gemini-2.5-pro-preview-05-06",
    generationConfig,
  });

  const history: Content[] = [
    {
      role: "user",
      parts: [
        "Design a REST API for para  a api vai ser em hono + supabase/ssr, quero fazer essa api isolada para facil utilizacao em outros frameworks, a principio usarei em next/nuxt. sera uma api omminichannel, para gerenciar whatsapp, telegram, instagram, analytics (gtm, gtm server-side, tracker de uso proprio (e.g: injetar cookie + facebook pixel+ gtm events ao clicar em um botao e armazenar os dados no nosso banco de dados para trackear e segmentar os usuarios e gerar predicts...) api multimodal gemini, anthrhropic, api wp-headless, leads manager, projectmanager, chat ao vivo, e.g, telegram, instagram, whatsaapp, metricas..)",
      ],
    },
    {
      role: "model",
      parts: [
        "**Considering the Framework**\n\nI'm currently focusing on the core technologies: Hono and Supabase.  The need for server-side rendering strongly suggests the implementation of Supabase Auth, Row-Level Security, and Database integration.  My aim is to design an isolated API that's simple to integrate into other frameworks.\n\n\n**Analyzing the Architecture**\n\nI've been mapping out the core entities needed for the API.  Key resources include Channels (WhatsApp, Telegram, Instagram), Users, Messages, and Analytics events. I'm focusing on RESTful principles and JWT authentication.  I'm also considering the integration of server-side Google Tag Manager for more advanced analytics tracking.\n\n\n**Outlining API Functions**\n\nCurrently, I'm defining the key API functions.  The core will handle channel management (WhatsApp, Telegram, Instagram), encompassing message handling, contact management, and analytics tracking.  I'm focusing on defining REST endpoints for creating, reading, updating, and deleting each entity. Authentication will be JWT-based. I'm also planning to integrate Gemini and Anthropic AI models, and fetch content from WP-Headless.\n\n\n**Detailing Functionality**\n\nI'm now diving into the specifics of API functionality.  I'm concentrating on designing CRUD operations for channels and messages, and defining endpoints for incoming and outgoing messages within each channel. I'm also planning the design of the webhook endpoints. Considering the nuances of different messaging platforms is key.\n\n\n**Mapping API Endpoints**\n\nI'm now concretizing the endpoint design. I'm focusing on CRUD operations for each key entity, ensuring alignment with RESTful principles.  I'm also considering the specific actions needed for omni-channel message handling, analytics event logging, and interactions with AI models and headless WordPress content. I'm also planning the design of the webhook endpoints.\n\n\n**Finalizing Endpoint Design**\n\nI've meticulously mapped out the endpoints, CRUD operations, and webhook integrations needed for each core entity, now integrating them with authentication.  I'm now determining the optimal strategy for the proprietary analytics events and the content retrieval from WP-Headless.  I'm also considering tenant separation, while still planning the single-tenant setup.\n\n\n**Refining Authentication Strategies**\n\nI'm now focusing on a robust authentication system. I plan to use Supabase for user authentication, issuing JWTs for API access. For API keys, I'll integrate a system for server-to-server communication if needed. I'm also ensuring tight data security with Row Level Security in Supabase.\n\n\n**Designing Supabase Interactions**\n\nI'm currently focusing on the Supabase integration, specifically table design and data modeling, for the API.  I'm exploring the best approach for the database schema, including the use of JSONB for flexible fields, ensuring robust data security with Row Level Security, and implementing API keys for server-to-server communication if needed.\n\n\n**Structuring the Data**\n\nI've been exploring the key entities in detail, focusing on Channels, Messages, Contacts, and Analytics Events. The goal is to define data models to ensure efficient storage and retrieval. I'm also planning the API key and authentication infrastructure for securing server-to-server and client-to-server communication, respectively. I'm also considering the use of JSONB for flexible data fields in Supabase.\n\n\n**Structuring Data and Access**\n\nI'm now focusing on securing the API, planning the implementation of authentication with JWTs issued by Supabase. I'll design RLS policies to safeguard sensitive data within Supabase. Concurrently, I'm working on the data model for the API. I'm also planning the API key and authentication infrastructure for securing server-to-server and client-to-server communication, respectively.\n\n\n**Structuring Data Access**\n\nI'm solidifying the data model, focusing on defining and securing the data access patterns. I'm focusing on defining tables and data relationships. Row-Level Security in Supabase will be a key strategy for safeguarding the data. Now, I'm working to secure the API using Supabase and JWT authentication. I'm also planning the API key and authentication infrastructure for securing server-to-server and client-to-server communication, respectively.\n\n**Focusing on API Architecture**\n\nI'm now integrating the Supabase database schema design. I've considered channels, messages, and contact structures to establish the core tables for the API. I'm focusing on the implementation of Row-Level Security and JWT-based authentication for data security. I'm also preparing the design for API keys for server-to-server communication if needed.\n\n\n",
        "Okay, this is an ambitious and exciting project! An omnichannel API built with Hono and Supabase is a great choice for flexibility and performance. Here's a design proposal, keeping in mind your requirements for isolation and use in frameworks like Next.js/Nuxt.js.\n\n**Core Principles:**\n\n1.  **Stateless:** The API will be stateless, relying on JWTs (from Supabase Auth) for authentication.\n2.  **RESTful:** Follow REST principles for resource naming and HTTP methods.\n3.  **JSON:** Use JSON for request and response bodies.\n4.  **Supabase Integration:**\n    *   **Auth:** Supabase Auth for user management and JWT generation.\n    *   **Database:** Supabase Postgres for storing all data (channels, messages, leads, analytics, etc.).\n    *   **RLS (Row Level Security):** Crucial for multi-tenancy (if applicable) and ensuring users only access their own data.\n    *   **Storage:** For media attachments in messages.\n    *   **Edge Functions (Optional):** Some Hono routes could potentially be deployed as Supabase Edge Functions if desired for proximity or specific scaling needs, though a dedicated Hono server is also fine.\n5.  **Hono:**\n    *   Lightweight and fast router.\n    *   Middleware for auth, validation (e.g., Zod), logging.\n6.  **Modularity:** Design endpoints in a modular way, grouping by functionality.\n\n---\n\n**I. Authentication & Authorization**\n\n*   **Method:** JWT Bearer Tokens issued by Supabase Auth.\n*   **Hono Middleware:**\n    *   Verify JWT.\n    *   Extract `user_id` (and potentially `org_id` or `tenant_id` if you have multi-tenancy) from the token.\n    *   Make user information available in the Hono context (`c.get('user')`).\n*   **Endpoints:**\n    *   Supabase handles `/auth/v1/signup`, `/auth/v1/token?grant_type=password`, `/auth/v1/user`, `/auth/v1/logout` etc., directly. Your Next/Nuxt frontend will interact with these.\n    *   Your API will simply *consume* the JWTs generated by Supabase.\n\n```typescript\n// Example Hono Auth Middleware (simplified)\nimport { createMiddleware } from 'hono/factory'\nimport { verify } from 'hono/jwt' // Or use Supabase's own libraries\n\nconst authMiddleware = createMiddleware(async (c, next) => {\n  const authHeader = c.req.header('Authorization');\n  if (!authHeader || !authHeader.startsWith('Bearer ')) {\n    return c.json({ error: 'Unauthorized', message: 'Bearer token missing' }, 401);\n  }\n  const token = authHeader.substring(7);\n  try {\n    // Replace with your Supabase JWT secret\n    const decodedPayload = await verify(token, process.env.SUPABASE_JWT_SECRET!);\n    // You might want to fetch user details from Supabase DB based on decodedPayload.sub (user_id)\n    // to ensure the user still exists and has appropriate permissions.\n    // For simplicity, we'll just pass the decoded payload.\n    c.set('user', decodedPayload); // Contains { sub: 'user_id', role: 'authenticated', ... }\n    await next();\n  } catch (err) {\n    return c.json({ error: 'Unauthorized', message: 'Invalid token' }, 401);\n  }\n});\n\n// Apply middleware to protected routes\n// app.use('/api/v1/*', authMiddleware);\n```\n\n---\n\n**II. API Endpoint Design (Versioned: `/api/v1/*`)**\n\n**A. Channels Management** (WhatsApp, Telegram, Instagram)\n\n*   `POST /api/v1/channels`: Configure/Connect a new channel.\n    *   Body: `{ type: \"whatsapp\" | \"telegram\" | \"instagram\", name: \"My Business WhatsApp\", credentials: { /* api_key, app_secret, bot_token etc. */ } }`\n    *   Response: Channel details.\n*   `GET /api/v1/channels`: List connected channels for the authenticated user/organization.\n*   `GET /api/v1/channels/{channel_id}`: Get specific channel details.\n*   `PUT /api/v1/channels/{channel_id}`: Update channel configuration.\n*   `DELETE /api/v1/channels/{channel_id}`: Disconnect a channel.\n\n**B. Omnichannel Messaging**\n\n*   `POST /api/v1/channels/{channel_id}/messages`: Send an outgoing message.\n    *   Body: `{ contact_identifier: \"whatsapp:+1234567890\" | \"telegram_chat_id:123\" | \"ig_user_id:456\", content: { type: \"text\" | \"image\" | \"template\", text?: \"Hello\", media_url?: \"...\", template_name?: \"...\" } }`\n    *   Response: Sent message details.\n*   `GET /api/v1/contacts/{contact_id}/messages`: List messages for a specific contact (across channels or filtered by channel).\n    *   Query params: `?channel_id=...&limit=20&offset=0&sort=timestamp:desc`\n*   `GET /api/v1/messages`: List all messages (admin view, requires proper RLS).\n    *   Query params: `?channel_id=...&contact_id=...&direction=inbound|outbound`\n\n**C. Contacts/Users Management**\n\n*   `GET /api/v1/contacts`: List contacts.\n    *   Query params for filtering, searching, pagination.\n*   `POST /api/v1/contacts`: Create a contact manually (often auto-created on first inbound message).\n    *   Body: `{ name: \"John Doe\", identifiers: [{ type: \"whatsapp\", value: \"+123...\"}, { type: \"email\", value: \"john@example.com\"}], custom_fields: { ... } }`\n*   `GET /api/v1/contacts/{contact_id}`: Get contact details.\n*   `PUT /api/v1/contacts/{contact_id}`: Update contact details (add tags, custom fields).\n*   `DELETE /api/v1/contacts/{contact_id}`: Delete a contact.\n\n**D. Leads Manager**\n\n*   `POST /api/v1/leads`: Create a new lead (can be linked to a contact or standalone).\n    *   Body: `{ contact_id?: \"...\", name: \"Potential Client\", email: \"...\", phone: \"...\", source: \"Website Form\", status: \"new\", value: 1000, notes: \"...\" }`\n*   `GET /api/v1/leads`: List leads.\n    *   Query params: `?status=open&assigned_to=user_id&source=...`\n*   `GET /api/v1/leads/{lead_id}`: Get lead details.\n*   `PUT /api/v1/leads/{lead_id}`: Update lead (status, assignment, notes).\n*   `DELETE /api/v1/leads/{lead_id}`: Delete a lead.\n\n**E. Analytics & Tracking**\n\n1.  **Proprietary Event Tracker Endpoint:**\n    *   `POST /api/v1/track/event`: Endpoint for your client-side JS tracker to send data.\n        *   Body: `{ event_name: \"button_click\", page_url: \"...\", user_cookie_id: \"...\", properties: { button_id: \"cta-subscribe\", campaign: \"summer_sale\", ... }, gtm_event_data?: { ... }, facebook_pixel_data?: { ... } }`\n        *   This endpoint will:\n            1.  Validate and sanitize data.\n            2.  Store in a Supabase table (`tracked_events`).\n            3.  Optionally, forward to Facebook CAPI / GTM Server-Side if not already done client-side.\n2.  **Analytics Data Retrieval:**\n    *   `GET /api/v1/analytics/events`: Retrieve tracked events (with filtering).\n    *   `GET /api/v1/analytics/segment/{segment_id}/users`: Get users belonging to a pre-defined segment.\n    *   `GET /api/v1/analytics/reports/user-journey/{user_cookie_id_or_contact_id}`: Example report.\n    *   These would query the `tracked_events`, `contacts`, `messages` tables.\n\n**F. Multimodal AI (Gemini, Anthropic)**\n\n*   `POST /api/v1/ai/generate/text`:\n    *   Body: `{ provider: \"gemini\" | \"anthropic\", model: \"gemini-pro\" | \"claude-2\", prompt: \"Summarize this conversation: ...\", context_messages?: [{role: \"user\", content: \"...\"}, {role: \"assistant\", content: \"...\"}], max_tokens?: 200 }`\n    *   Response: `{ result: \"Generated text...\" }`\n*   `POST /api/v1/ai/generate/image` (if applicable):\n    *   Body: `{ provider: \"gemini\" | \"stability-ai\", prompt: \"A photo of...\", ... }`\n*   (Consider storing API keys for these services securely, perhaps encrypted in Supabase or using a vault service).\n\n**G. WP-Headless Integration**\n\n*   `GET /api/v1/content/wp/posts`: List posts.\n    *   Query params: `?category=...&tag=...&search=...&per_page=10&page=1`\n*   `GET /api/v1/content/wp/posts/{post_slug_or_id}`: Get a single post.\n*   `GET /api/v1/content/wp/pages`: List pages.\n*   `GET /api/v1/content/wp/pages/{page_slug_or_id}`: Get a single page.\n*   (This API would act as a proxy/cache to your WP-Headless instance to avoid exposing WP directly and to potentially add caching or transformation logic).\n\n**H. Project Manager**\n\n*   `POST /api/v1/projects`: Create a project.\n    *   Body: `{ name: \"New Website Build\", description: \"...\", due_date: \"...\" }`\n*   `GET /api/v1/projects`: List projects.\n*   `GET /api/v1/projects/{project_id}`: Get project details.\n*   `PUT /api/v1/projects/{project_id}`: Update project.\n*   `POST /api/v1/projects/{project_id}/tasks`: Create a task within a project.\n    *   Body: `{ title: \"Design Homepage\", assigned_to_user_id: \"...\", due_date: \"...\" }`\n*   `GET /api/v1/tasks`: List all tasks (filterable by project, assignee, status).\n*   `GET /api/v1/tasks/{task_id}`: Get task details.\n*   `PUT /api/v1/tasks/{task_id}`: Update task (status, assignment).\n\n**I. Live Chat** (Agent-facing functionality)\n\n*   `GET /api/v1/live-chat/sessions`: List active/pending chat sessions.\n    *   Query params: `?status=pending&agent_id=...`\n*   `POST /api/v1/live-chat/sessions/{session_id}/assign`: Assign a session to an agent (current user or specified).\n*   `POST /api/v1/live-chat/sessions/{session_id}/messages`: Agent sends a message in a live chat.\n    *   (This might internally use the same mechanism as `POST /api/v1/channels/{channel_id}/messages`)\n*   `PUT /api/v1/live-chat/sessions/{session_id}/status`: Update session status (e.g., 'closed', 'resolved').\n*   (Supabase Realtime can be very useful here to push updates to agent dashboards).\n\n**J. Metrics & Dashboards**\n\n*   These endpoints will typically aggregate data from other tables.\n*   `GET /api/v1/metrics/overview`: General stats (total messages, new leads, active chats).\n*   `GET /api/v1/metrics/channel-performance`: Performance per channel.\n*   `GET /api/v1/metrics/agent-performance`: Agent-specific metrics.\n*   (These can be complex and might involve SQL views or Supabase Functions for aggregation).\n\n---\n\n**III. Webhooks (Inbound from External Services)**\n\nThese are public-facing endpoints that external services (WhatsApp, Telegram, GTM Server-Side) will call. They should NOT require JWT auth but should have some form of signature verification or secret token check.\n\n*   `/webhooks/whatsapp`: Receives inbound messages and status updates from WhatsApp Cloud API / Twilio etc.\n    *   Verifies WhatsApp signature.\n    *   Processes message, creates/updates contact, stores message.\n    *   May trigger notifications or AI responses.\n*   `/webhooks/telegram`: Receives inbound messages from Telegram Bot API.\n    *   Verifies request (e.g., using a secret path or token).\n    *   Processes message.\n*   `/webhooks/instagram`: Receives inbound messages/mentions from Instagram Graph API.\n    *   Verifies Instagram signature.\n    *   Processes message.\n*   `/webhooks/gtm-server`: Endpoint for your GTM Server-Side container to send data to your backend.\n    *   Body: Data payload from GTM SS.\n    *   Processes and stores data, potentially linking it to contacts or leads.\n\n**Example Hono Webhook Route (Conceptual):**\n\n```typescript\n// In your Hono app\n// import { Hono } from 'hono';\n// const app = new Hono();\n\napp.post('/webhooks/whatsapp', async (c) => {\n  // 1. Verify WhatsApp Signature (critical!)\n  //    const signature = c.req.header('X-Hub-Signature-256');\n  //    const body = await c.req.raw.clone().text(); // Need raw body for signature\n  //    if (!verifyWhatsappSignature(body, signature, process.env.WHATSAPP_APP_SECRET)) {\n  //      return c.text('Invalid signature', 403);\n  //    }\n\n  const payload = await c.req.json();\n  console.log('Received WhatsApp Webhook:', payload);\n\n  // 2. Process the payload\n  //    - Identify contact\n  //    - Store message in Supabase\n  //    - Trigger workflows (e.g., AI auto-reply, notify agent)\n  //    const { messages, contacts } = payload.entry[0].changes[0].value;\n  //    if (messages && messages[0]) {\n  //        const incomingMessage = messages[0];\n  //        const from = incomingMessage.from; // phone number\n  //        const text = incomingMessage.text?.body;\n  //        // ... logic to find/create contact, save message ...\n  //    }\n\n  return c.text('OK', 200); // WhatsApp expects a 200 OK\n});\n```\n\n---\n\n**IV. Supabase Database Schema (High-Level Ideas)**\n\n*   `organizations` (if multi-tenant: id, name)\n*   `users` (from Supabase Auth, extended with `organization_id`, `role_in_org`)\n*   `api_credentials` (id, service_name, encrypted_credentials, user_id, organization_id)\n*   `channels` (id, organization_id, type, name, config_json, status, created_at, updated_at)\n*   `contacts` (id, organization_id, name, email, created_at, updated_at, custom_fields_jsonb)\n*   `contact_identifiers` (id, contact_id, channel_type, identifier_value, is_primary) - e.g. (contact_123, 'whatsapp', '+12345', true)\n*   `messages` (id, organization_id, channel_id, contact_id, direction, content_type, text_content, media_url, template_name, metadata_jsonb, status, timestamp, external_message_id)\n*   `leads` (id, organization_id, contact_id, name, email, phone, source, status, value, assigned_to_user_id, notes, created_at, updated_at)\n*   `tracked_events` (id, organization_id, contact_id, user_cookie_id, event_name, page_url, properties_jsonb, timestamp)\n*   `ai_interactions_log` (id, organization_id, user_id, provider, model, prompt_tokens, completion_tokens, request_payload_jsonb, response_payload_jsonb, timestamp)\n*   `wp_content_cache` (id, organization_id, source_url_or_slug, content_type, data_jsonb, last_fetched_at)\n*   `projects` (id, organization_id, name, description, status, due_date, created_at, updated_at)\n*   `tasks` (id, organization_id, project_id, title, description, status, assigned_to_user_id, due_date, created_at, updated_at)\n*   `live_chat_sessions` (id, organization_id, contact_id, channel_id, agent_user_id, status, start_time, end_time, last_message_at)\n\n**RLS Policies:**\nExtensive use of RLS is critical. For example:\n*   A user can only see channels belonging to their `organization_id`.\n*   An agent can only see leads/tasks assigned to them, or unassigned ones if they have permission.\n*   `SELECT ... FROM messages WHERE organization_id = current_setting('request.jwt.claims', true)::jsonb ->> 'app_metadata'::text ->> 'organization_id'::text;` (This is a common pattern for RLS with custom JWT claims).\n\n---\n\n**V. Project Structure (Hono Example)**\n\n```\n/src\n  /api\n    /v1\n      auth.ts         // Middleware\n      channels.ts     // Channel routes\n      messages.ts     // Message routes\n      contacts.ts\n      leads.ts\n      analytics.ts\n      ai.ts\n      content.ts\n      projects.ts\n      livechat.ts\n      metrics.ts\n    index.ts          // Main v1 router\n  /webhooks\n    whatsapp.ts\n    telegram.ts\n    instagram.ts\n    gtm.ts\n    index.ts          // Main webhooks router\n  /core               // Core logic, Supabase client, utils\n    supabase.ts\n    validators.ts     // Zod schemas\n    // ... other services\n  index.ts            // Main Hono app setup\n.env\npackage.json\ntsconfig.json\n```\n\n---\n\n**VI. Considerations & Next Steps:**\n\n1.  **Error Handling:** Implement consistent error responses (e.g., `{ \"error\": \"code\", \"message\": \"description\" }`).\n2.  **Validation:** Use Zod for robust request body and parameter validation in Hono.\n3.  **Logging:** Implement comprehensive logging (requests, errors, important events).\n4.  **Rate Limiting:** Essential for public-facing webhooks and overall API stability.\n5.  **Scalability:** Supabase scales well. Your Hono application can be deployed on various platforms (Fly.io, Vercel Serverless, Cloud Run, Supabase Edge Functions).\n6.  **Security:**\n    *   HTTPS always.\n    *   Input sanitization.\n    *   Securely store external API keys (Supabase Vault if available, or encrypted in DB with careful key management).\n    *   Regularly review RLS policies.\n7.  **Documentation:** Use OpenAPI (Swagger) to document your API. Hono has adaptors for this.\n8.  **Client-Side Tracker JS:** You'll need to develop the JavaScript snippet that users will embed on their sites for the proprietary tracker. This script will:\n    *   Set/read a unique user cookie.\n    *   Attach event listeners (e.g., to buttons with specific attributes).\n    *   On event, gather data (page URL, element clicked, etc.).\n    *   Optionally trigger FB Pixel, GTM `dataLayer.push`.\n    *   Send data to your `POST /api/v1/track/event` endpoint.\n9.  **GTM Server-Side Integration:**\n    *   Your GTM SS container can use its built-in HTTP request tag or a custom template to send data to `/webhooks/gtm-server`.\n    *   Alternatively, your API could send data *to* GTM SS via its event data collection endpoint if you want to trigger tags in GTM SS from your backend events.\n\nThis design provides a solid foundation. You'll iterate and refine as you build. Start with a core module (e.g., Channels & Messaging) and expand from there. Good luck!",
      ],
    },
    {
      role: "user",
      parts: [
        "gere os codigos agora",
      ],
    },
    {
      role: "model",
      parts: [
        "**Generating Code Snippets**\n\nI've decided to prioritize the request for REST API examples by focusing on a basic Hono setup and Supabase client initialization. My next step involves crafting a concise example showing basic interaction. I'll showcase a simple route setup using Hono with Supabase authentication. This approach lets the user understand the core components without overwhelming them.\n\n\n**Expanding Code Examples**\n\nI'm now focusing on a more comprehensive structure. This includes basic Hono setup, Supabase client initialization, and an illustrative JWT authentication middleware. I'll include concise examples of CRUD operations for a 'Channels' resource. Additionally, I'll showcase a simple webhook handler and conceptual client-side tracking, along with Zod validation examples. I'll make sure to note that this is a starting point, not a complete solution.\n\n\n**Developing Structure and Snippets**\n\nI'm now integrating the Supabase client and building out the JWT authentication middleware within the Hono framework. I'm focusing on crafting a basic CRUD example using 'Channels' as a representative resource. I've also begun sketching the webhook handler and a conceptual client-side tracking snippet, complemented by Zod validation examples. These will be clearly labeled and placed in the project structure. This will be a starting point, to keep in mind, and not a fully complete solution.\n\n\n**Defining Project Structure**\n\nI'm now focusing on defining the project structure and breaking down the code examples into manageable parts. I've decided on an `api/v1` directory for versioned API endpoints, a `core` directory for shared utilities like Supabase client initialization and Zod schemas, and a `webhooks` directory. I'll include clear instructions and an emphasis on these examples being starting points.\n\n\n**Defining Example Structure**\n\nI'm now focusing on defining the project structure. I've decided on an `api/v1` directory for API endpoints, a `core` directory for Supabase client initialization and Zod schemas, and a `webhooks` directory. I'm prioritizing clear explanations and emphasizing these examples are starting points. My goal is to craft a manageable and understandable demonstration. I'll provide a simplified Supabase schema and include key environment variables.\n\n**Refining Code Generation**\n\nI'm now prioritizing the code generation, starting with the `src/index.ts` file. I'm focusing on the Hono setup, Supabase client initialization, and basic routing. I'll define the project structure, including the `api/v1`, `core`, and `webhooks` directories.  I'll include clear environment variable explanations and a simplified Supabase schema example. The goal is to provide a concise and understandable starting point, with emphasis on the limitations.\n\n\n",
        "Okay, let's get our hands dirty with some code!\n\nThis will be a starter Hono project setup with Supabase integration, focusing on a few key areas you requested. Remember, this is a foundation, and a full-fledged production system will require more error handling, testing, security hardening, and detailed implementation for each module.\n\n**Prerequisites:**\n\n1.  **Node.js and npm/yarn:** Make sure you have them installed.\n2.  **Supabase Project:**\n    *   Create a Supabase project.\n    *   Get your `SUPABASE_URL`, `SUPABASE_ANON_KEY`, `SUPABASE_SERVICE_ROLE_KEY`, and `SUPABASE_JWT_SECRET`.\n    *   Enable JWT authentication.\n    *   (Optional for now, but crucial later) Set up Row Level Security (RLS) on your tables.\n3.  **Install Dependencies:**\n    ```bash\n    mkdir hono-omnichannel-api\n    cd hono-omnichannel-api\n    npm init -y\n    npm install hono supabase-js @supabase/supabase-js dotenv zod hono # For JWT middleware: hono/jwt\n    # Or if you prefer yarn\n    # yarn add hono supabase-js @supabase/supabase-js dotenv zod hono\n    npm install -D typescript @types/node ts-node nodemon # Dev dependencies\n    ```\n4.  **`tsconfig.json`:**\n    Create a `tsconfig.json` file in your project root:\n    ```json\n    {\n      \"compilerOptions\": {\n        \"target\": \"ES2020\",\n        \"module\": \"ESNext\",\n        \"moduleResolution\": \"node\",\n        \"esModuleInterop\": true,\n        \"strict\": true,\n        \"skipLibCheck\": true,\n        \"outDir\": \"./dist\",\n        \"rootDir\": \"./src\",\n        \"baseUrl\": \"./src\",\n        \"paths\": {\n          \"@/*\": [\"*\"]\n        }\n      },\n      \"include\": [\"src/**/*\"],\n      \"exclude\": [\"node_modules\"]\n    }\n    ```\n5.  **`.env` file:**\n    Create a `.env` file in your project root (add this to `.gitignore`!):\n    ```env\n    SUPABASE_URL=your_supabase_url\n    SUPABASE_ANON_KEY=your_supabase_anon_key\n    SUPABASE_SERVICE_ROLE_KEY=your_supabase_service_role_key # Use with caution\n    SUPABASE_JWT_SECRET=your_supabase_jwt_secret # From Supabase Auth settings\n    PORT=3000\n    ```\n\n**Project Structure (Simplified):**\n\n```\nhono-omnichannel-api/\n├── .env\n├── package.json\n├── tsconfig.json\n├── src/\n│   ├── index.ts            # Main Hono app entry point\n│   ├── core/\n│   │   ├── supabase.ts     # Supabase client setup\n│   │   └── validators.ts   # Zod schemas\n│   ├── api/\n│   │   └── v1/\n│   │       ├── middleware/\n│   │       │   └── auth.ts # Authentication middleware\n│   │       ├── channels.ts # Channel management routes\n│   │       └── index.ts    # V1 API router\n│   ├── webhooks/\n│   │   └── whatsapp.ts   # Example WhatsApp webhook\n│   └── types/\n│       └── index.ts        # Custom TypeScript types (e.g., for Hono context)\n├── public/                 # For static files like the client-side tracker\n│   └── tracker.js\n```\n\n---\n\n**1. Supabase Client (`src/core/supabase.ts`)**\n\n```typescript\nimport { createClient, SupabaseClient } from '@supabase/supabase-js';\nimport 'dotenv/config'; // To load .env variables\n\nconst supabaseUrl = process.env.SUPABASE_URL;\nconst supabaseAnonKey = process.env.SUPABASE_ANON_KEY; // For client-side like operations or if RLS handles everything\nconst supabaseServiceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY; // For admin operations, use carefully\n\nif (!supabaseUrl || !supabaseAnonKey || !supabaseServiceRoleKey || !process.env.SUPABASE_JWT_SECRET) {\n  throw new Error('Supabase URL, Anon Key, Service Role Key, or JWT Secret not found in environment variables.');\n}\n\n// Client for general use, respects RLS if user JWT is provided\nexport const supabase = createClient(supabaseUrl, supabaseAnonKey);\n\n// Admin client, bypasses RLS. Use with extreme caution and only when necessary.\n// Prefer creating specific database roles and using those with a custom JWT if possible.\nexport const supabaseAdmin = createClient(supabaseUrl, supabaseServiceRoleKey, {\n  auth: {\n    autoRefreshToken: false,\n    persistSession: false,\n  }\n});\n\n// Function to get a Supabase client instance for a specific user's JWT\n// This client will operate under the user's RLS policies\nexport const getSupabaseClientForUser = (jwt: string): SupabaseClient => {\n  return createClient(supabaseUrl, supabaseAnonKey, {\n    global: {\n      headers: { Authorization: `Bearer ${jwt}` },\n    },\n  });\n};\n\nconsole.log('Supabase client initialized.');\n```\n\n---\n\n**2. Custom Types (`src/types/index.ts`)**\n\nThis is for extending Hono's context if needed, especially after authentication.\n\n```typescript\n// src/types/index.ts\nimport { JwtVariables } from 'hono/jwt'; // If using hono/jwt\n\nexport type HonoEnv = {\n  Variables: {\n    user?: { sub: string; [key: string]: any }; // User payload from JWT\n    // You can add other variables here, e.g., db client specific to the request\n    // supabaseUserClient?: SupabaseClient;\n  } & JwtVariables; // Include if using hono/jwt for its default variables\n  Bindings: { // For Cloudflare Workers or similar environments\n    // Define your bindings here if deploying to CF Workers\n  };\n};\n```\n\n---\n\n**3. Authentication Middleware (`src/api/v1/middleware/auth.ts`)**\n\n```typescript\n// src/api/v1/middleware/auth.ts\nimport { createMiddleware } from 'hono/factory';\nimport { verify } from 'hono/jwt';\nimport { HonoEnv } from '@/types'; // Adjust path if necessary\n\nconst jwtSecret = process.env.SUPABASE_JWT_SECRET!;\n\nif (!jwtSecret) {\n  throw new Error(\"SUPABASE_JWT_SECRET is not defined in environment variables.\");\n}\n\nexport const authMiddleware = createMiddleware<HonoEnv>(async (c, next) => {\n  const authHeader = c.req.header('Authorization');\n  if (!authHeader || !authHeader.startsWith('Bearer ')) {\n    return c.json({ error: 'Unauthorized', message: 'Bearer token is missing or malformed.' }, 401);\n  }\n\n  const token = authHeader.substring(7); // Remove \"Bearer \"\n\n  try {\n    const decodedPayload = await verify(token, jwtSecret);\n    // `decodedPayload` will contain `sub` (user_id), `role`, `exp`, etc.\n    // You might want to add more checks here, e.g., if user exists in your db\n    // or if the token is not blacklisted.\n\n    // Example: Validate 'sub' exists\n    if (!decodedPayload.sub) {\n        return c.json({ error: 'Unauthorized', message: 'Invalid token: subject missing.' }, 401);\n    }\n\n    c.set('user', { sub: decodedPayload.sub as string, ...decodedPayload });\n    // c.set('supabaseUserClient', getSupabaseClientForUser(token)); // Option to set user-specific client\n\n    await next();\n  } catch (err: any) {\n    console.error(\"JWT Verification Error:\", err.message);\n    return c.json({ error: 'Unauthorized', message: 'Invalid or expired token.' }, 401);\n  }\n});\n```\n\n---\n\n**4. Zod Validators (`src/core/validators.ts`)**\n\n```typescript\n// src/core/validators.ts\nimport { z } from 'zod';\n\nexport const createChannelSchema = z.object({\n  type: z.enum(['whatsapp', 'telegram', 'instagram']),\n  name: z.string().min(3).max(100),\n  credentials: z.object({\n    // Define specific credential fields per type if needed\n    // For example, for WhatsApp:\n    // phoneNumberId: z.string().optional(),\n    // accessToken: z.string().optional(),\n    // For Telegram:\n    // botToken: z.string().optional(),\n  }).passthrough(), // Allows other properties in credentials\n});\n\nexport type CreateChannelInput = z.infer<typeof createChannelSchema>;\n\nexport const updateChannelSchema = createChannelSchema.partial();\nexport type UpdateChannelInput = z.infer<typeof updateChannelSchema>;\n\n// Example for sending a message\nexport const sendMessageSchema = z.object({\n    contact_identifier: z.string().min(1), // e.g., \"whatsapp:+1234567890\"\n    content: z.object({\n        type: z.enum([\"text\", \"image\", \"template\"]),\n        text: z.string().optional(),\n        media_url: z.string().url().optional(),\n        template_name: z.string().optional(),\n    }),\n});\nexport type SendMessageInput = z.infer<typeof sendMessageSchema>;\n```\n\n---\n\n**5. Channels API Routes (`src/api/v1/channels.ts`)**\n\n```typescript\n// src/api/v1/channels.ts\nimport { Hono } from 'hono';\nimport { zValidator } from '@hono/zod-validator';\nimport { supabase, supabaseAdmin } from '@/core/supabase'; // Using admin for now, adjust based on RLS\nimport { createChannelSchema, updateChannelSchema } from '@/core/validators';\nimport { authMiddleware } from './middleware/auth';\nimport { HonoEnv } from '@/types';\n\nconst channelsApp = new Hono<HonoEnv>();\n\n// Apply auth middleware to all channel routes\nchannelsApp.use('*', authMiddleware);\n\n// POST /api/v1/channels - Create a new channel\nchannelsApp.post('/', zValidator('json', createChannelSchema), async (c) => {\n  const channelData = c.req.valid('json');\n  const user = c.get('user'); // Get user from auth middleware\n\n  if (!user || !user.sub) {\n    return c.json({ error: 'User not authenticated or user ID missing' }, 403);\n  }\n\n  // For RLS to work correctly, Supabase needs to know the user.\n  // If using the standard `supabase` client with RLS and JWT in headers:\n  // const userSupabase = getSupabaseClientForUser(c.req.header('Authorization')!.substring(7));\n  // const { data, error } = await userSupabase.from('channels').insert({\n  //   ...channelData,\n  //   user_id: user.sub, // Make sure your table has user_id and RLS is set\n  // }).select().single();\n\n  // Using supabaseAdmin for simplicity here, assumes you handle auth context.\n  // In a real app, prefer user-context client or strict RLS + service roles.\n  const { data, error } = await supabaseAdmin\n    .from('channels')\n    .insert({\n      ...channelData,\n      user_id: user.sub, // This should match your DB schema\n      // organization_id: user.organization_id, // If using orgs\n    })\n    .select()\n    .single();\n\n  if (error) {\n    console.error('Supabase error creating channel:', error);\n    return c.json({ error: 'Failed to create channel', details: error.message }, 500);\n  }\n  return c.json(data, 201);\n});\n\n// GET /api/v1/channels - List channels for the authenticated user\nchannelsApp.get('/', async (c) => {\n  const user = c.get('user');\n  if (!user || !user.sub) {\n    return c.json({ error: 'User not authenticated' }, 403);\n  }\n\n  const { data, error } = await supabaseAdmin // Replace with user-context client for RLS\n    .from('channels')\n    .select('*')\n    .eq('user_id', user.sub); // Or use RLS to handle this automatically\n\n  if (error) {\n    console.error('Supabase error fetching channels:', error);\n    return c.json({ error: 'Failed to fetch channels', details: error.message }, 500);\n  }\n  return c.json(data);\n});\n\n// GET /api/v1/channels/:id - Get a specific channel\nchannelsApp.get('/:id', async (c) => {\n  const user = c.get('user');\n  const channelId = c.req.param('id');\n  if (!user || !user.sub) {\n    return c.json({ error: 'User not authenticated' }, 403);\n  }\n\n  const { data, error } = await supabaseAdmin // Replace with user-context client\n    .from('channels')\n    .select('*')\n    .eq('id', channelId)\n    .eq('user_id', user.sub) // Ensure user owns this channel\n    .single();\n\n  if (error) {\n    console.error(`Supabase error fetching channel ${channelId}:`, error);\n    return c.json({ error: 'Channel not found or access denied', details: error.message }, 404);\n  }\n  return c.json(data);\n});\n\n// PUT /api/v1/channels/:id - Update a channel\nchannelsApp.put('/:id', zValidator('json', updateChannelSchema), async (c) => {\n    const user = c.get('user');\n    const channelId = c.req.param('id');\n    const updateData = c.req.valid('json');\n\n    if (!user || !user.sub) {\n      return c.json({ error: 'User not authenticated' }, 403);\n    }\n\n    const { data, error } = await supabaseAdmin // Replace with user-context client\n      .from('channels')\n      .update({ ...updateData, updated_at: new Date().toISOString() })\n      .eq('id', channelId)\n      .eq('user_id', user.sub) // Ensure user owns this channel\n      .select()\n      .single();\n\n    if (error) {\n      console.error(`Supabase error updating channel ${channelId}:`, error);\n      return c.json({ error: 'Failed to update channel or channel not found', details: error.message }, error.code === 'PGRST116' ? 404 : 500);\n    }\n    return c.json(data);\n});\n\n// DELETE /api/v1/channels/:id - Delete a channel\nchannelsApp.delete('/:id', async (c) => {\n    const user = c.get('user');\n    const channelId = c.req.param('id');\n\n    if (!user || !user.sub) {\n      return c.json({ error: 'User not authenticated' }, 403);\n    }\n\n    const { error, count } = await supabaseAdmin // Replace with user-context client\n      .from('channels')\n      .delete({ count: 'exact' }) // Get the count of deleted rows\n      .eq('id', channelId)\n      .eq('user_id', user.sub); // Ensure user owns this channel\n\n    if (error) {\n      console.error(`Supabase error deleting channel ${channelId}:`, error);\n      return c.json({ error: 'Failed to delete channel', details: error.message }, 500);\n    }\n    if (count === 0) {\n        return c.json({ error: 'Channel not found or not owned by user' }, 404);\n    }\n    return c.json({ message: 'Channel deleted successfully' }, 200);\n});\n\n\nexport default channelsApp;\n```\n\n---\n\n**6. V1 API Router (`src/api/v1/index.ts`)**\n\n```typescript\n// src/api/v1/index.ts\nimport { Hono } from 'hono';\nimport channelsApp from './channels';\n// Import other resource routers here (messages, leads, etc.)\n// import messagesApp from './messages';\n\nconst v1App = new Hono();\n\nv1App.route('/channels', channelsApp);\n// v1App.route('/messages', messagesApp);\n// ... other routes\n\nexport default v1App;\n```\n\n---\n\n**7. Example Webhook (`src/webhooks/whatsapp.ts`)**\n\nThis is a very basic placeholder. Real WhatsApp webhooks require signature verification.\n\n```typescript\n// src/webhooks/whatsapp.ts\nimport { Hono } from 'hono';\nimport { supabaseAdmin } from '@/core/supabase'; // For storing messages\n\nconst whatsappWebhookApp = new Hono();\n\n// This secret should be part of your webhook URL or checked via a header\nconst WEBHOOK_VERIFY_TOKEN = process.env.WHATSAPP_WEBHOOK_VERIFY_TOKEN || \"your_very_secret_token\";\n\n// WhatsApp Webhook Verification (GET request)\nwhatsappWebhookApp.get('/', async (c) => {\n  const mode = c.req.query('hub.mode');\n  const token = c.req.query('hub.verify_token');\n  const challenge = c.req.query('hub.challenge');\n\n  if (mode && token) {\n    if (mode === 'subscribe' && token === WEBHOOK_VERIFY_TOKEN) {\n      console.log('WhatsApp Webhook verified');\n      return c.text(challenge!, 200);\n    } else {\n      console.warn('WhatsApp Webhook verification failed: Invalid token or mode');\n      return c.text('Forbidden', 403);\n    }\n  }\n  return c.text('Missing query parameters for verification', 400);\n});\n\n\n// WhatsApp Inbound Message Handler (POST request)\nwhatsappWebhookApp.post('/', async (c) => {\n  const body = await c.req.json();\n  console.log('Received WhatsApp Webhook Payload:', JSON.stringify(body, null, 2));\n\n  // IMPORTANT: Implement WhatsApp Signature Verification here!\n  // const signature = c.req.header('X-Hub-Signature-256');\n  // const rawBody = await c.req.raw.clone().text(); // Hono might need a different way to get raw body if consumed\n  // if (!verifyWhatsappSignature(rawBody, signature, process.env.WHATSAPP_APP_SECRET)) {\n  //   console.warn('Invalid WhatsApp signature');\n  //   return c.text('Invalid signature', 403);\n  // }\n\n  // Process the payload (simplified example)\n  // This structure is based on Meta's Cloud API\n  if (body.object === 'whatsapp_business_account') {\n    body.entry?.forEach((entry: any) => {\n      entry.changes?.forEach(async (change: any) => {\n        if (change.field === 'messages') {\n          const messageData = change.value.messages?.[0];\n          if (messageData) {\n            const from = messageData.from; // Sender phone number\n            const messageType = messageData.type;\n            let textContent = null;\n\n            if (messageType === 'text') {\n              textContent = messageData.text.body;\n            } else if (messageType === 'image') {\n              // Handle image (messageData.image.id to download)\n              textContent = \"[Image Received]\";\n            } // Add more types: audio, video, document, location, contacts, interactive\n\n            console.log(`Message from ${from}: ${textContent || `[${messageType}]`}`);\n\n            // Example: Store in Supabase (highly simplified)\n            // You'd need to:\n            // 1. Find or create a contact based on 'from' number.\n            // 2. Find the correct channel_id.\n            // 3. Store the message.\n            try {\n              const { error } = await supabaseAdmin.from('messages_log').insert({\n                external_id: messageData.id,\n                sender_identifier: from,\n                receiver_identifier: change.value.metadata.display_phone_number, // Your WA number\n                channel_type: 'whatsapp',\n                content: textContent || `Unsupported type: ${messageType}`,\n                payload: messageData, // Store the full payload for debugging/later processing\n                direction: 'inbound',\n                timestamp: new Date(parseInt(messageData.timestamp) * 1000),\n              });\n              if (error) console.error(\"Error saving message to DB:\", error);\n            } catch (dbError) {\n              console.error(\"DB Insert Exception:\", dbError);\n            }\n          }\n        }\n      });\n    });\n  }\n\n  return c.text('EVENT_RECEIVED', 200); // Meta expects a 200 OK quickly\n});\n\nexport default whatsappWebhookApp;\n```\n*Note: `messages_log` is a hypothetical table. You'd use your `messages` table.*\n\n---\n\n**8. Main Hono App (`src/index.ts`)**\n\n```typescript\n// src/index.ts\nimport { Hono } from 'hono';\nimport { cors } from 'hono/cors';\nimport { logger } from 'hono/logger';\nimport { secureHeaders } from 'hono/secure-headers';\nimport { prettyJSON } from 'hono/pretty-json';\nimport 'dotenv/config';\n\nimport v1ApiApp from './api/v1';\nimport whatsappWebhookApp from './webhooks/whatsapp';\n// Import other webhook routers\n// import telegramWebhookApp from './webhooks/telegram';\n\nimport { HonoEnv } from './types';\n\nconst app = new Hono<HonoEnv>();\n\n// --- Global Middleware ---\napp.use('*', logger()); // Basic request logger\napp.use('*', prettyJSON()); // Pretty print JSON responses\napp.use('*', secureHeaders()); // Adds security-related headers\napp.use(\n  '/api/*', // Apply CORS only to API routes, or '*' for all\n  cors({\n    origin: ['http://localhost:3001', 'https://your-nextjs-app.com', 'https://your-nuxt-app.com'], // Your frontend URLs\n    allowMethods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],\n    allowHeaders: ['Content-Type', 'Authorization'],\n    credentials: true,\n  })\n);\n\n// --- Routes ---\napp.get('/', (c) => {\n  return c.json({ message: 'Omnichannel API is alive!' });\n});\n\n// API Version 1\napp.route('/api/v1', v1ApiApp);\n\n// Webhooks\napp.route('/webhooks/whatsapp', whatsappWebhookApp);\n// app.route('/webhooks/telegram', telegramWebhookApp);\n// ... other webhooks\n\n// --- Error Handling ---\napp.onError((err, c) => {\n  console.error(`Unhandled error: ${err}`, err.stack);\n  // Check if it's a HonoHTTPException for specific status codes\n  if (err instanceof Error && 'status' in err) {\n    return c.json({ error: 'An error occurred', message: err.message }, (err as any).status || 500);\n  }\n  return c.json({ error: 'Internal Server Error', message: err.message || 'Something went wrong' }, 500);\n});\n\napp.notFound((c) => {\n  return c.json({ error: 'Not Found', message: `The path ${c.req.path} was not found.` }, 404);\n});\n\n\n// --- Server ---\nconst port = parseInt(process.env.PORT || '3000');\nconsole.log(`Server is running on port ${port}`);\n\n// For local development with Node.js\n// In production, you might deploy this to a serverless environment\n// or use a process manager like PM2.\nexport default {\n  port: port,\n  fetch: app.fetch,\n};\n\n// If you want to run directly with `ts-node src/index.ts`\n// (needs `serve` from `@hono/node-server` or similar)\n/*\nimport { serve } from '@hono/node-server'\nif (process.env.NODE_ENV !== 'test') { // Avoid running server during tests\n  serve({\n    fetch: app.fetch,\n    port: port\n  }, info => {\n    console.log(`Hono server listening on http://localhost:${info.port}`)\n  })\n}\n*/\n```\n\n---\n\n**9. Client-Side Tracker (`public/tracker.js` - Conceptual)**\n\nThis is a very simplified example. A real tracker would be more robust.\n\n```javascript\n// public/tracker.js\n(function() {\n  const API_ENDPOINT = 'YOUR_API_URL/api/v1/track/event'; // Replace with your actual API endpoint\n  let userCookieId = null;\n\n  function getCookie(name) {\n    const value = `; ${document.cookie}`;\n    const parts = value.split(`; ${name}=`);\n    if (parts.length === 2) return parts.pop().split(';').shift();\n    return null;\n  }\n\n  function setCookie(name, value, days) {\n    let expires = \"\";\n    if (days) {\n      const date = new Date();\n      date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));\n      expires = \"; expires=\" + date.toUTCString();\n    }\n    document.cookie = name + \"=\" + (value || \"\") + expires + \"; path=/; SameSite=Lax\";\n  }\n\n  function generateUUID() { // Basic UUID generator\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n      var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\n      return v.toString(16);\n    });\n  }\n\n  function initTracker() {\n    userCookieId = getCookie('_omni_tracker_uid');\n    if (!userCookieId) {\n      userCookieId = generateUUID();\n      setCookie('_omni_tracker_uid', userCookieId, 365); // Cookie for 1 year\n    }\n    console.log('OmniTracker Initialized. User ID:', userCookieId);\n    trackPageView(); // Track initial page view\n    attachEventListeners();\n  }\n\n  function trackEvent(eventName, properties = {}) {\n    const payload = {\n      event_name: eventName,\n      page_url: window.location.href,\n      user_cookie_id: userCookieId,\n      properties: properties,\n      timestamp: new Date().toISOString(),\n      // You could also try to capture GTM client ID or FB fbp/fbc if available\n      // gtm_client_id: getGtmClientId(),\n    };\n\n    console.log('Tracking Event:', payload);\n\n    navigator.sendBeacon(API_ENDPOINT, JSON.stringify(payload));\n    // Or use fetch with keepalive for more reliability if sendBeacon is not sufficient\n    /*\n    fetch(API_ENDPOINT, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(payload),\n      keepalive: true // Important for requests during page unload\n    }).catch(error => console.error('Error sending tracking event:', error));\n    */\n  }\n\n  function trackPageView() {\n    trackEvent('page_view', { title: document.title });\n  }\n\n  function attachEventListeners() {\n    // Example: Track clicks on buttons with a specific data attribute\n    document.addEventListener('click', function(event) {\n      let targetElement = event.target;\n      // Traverse up the DOM tree if the clicked element is nested\n      while (targetElement && targetElement !== document.body) {\n        if (targetElement.matches('[data-omni-track-click]')) {\n          const eventName = targetElement.getAttribute('data-omni-track-click') || 'button_click';\n          const eventProps = {};\n          // Collect other data attributes as properties\n          for (const attr of targetElement.attributes) {\n            if (attr.name.startsWith('data-omni-prop-')) {\n              eventProps[attr.name.substring('data-omni-prop-'.length)] = attr.value;\n            }\n          }\n          eventProps.element_id = targetElement.id || null;\n          eventProps.element_text = targetElement.innerText?.substring(0,100) || targetElement.value?.substring(0,100) || null;\n\n          trackEvent(eventName, eventProps);\n          break; // Stop traversing once a trackable element is found\n        }\n        targetElement = targetElement.parentElement;\n      }\n    }, true); // Use capture phase to get event early\n  }\n\n  // --- GTM & Facebook Pixel Integration (Conceptual) ---\n  // This part would be more complex in reality.\n  function integrateWithGTM(eventName, properties) {\n    if (window.dataLayer) {\n      window.dataLayer.push({\n        'event': `omni_${eventName}`, // Prefix to avoid conflicts\n        ...properties\n      });\n    }\n  }\n\n  function integrateWithFacebookPixel(eventName, properties) {\n    if (window.fbq) {\n      // Map your eventName",
      ],
    },
    {
      role: "user",
      parts: [
        "porque nao fazemos o armazenamento das integracoes assim:? me explique tambem.. vi isso no n8n\nimport type { AxiosRequestConfig, Method, RawAxiosRequestHeaders } from 'axios';\nimport axios from 'axios';\nimport { ApplicationError, jsonParse, type GenericValue, type IDataObject } from 'n8n-workflow';\nimport { parse } from 'flatted';\nimport { assert } from '@n8n/utils/assert';\n\nimport { BROWSER_ID_STORAGE_KEY } from '@/constants';\nimport type { IExecutionFlattedResponse, IExecutionResponse, IRestApiContext } from '@/Interface';\n\nconst getBrowserId = () => {\n\tlet browserId = localStorage.getItem(BROWSER_ID_STORAGE_KEY);\n\tif (!browserId) {\n\t\tbrowserId = crypto.randomUUID();\n\t\tlocalStorage.setItem(BROWSER_ID_STORAGE_KEY, browserId);\n\t}\n\treturn browserId;\n};\n\nexport const NO_NETWORK_ERROR_CODE = 999;\nexport const STREAM_SEPERATOR = '⧉⇋⇋➽⌑⧉§§\\n';\n\nexport class ResponseError extends ApplicationError {\n\t// The HTTP status code of response\n\thttpStatusCode?: number;\n\n\t// The error code in the response\n\terrorCode?: number;\n\n\t// The stack trace of the server\n\tserverStackTrace?: string;\n\n\t/**\n\t * Creates an instance of ResponseError.\n\t * @param {string} message The error message\n\t * @param {number} [errorCode] The error code which can be used by frontend to identify the actual error\n\t * @param {number} [httpStatusCode] The HTTP status code the response should have\n\t * @param {string} [stack] The stack trace\n\t */\n\tconstructor(\n\t\tmessage: string,\n\t\toptions: { errorCode?: number; httpStatusCode?: number; stack?: string } = {},\n\t) {\n\t\tsuper(message);\n\t\tthis.name = 'ResponseError';\n\n\t\tconst { errorCode, httpStatusCode, stack } = options;\n\t\tif (errorCode) {\n\t\t\tthis.errorCode = errorCode;\n\t\t}\n\t\tif (httpStatusCode) {\n\t\t\tthis.httpStatusCode = httpStatusCode;\n\t\t}\n\t\tif (stack) {\n\t\t\tthis.serverStackTrace = stack;\n\t\t}\n\t}\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst legacyParamSerializer = (params: Record<string, any>) =>\n\tObject.keys(params)\n\t\t.filter((key) => params[key] !== undefined)\n\t\t.map((key) => {\n\t\t\tif (Array.isArray(params[key])) {\n\t\t\t\treturn params[key].map((v: string) => `${key}[]=${encodeURIComponent(v)}`).join('&');\n\t\t\t}\n\t\t\tif (typeof params[key] === 'object') {\n\t\t\t\tparams[key] = JSON.stringify(params[key]);\n\t\t\t}\n\t\t\treturn `${key}=${encodeURIComponent(params[key])}`;\n\t\t})\n\t\t.join('&');\n\nexport async function request(config: {\n\tmethod: Method;\n\tbaseURL: string;\n\tendpoint: string;\n\theaders?: RawAxiosRequestHeaders;\n\tdata?: GenericValue | GenericValue[];\n\twithCredentials?: boolean;\n}) {\n\tconst { method, baseURL, endpoint, headers, data } = config;\n\tconst options: AxiosRequestConfig = {\n\t\tmethod,\n\t\turl: endpoint,\n\t\tbaseURL,\n\t\theaders: headers ?? {},\n\t};\n\tif (baseURL.startsWith('/')) {\n\t\toptions.headers!['browser-id'] = getBrowserId();\n\t}\n\tif (\n\t\timport.meta.env.NODE_ENV !== 'production' &&\n\t\t!baseURL.includes('api.n8n.io') &&\n\t\t!baseURL.includes('n8n.cloud')\n\t) {\n\t\toptions.withCredentials = options.withCredentials ?? true;\n\t}\n\tif (['POST', 'PATCH', 'PUT'].includes(method)) {\n\t\toptions.data = data;\n\t} else if (data) {\n\t\toptions.params = data;\n\t\toptions.paramsSerializer = legacyParamSerializer;\n\t}\n\n\ttry {\n\t\tconst response = await axios.request(options);\n\t\treturn response.data;\n\t} catch (error) {\n\t\tif (error.message === 'Network Error') {\n\t\t\tthrow new ResponseError(\"Can't connect to n8n.\", {\n\t\t\t\terrorCode: NO_NETWORK_ERROR_CODE,\n\t\t\t});\n\t\t}\n\n\t\tconst errorResponseData = error.response?.data;\n\t\tif (errorResponseData?.message !== undefined) {\n\t\t\tif (errorResponseData.name === 'NodeApiError') {\n\t\t\t\terrorResponseData.httpStatusCode = error.response.status;\n\t\t\t\tthrow errorResponseData;\n\t\t\t}\n\n\t\t\tthrow new ResponseError(errorResponseData.message, {\n\t\t\t\terrorCode: errorResponseData.code,\n\t\t\t\thttpStatusCode: error.response.status,\n\t\t\t\tstack: errorResponseData.stack,\n\t\t\t});\n\t\t}\n\n\t\tthrow error;\n\t}\n}\n\n/**\n * Sends a request to the API and returns the response without extracting the data key.\n * @param context Rest API context\n * @param method HTTP method\n * @param endpoint relative path to the API endpoint\n * @param data request data\n * @returns data and total count\n */\nexport async function getFullApiResponse<T>(\n\tcontext: IRestApiContext,\n\tmethod: Method,\n\tendpoint: string,\n\tdata?: GenericValue | GenericValue[],\n) {\n\tconst response = await request({\n\t\tmethod,\n\t\tbaseURL: context.baseUrl,\n\t\tendpoint,\n\t\theaders: { 'push-ref': context.pushRef },\n\t\tdata,\n\t});\n\n\treturn response as { count: number; data: T };\n}\n\nexport async function makeRestApiRequest<T>(\n\tcontext: IRestApiContext,\n\tmethod: Method,\n\tendpoint: string,\n\tdata?: GenericValue | GenericValue[],\n) {\n\tconst response = await request({\n\t\tmethod,\n\t\tbaseURL: context.baseUrl,\n\t\tendpoint,\n\t\theaders: { 'push-ref': context.pushRef },\n\t\tdata,\n\t});\n\n\t// @ts-ignore all cli rest api endpoints return data wrapped in `data` key\n\treturn response.data as T;\n}\n\nexport async function get(\n\tbaseURL: string,\n\tendpoint: string,\n\tparams?: IDataObject,\n\theaders?: RawAxiosRequestHeaders,\n) {\n\treturn await request({ method: 'GET', baseURL, endpoint, headers, data: params });\n}\n\nexport async function post(\n\tbaseURL: string,\n\tendpoint: string,\n\tparams?: IDataObject,\n\theaders?: RawAxiosRequestHeaders,\n) {\n\treturn await request({ method: 'POST', baseURL, endpoint, headers, data: params });\n}\n\nexport async function patch(\n\tbaseURL: string,\n\tendpoint: string,\n\tparams?: IDataObject,\n\theaders?: RawAxiosRequestHeaders,\n) {\n\treturn await request({ method: 'PATCH', baseURL, endpoint, headers, data: params });\n}\n\n/**\n * Unflattens the Execution data.\n *\n * @param {IExecutionFlattedResponse} fullExecutionData The data to unflatten\n */\nexport function unflattenExecutionData(fullExecutionData: IExecutionFlattedResponse) {\n\t// Unflatten the data\n\tconst returnData: IExecutionResponse = {\n\t\t...fullExecutionData,\n\t\tworkflowData: fullExecutionData.workflowData,\n\t\tdata: parse(fullExecutionData.data),\n\t};\n\n\treturnData.finished = returnData.finished ? returnData.finished : false;\n\n\tif (fullExecutionData.id) {\n\t\treturnData.id = fullExecutionData.id;\n\t}\n\n\treturn returnData;\n}\n\nexport async function streamRequest<T extends object>(\n\tcontext: IRestApiContext,\n\tapiEndpoint: string,\n\tpayload: object,\n\tonChunk?: (chunk: T) => void,\n\tonDone?: () => void,\n\tonError?: (e: Error) => void,\n\tseparator = STREAM_SEPERATOR,\n): Promise<void> {\n\tconst headers: Record<string, string> = {\n\t\t'browser-id': getBrowserId(),\n\t\t'Content-Type': 'application/json',\n\t};\n\tconst assistantRequest: RequestInit = {\n\t\theaders,\n\t\tmethod: 'POST',\n\t\tcredentials: 'include',\n\t\tbody: JSON.stringify(payload),\n\t};\n\ttry {\n\t\tconst response = await fetch(`${context.baseUrl}${apiEndpoint}`, assistantRequest);\n\n\t\tif (response.body) {\n\t\t\t// Handle the streaming response\n\t\t\tconst reader = response.body.getReader();\n\t\t\tconst decoder = new TextDecoder('utf-8');\n\n\t\t\tlet buffer = '';\n\n\t\t\tasync function readStream() {\n\t\t\t\tconst { done, value } = await reader.read();\n\t\t\t\tif (done) {\n\t\t\t\t\tonDone?.();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst chunk = decoder.decode(value);\n\t\t\t\tbuffer += chunk;\n\n\t\t\t\tconst splitChunks = buffer.split(separator);\n\n\t\t\t\tbuffer = '';\n\t\t\t\tfor (const splitChunk of splitChunks) {\n\t\t\t\t\tif (splitChunk) {\n\t\t\t\t\t\tlet data: T;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tdata = jsonParse<T>(splitChunk, { errorMessage: 'Invalid json' });\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t// incomplete json. append to buffer to complete\n\t\t\t\t\t\t\tbuffer += splitChunk;\n\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif (response.ok) {\n\t\t\t\t\t\t\t\t// Call chunk callback if request was successful\n\t\t\t\t\t\t\t\tonChunk?.(data);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Otherwise, call error callback\n\t\t\t\t\t\t\t\tconst message = 'message' in data ? data.message : response.statusText;\n\t\t\t\t\t\t\t\tonError?.(\n\t\t\t\t\t\t\t\t\tnew ResponseError(String(message), {\n\t\t\t\t\t\t\t\t\t\thttpStatusCode: response.status,\n\t\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (e: unknown) {\n\t\t\t\t\t\t\tif (e instanceof Error) {\n\t\t\t\t\t\t\t\tonError?.(e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tawait readStream();\n\t\t\t}\n\n\t\t\t// Start reading the stream\n\t\t\tawait readStream();\n\t\t} else if (onError) {\n\t\t\tonError(new Error(response.statusText));\n\t\t}\n\t} catch (e: unknown) {\n\t\tassert(e instanceof Error);\n\t\tonError?.(e);\n\t}\n}",
      ],
    },
    {
      role: "model",
      parts: [
        "**Examining API Abstraction**\n\nI'm currently focused on the user's central inquiry: why not employ a client-side API abstraction, similar to n8n's, rather than the approach of Hono/Supabase? I'm digging into the potential benefits and drawbacks, considering factors like flexibility, maintainability, and initial development time. The current thinking is that understanding the fundamental differences in architectural approaches will be key to a clear and concise explanation.\n\n\n**Assessing Code Structure**\n\nI've been analyzing the n8n code, particularly `request()`, and noticing its use of `axios` as a base. I'm focusing on how it handles requests, error mapping, and data serialization. I'm also examining the wrappers around `request`, aiming to grasp how n8n tailors the abstraction for its specific API needs. The use of `flatted` for complex data de-serialization is of interest.\n\n\n**Clarifying Request Structure**\n\nI'm now zeroing in on how `request()` handles HTTP methods, `baseURL`, and headers. The customization of `paramsSerializer` is particularly interesting. I'm noting how `request()` is built for flexibility within n8n's API context, looking at how it integrates custom error mapping. Then, I'll be comparing it to alternative approaches used by Hono/Supabase.\n\n\n**Comparing Abstraction Approaches**\n\nI'm now focusing on the client-side benefits of n8n's approach versus the server-side focus of Hono/Supabase. The key is to understand how each strategy impacts initial setup, flexibility, and maintenance. I'm considering the potential overhead of managing a client-side API abstraction in the user's context, where a robust server-side API may offer advantages. I'm exploring the trade-offs.\n\n\n**Understanding `streamRequest`**\n\nI'm now focusing on `streamRequest()` in the n8n code and how it handles streaming data with `fetch`. I'm examining its reliance on a custom separator and how it's designed to process and parse streamed responses effectively. I'm also considering the implications of server-sent events for our Hono API.\n\n\n**Comparing Client and Server Roles**\n\nI'm now focusing on the fundamental difference: n8n's code acts as a client-side API helper, whereas Hono/Supabase define the server-side API. The user will still need client-side code similar to n8n's `request()` to consume the Hono API. My goal is to clearly illustrate the distinct responsibilities of client-side and server-side components. This comparison seeks to clarify their respective roles.\n\n\n**Delineating Component Roles**\n\nI'm now clarifying the key distinction: the n8n code serves as a client-side API helper, while Hono/Supabase define the server-side API. The user will still need client-side code similar to n8n's `request()` to interact with the Hono API. My goal is to delineate the distinct responsibilities of client-side and server-side components.\n\n\n**Distinguishing Roles and Tasks**\n\nI'm now recognizing the n8n code functions as a client-side utility, which differs from Hono/Supabase's API approach. To be clear, the user *will* need a client-side request library for their Next/Nuxt app. The Hono API will use server-side logic for its outbound integrations. I will clarify this in detail.\n\n\n**Comparing and Contrasting Roles**\n\nI'm now focusing on the core difference: n8n's code serves as a client-side API helper, while Hono/Supabase define a server-side API.  The user will still need client-side code similar to n8n's `request()` to consume the Hono API. My goal is to clearly distinguish their roles.\n\n\n",
        "Você está mostrando um trecho de código JavaScript/TypeScript que é uma **camada de cliente (client-side)** para interagir com uma API REST, especificamente a API do n8n. Este código é muito bem estruturado e lida com vários aspectos importantes da comunicação cliente-servidor.\n\nVamos quebrar o código do n8n e depois discutir como isso se relaciona com a sua API Hono/Supabase e o conceito de \"integrações\".\n\n**Explicação do Código do n8n:**\n\nEste código é essencialmente um SDK ou um conjunto de utilitários para que a interface do usuário (frontend) do n8n possa fazer requisições para o backend do n8n de forma padronizada e robusta.\n\n1.  **`getBrowserId()`**:\n    *   **Propósito**: Cria e armazena um identificador único para o navegador do usuário no `localStorage`.\n    *   **Uso**: Provavelmente usado para rastreamento, analytics, ou para associar certas ações/configurações do lado do cliente a um navegador específico, especialmente se o usuário não estiver logado.\n    *   **No seu projeto**: Você poderia ter algo similar no seu `tracker.js` para gerar o `user_cookie_id`.\n\n2.  **`STREAM_SEPERATOR`**:\n    *   **Propósito**: Uma string delimitadora customizada usada na funcionalidade de streaming para separar chunks de dados.\n    *   **Uso**: Quando o servidor envia dados em streaming (múltiplos pacotes), esse separador ajuda o cliente a identificar o final de cada pacote JSON.\n\n3.  **`ResponseError`**:\n    *   **Propósito**: Uma classe de erro customizada que estende `ApplicationError`. Permite padronizar os erros vindos da API, incluindo `httpStatusCode`, `errorCode` (um código de erro específico da aplicação) e `serverStackTrace`.\n    *   **Uso**: Melhora o tratamento de erros no frontend, permitindo que a UI reaja de forma mais específica a diferentes tipos de problemas.\n    *   **No seu projeto**: Sua API Hono também deve retornar erros padronizados. O frontend (Next/Nuxt) que consumir sua API Hono se beneficiaria de uma classe de erro similar para tratar as respostas da sua API.\n\n4.  **`legacyParamSerializer()`**:\n    *   **Propósito**: Serializa parâmetros de requisição para o formato `query string`. Lida com arrays (ex: `key[]=value1&key[]=value2`) e objetos (serializando-os como JSON string).\n    *   **Uso**: Garante que os parâmetros sejam enviados corretamente em requisições GET ou quando os dados são passados via URL.\n\n5.  **`request()`**:\n    *   **Propósito**: É o coração da comunicação com a API. Um wrapper em torno do `axios` (uma popular biblioteca HTTP client).\n    *   **Características**:\n        *   Recebe `method`, `baseURL`, `endpoint`, `headers`, `data`.\n        *   Adiciona o `browser-id` ao header se a `baseURL` for relativa (indicando uma chamada para o próprio backend do n8n).\n        *   Configura `withCredentials` (importante para cookies em desenvolvimento).\n        *   Coloca `data` no corpo da requisição para POST/PATCH/PUT e como `params` (query string) para outros métodos.\n        *   Usa o `legacyParamSerializer` para serializar `params`.\n        *   **Tratamento de Erro**: Captura erros do Axios.\n            *   Se for \"Network Error\", lança um `ResponseError` específico.\n            *   Se a resposta do erro da API tiver `message`, `code`, `stack`, ele os usa para criar um `ResponseError` mais detalhado.\n            *   Se for um erro específico do nó n8n (`NodeApiError`), ele repassa esse erro.\n    *   **No seu projeto**: Seu frontend Next/Nuxt precisará de uma função similar (ou usará bibliotecas como SWR, TanStack Query, ou o próprio Axios/fetch) para fazer chamadas à sua API Hono.\n\n6.  **`getFullApiResponse()` e `makeRestApiRequest()`**:\n    *   **Propósito**: Funções utilitárias que usam `request()` mas são adaptadas à estrutura de resposta específica da API do n8n. `getFullApiResponse` espera uma resposta como `{ count: number, data: T }`, enquanto `makeRestApiRequest` espera que os dados estejam diretamente em uma chave `data`.\n    *   **Uso**: Simplificam o código que consome a API, já tratando da extração dos dados.\n\n7.  **`get()`, `post()`, `patch()`**:\n    *   **Propósito**: Funções de conveniência que chamam `request()` com o método HTTP correspondente.\n\n8.  **`unflattenExecutionData()`**:\n    *   **Propósito**: Deserializa dados de execução de workflows do n8n. Usa `flatted.parse`.\n    *   **Uso**: `flatted` é usado para serializar/desserializar estruturas de dados complexas que podem conter referências circulares, o que pode acontecer em dados de workflows.\n    *   **No seu projeto**: Você provavelmente não precisará disso a menos que sua API retorne estruturas de dados muito complexas com referências circulares (o que geralmente é evitado em APIs REST típicas).\n\n9.  **`streamRequest()`**:\n    *   **Propósito**: Lida com requisições que esperam uma resposta em *streaming* (o servidor envia dados continuamente em vez de uma única resposta).\n    *   **Mecanismo**:\n        *   Usa a API `fetch` nativa do navegador.\n        *   Configura `credentials: 'include'` (para enviar cookies).\n        *   Lê o `response.body` (que é um `ReadableStream`).\n        *   Usa `TextDecoder` para converter os bytes recebidos em texto.\n        *   Acumula os dados em um `buffer` e tenta separar os `chunks` usando o `STREAM_SEPERATOR`.\n        *   Para cada `chunk` completo, tenta fazer o `jsonParse`.\n        *   Chama `onChunk` para cada pedaço de dado recebido e `onDone` quando o stream termina.\n        *   Trata erros de parsing ou de resposta HTTP.\n    *   **No seu projeto**: Se sua API Hono precisar fornecer endpoints de streaming (por exemplo, para atualizações de chat ao vivo, progresso de tarefas longas, respostas de IA em streaming), o seu frontend Next/Nuxt usaria uma função como esta para consumir esses streams.\n\n**Por que não fazemos o armazenamento das integrações assim?**\n\nA pergunta é um pouco ambígua, mas vou interpretar \"armazenamento das integrações\" como a forma como o **seu backend (API Hono) se integra com serviços de terceiros** (WhatsApp, Telegram, Gemini, etc.).\n\nO código do n8n que você mostrou é para o **CLIENTE (frontend) interagir com o SERVIDOR (backend do n8n)**.\n\nSua API Hono é o **SERVIDOR**. Quando sua API Hono precisa:\n\n1.  **Receber dados de integrações (Inbound Webhooks):**\n    *   Ex: WhatsApp envia uma mensagem para `/webhooks/whatsapp` na sua API Hono.\n    *   Neste caso, sua API Hono é o *servidor* que recebe a requisição. O código do n8n não se aplica diretamente aqui, pois ele é para *fazer* requisições, não para *recebê-las*.\n\n2.  **Enviar dados para integrações (Outbound API Calls):**\n    *   Ex: Sua API Hono precisa enviar uma mensagem via API do WhatsApp, ou pedir uma completion para a API do Gemini.\n    *   Neste caso, sua API Hono atua como um *cliente* para essas APIs de terceiros. **Aqui, sim, sua API Hono usaria uma lógica similar à função `request()` do n8n, mas do lado do servidor.**\n        *   Você usaria `fetch` (nativo no Node.js recente), `axios`, ou outra biblioteca HTTP no seu código Hono para fazer essas chamadas.\n        *   Você precisaria lidar com URLs base, endpoints, headers (como `Authorization` com API keys), corpo da requisição e tratamento de respostas/erros dessas APIs externas.\n\n**Onde o código do n8n é relevante para VOCÊ:**\n\n1.  **Para o seu Frontend (Next.js/Nuxt.js):**\n    *   Seu aplicativo Next.js ou Nuxt.js (que será o cliente da sua API Hono) **PRECISARÁ** de um código muito similar ao que você mostrou para fazer chamadas à sua API Hono.\n    *   Você pode criar seus próprios utilitários `request`, `get`, `post` usando `fetch` ou `axios` no seu frontend, ou usar bibliotecas de data fetching como SWR (React) ou TanStack Query (Vue/React/Solid) que abstraem muito dessa lógica.\n    *   A classe `ResponseError` e o tratamento de erros são boas inspirações.\n    *   A função `streamRequest` é relevante se sua API Hono tiver endpoints de streaming que seu frontend precise consumir.\n\n2.  **Para a sua API Hono (quando ela chama OUTRAS APIs):**\n    *   A *lógica* dentro da função `request()` do n8n (configurar URL, headers, body, fazer a chamada, tratar a resposta) é o que você fará dentro dos seus serviços/módulos na API Hono quando ela precisar se comunicar com o WhatsApp, Telegram, Gemini, etc.\n    *   Você não usaria `localStorage` ou `browser-id` no backend, mas sim API keys e outros métodos de autenticação de servidor para servidor.\n\n**Em resumo:**\n\n*   O código do n8n é uma excelente referência para construir a **camada de comunicação entre seu frontend (Next/Nuxt) e sua API Hono.**\n*   Para as **integrações onde sua API Hono chama APIs de terceiros**, você implementará uma lógica de cliente HTTP semelhante *dentro do seu código Hono no servidor*, usando ferramentas do Node.js/Deno.\n\nA confusão pode surgir porque o termo \"integração\" pode significar tanto \"meu sistema se integra com X (chamando a API de X)\" quanto \"X se integra com meu sistema (chamando a API do meu sistema)\". O código do n8n é para o primeiro caso, do ponto de vista de um cliente de navegador. Sua API Hono fará os dois.",
      ],
    },
    {
      role: "user",
      parts: [
        "entao como ficaria o schema final do banco de dados, e a estrutura da nossa api? pra suportar multiplas integracoes... e as demais features\n\n",
      ],
    },
    {
      role: "model",
      parts: [
        "**Refining API Requirements**\n\nI've been meticulously examining the user's need for a multi-integration, omnichannel API. My focus is now on meticulously dissecting the various features requested within the messaging framework. The initial challenge lies in mapping these user-defined features into a structured database schema and subsequent API endpoints. I am starting by outlining core entities and establishing their critical relationships.\n\n\n**Establishing the Data Model**\n\nI'm now focusing on the data model that will underpin the API. Key entities are becoming clear: Users, Organizations, Channels, and Contacts. My strategy is to map the user's requested features directly into database tables, ensuring data integrity. I'm prioritizing the relationship between users and organizations, as this will define the scope of all other data. Securing channels and their credentials is paramount.\n\n\n**Developing the Data Structure**\n\nMy focus is now on mapping the user's features into concrete data structures. I've expanded on the established entities, including the crucial multi-tenant architecture with `organizations`. I am outlining the 'Channels' table, which I'll extend to include channel-specific attributes for each integration type.  The 'Contacts' table is being expanded to accommodate multi-channel identifiers. Finally, I'm refining the messaging and interaction logging, with the addition of analytics and AI tables.\n\n\n**Constructing Core Entities**\n\nMy current focus is on solidifying the data model, now considering the comprehensive features list. I've begun to define the key entities, starting with `users` and `organizations`. I'm meticulously considering the relationships and potential fields within each entity, including timestamps and foreign keys. Further, I'm structuring a `contacts` table, ensuring it's tied to an `organization_id`.\n\n\n**Outlining API Infrastructure**\n\nMy focus has shifted to the API structure, and I'm detailing the key aspects for optimal organization. I've begun planning endpoints for core entities like channels, contacts, and messages, using RESTful principles. I am developing authentication and validation middlewares, incorporating best practices. I'm also planning modular routers to streamline the API design and ensure maintainability.\n\n\n**Defining the Data Structure**\n\nMy focus is on fleshing out the database structure to enable all the requested features. I'm now establishing a table for contact identifiers to facilitate cross-channel tracking. Moreover, I'm working on the data model for the AI interactions and content caching. I'm prioritizing the user authentication via Supabase and integrating it with the user data.\n\n\n**Defining API Endpoints**\n\nI'm currently working on defining API endpoints using RESTful principles. Key focus areas include authentication and validation middleware. Using modular routers within Hono, I'm aiming for a structure that facilitates maintainability. My core endpoints include `/channels`, `/contacts`, and `/messages`.\n\n\n**Establishing Initial Database Design**\n\nI've completed my initial pass on the database design, primarily focusing on `users`, `organizations`, `channels`, and `contacts` tables. I am currently concentrating on incorporating message logs, including their associations with channels, contacts, and organizations. I'm also planning the design for webhooks integration.\n\n\n**Defining Webhook Integration**\n\nI am now focusing on the integration of webhooks, specifically how they will receive and process data from different channels. The structure includes creating modular and secure webhooks routes. For inbound messages, I've outlined the process of receiving data, processing, and storing into the respective tables. Furthermore, I've started the design of the `channel_credentials` for storing channel specific credentials.\n\n\n",
        "Okay, vamos refinar o esquema do banco de dados e a estrutura da API Hono para suportar múltiplas integrações e as funcionalidades que você listou, mantendo a flexibilidade.\n\n**Princípios Chave para Suportar Múltiplas Integrações:**\n\n1.  **Tabelas Genéricas com Campos de Tipo/Configuração:** Em vez de uma tabela para `whatsapp_messages` e outra para `telegram_messages`, teremos uma tabela `messages` com uma coluna `channel_type` (ou `integration_type`).\n2.  **Armazenamento Seguro de Credenciais:** As credenciais para cada integração precisam ser armazenadas de forma segura (criptografadas).\n3.  **Flexibilidade de Configuração:** Cada canal/integração terá configurações específicas. JSONB é ótimo para isso.\n4.  **Abstração de Lógica:** A API deve abstrair os detalhes de cada plataforma. Enviar uma mensagem deve ser um endpoint genérico, e a API resolve como enviá-la pela plataforma correta.\n\n---\n\n**I. Esquema Final do Banco de Dados (Supabase - PostgreSQL)**\n\nVamos assumir um modelo multi-tenant onde cada conjunto de dados pertence a uma `organization`. Se for single-tenant, você pode remover `organization_id` ou sempre usar um valor padrão.\n\n```sql\n-- Para habilitar UUIDs\nCREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";\n\n-- Organizações (se multi-tenant)\nCREATE TABLE organizations (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    name TEXT NOT NULL,\n    -- Outros detalhes da organização\n    created_at TIMESTAMPTZ DEFAULT NOW(),\n    updated_at TIMESTAMPTZ DEFAULT NOW()\n);\n\n-- Usuários (Supabase Auth já cria `auth.users`. Esta é uma tabela de perfis para dados adicionais)\nCREATE TABLE user_profiles (\n    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,\n    organization_id UUID REFERENCES organizations(id) ON DELETE SET NULL, -- Ou CASCADE se um usuário DEVE ter uma org\n    full_name TEXT,\n    avatar_url TEXT,\n    role TEXT DEFAULT 'member', -- e.g., admin, agent, member\n    -- Outras informações do perfil\n    created_at TIMESTAMPTZ DEFAULT NOW(),\n    updated_at TIMESTAMPTZ DEFAULT NOW()\n);\n-- RLS: Usuários só podem ver/editar seu próprio perfil. Admins da org podem ver perfis da org.\n\n-- Tabela para armazenar credenciais de API de forma segura (para serviços externos como Gemini, Anthropic, etc.)\n-- As credenciais de canais específicos (WhatsApp Bot Token) podem ir na tabela 'channels'\nCREATE TABLE api_credentials (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,\n    service_name TEXT NOT NULL, -- e.g., 'gemini', 'anthropic_claude', 'facebook_capi'\n    credentials_encrypted TEXT NOT NULL, -- Use pgsodium ou outra forma de criptografia\n    notes TEXT,\n    created_at TIMESTAMPTZ DEFAULT NOW(),\n    updated_at TIMESTAMPTZ DEFAULT NOW(),\n    UNIQUE (organization_id, service_name)\n);\n-- RLS: Apenas usuários autorizados da organização podem acessar/gerenciar.\n\n-- Canais de Comunicação (Integrações)\nCREATE TYPE channel_type_enum AS ENUM ('whatsapp', 'telegram', 'instagram', 'web_chat', 'email');\nCREATE TABLE channels (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,\n    name TEXT NOT NULL,\n    type channel_type_enum NOT NULL,\n    is_active BOOLEAN DEFAULT TRUE,\n    -- Configurações específicas do canal (e.g., WhatsApp Phone Number ID, Telegram Bot Token, IG Page ID)\n    -- Algumas credenciais sensíveis aqui devem ser criptografadas.\n    -- Supabase Vault é uma boa opção para segredos. Se não, use pgsodium.\n    config_jsonb JSONB,\n    credentials_jsonb JSONB, -- Para credenciais sensíveis, criptografadas.\n    last_activity_at TIMESTAMPTZ,\n    created_at TIMESTAMPTZ DEFAULT NOW(),\n    updated_at TIMESTAMPTZ DEFAULT NOW()\n);\n-- RLS: Usuários da organização podem ver/gerenciar canais da sua organização.\n-- Index: organization_id, type\n\n-- Contatos (Pessoas com quem a organização interage)\nCREATE TABLE contacts (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,\n    full_name TEXT,\n    email TEXT,\n    phone_number TEXT, -- Pode ser um número principal\n    avatar_url TEXT,\n    custom_fields JSONB, -- Campos customizados definidos pela organização\n    -- Tags, segmentos, etc. podem ser campos JSONB ou tabelas separadas\n    tags TEXT[],\n    last_seen_at TIMESTAMPTZ,\n    created_at TIMESTAMPTZ DEFAULT NOW(),\n    updated_at TIMESTAMPTZ DEFAULT NOW()\n);\n-- RLS: Usuários da organização podem ver/gerenciar contatos da sua organização.\n-- Index: organization_id, email, phone_number\n\n-- Identificadores de Contato (Como um contato é identificado em cada canal)\nCREATE TABLE contact_identifiers (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    contact_id UUID NOT NULL REFERENCES contacts(id) ON DELETE CASCADE,\n    channel_id UUID REFERENCES channels(id) ON DELETE CASCADE, -- Opcional, pode ser genérico\n    identifier_type channel_type_enum NOT NULL, -- e.g., 'whatsapp', 'telegram_user_id', 'instagram_psid'\n    value TEXT NOT NULL, -- e.g., +15551234567, 123456789 (Telegram ID), etc.\n    is_primary BOOLEAN DEFAULT FALSE,\n    created_at TIMESTAMPTZ DEFAULT NOW(),\n    UNIQUE (contact_id, identifier_type, value), -- Um contato não pode ter o mesmo ID na mesma plataforma\n    UNIQUE (identifier_type, value) -- Globalmente, um ID de plataforma deve ser único (ou escopado por org se necessário)\n);\n-- Index: contact_id, value, (identifier_type, value)\n\n-- Mensagens (Omnichannel)\nCREATE TYPE message_direction_enum AS ENUM ('inbound', 'outbound');\nCREATE TYPE message_content_type_enum AS ENUM ('text', 'image', 'video', 'audio', 'file', 'template', 'interactive', 'location', 'contacts', 'sticker');\nCREATE TYPE message_status_enum AS ENUM ('pending', 'sent', 'delivered', 'read', 'failed', 'received');\n\nCREATE TABLE messages (\n    id BIGSERIAL PRIMARY KEY, -- Usar BIGSERIAL para alta frequência de inserção\n    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,\n    channel_id UUID NOT NULL REFERENCES channels(id) ON DELETE CASCADE,\n    contact_id UUID NOT NULL REFERENCES contacts(id) ON DELETE CASCADE,\n    agent_user_id UUID REFERENCES user_profiles(id) ON DELETE SET NULL, -- Agente que enviou/tratou\n    external_message_id TEXT, -- ID da mensagem na plataforma externa (e.g., WhatsApp message ID)\n    conversation_id TEXT, -- Para agrupar mensagens em uma conversa (pode ser gerado ou vir da plataforma)\n    direction message_direction_enum NOT NULL,\n    content_type message_content_type_enum NOT NULL,\n    text_content TEXT, -- Para mensagens de texto\n    media_url TEXT, -- URL para mídias\n    media_mime_type TEXT,\n    template_data JSONB, -- Se for uma mensagem de template\n    interactive_data JSONB, -- Para botões, listas, etc.\n    metadata JSONB, -- Outros metadados da plataforma (quotes, mentions, etc.)\n    status message_status_enum DEFAULT 'pending',\n    sent_at TIMESTAMPTZ, -- Quando foi enviada da nossa API\n    delivered_at TIMESTAMPTZ, -- Quando a plataforma confirmou entrega\n    read_at TIMESTAMPTZ, -- Quando a plataforma confirmou leitura\n    timestamp TIMESTAMPTZ DEFAULT NOW(), -- Quando o evento ocorreu ou foi registrado no nosso sistema\n    created_at TIMESTAMPTZ DEFAULT NOW(),\n    updated_at TIMESTAMPTZ DEFAULT NOW()\n);\n-- RLS: Usuários da organização podem ver mensagens da sua organização.\n-- Index: organization_id, channel_id, contact_id, timestamp, external_message_id, conversation_id\n\n-- Leads\nCREATE TYPE lead_status_enum AS ENUM ('new', 'contacted', 'qualified', 'proposal_sent', 'negotiation', 'won', 'lost', 'on_hold');\nCREATE TABLE leads (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,\n    contact_id UUID REFERENCES contacts(id) ON DELETE SET NULL, -- Um lead pode ou não estar ligado a um contato existente\n    title TEXT NOT NULL,\n    description TEXT,\n    source TEXT, -- e.g., 'Website Form', 'WhatsApp Inquiry', 'Manual Entry'\n    status lead_status_enum DEFAULT 'new',\n    value NUMERIC(12, 2), -- Valor monetário do lead\n    currency CHAR(3) DEFAULT 'BRL',\n    expected_close_date DATE,\n    assigned_to_user_id UUID REFERENCES user_profiles(id) ON DELETE SET NULL,\n    custom_fields JSONB,\n    created_at TIMESTAMPTZ DEFAULT NOW(),\n    updated_at TIMESTAMPTZ DEFAULT NOW()\n);\n-- RLS: Acesso baseado na organização e possivelmente no agente assignado.\n-- Index: organization_id, status, assigned_to_user_id\n\n-- Eventos de Tracking (Analytics Proprietário)\nCREATE TABLE tracked_events (\n    id BIGSERIAL PRIMARY KEY,\n    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,\n    contact_id UUID REFERENCES contacts(id) ON DELETE SET NULL, -- Se o usuário for identificado\n    anonymous_user_id TEXT, -- e.g., cookie ID do tracker.js\n    session_id TEXT,\n    event_name TEXT NOT NULL,\n    page_url TEXT,\n    utm_source TEXT,\n    utm_medium TEXT,\n    utm_campaign TEXT,\n    utm_term TEXT,\n    utm_content TEXT,\n    referrer_url TEXT,\n    user_agent TEXT,\n    ip_address INET, -- Pode ter implicações de privacidade (GDPR)\n    properties JSONB, -- Propriedades customizadas do evento\n    gtm_data JSONB, -- Dados relevantes do GTM se capturados\n    facebook_pixel_data JSONB, -- Dados relevantes do Pixel se capturados\n    timestamp TIMESTAMPTZ DEFAULT NOW()\n);\n-- RLS: Acesso pela organização.\n-- Index: organization_id, event_name, timestamp, anonymous_user_id, contact_id\n\n-- Log de Interações com IA\nCREATE TABLE ai_interactions_log (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,\n    user_id UUID REFERENCES user_profiles(id) ON DELETE SET NULL, -- Usuário que iniciou (se aplicável)\n    channel_id UUID REFERENCES channels(id) ON DELETE SET NULL, -- Canal onde a IA foi usada (se aplicável)\n    contact_id UUID REFERENCES contacts(id) ON DELETE SET NULL, -- Contato relacionado (se aplicável)\n    provider TEXT NOT NULL, -- e.g., 'gemini', 'anthropic', 'openai'\n    model TEXT,\n    prompt_text TEXT,\n    response_text TEXT,\n    prompt_tokens INTEGER,\n    completion_tokens INTEGER,\n    cost NUMERIC(10,6),\n    request_payload JSONB,\n    response_payload JSONB,\n    metadata JSONB,\n    is_success BOOLEAN,\n    error_message TEXT,\n    duration_ms INTEGER,\n    timestamp TIMESTAMPTZ DEFAULT NOW()\n);\n-- RLS: Acesso pela organização.\n-- Index: organization_id, provider, timestamp\n\n-- Conteúdo Cacheado (e.g., de WP-Headless)\nCREATE TABLE content_cache (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,\n    source_identifier TEXT NOT NULL, -- e.g., 'wp_posts_all', 'wp_post_slug_abc'\n    content_type TEXT NOT NULL, -- e.g., 'post_list', 'single_post', 'page_data'\n    data JSONB NOT NULL,\n    last_fetched_at TIMESTAMPTZ NOT NULL,\n    expires_at TIMESTAMPTZ,\n    created_at TIMESTAMPTZ DEFAULT NOW(),\n    UNIQUE (organization_id, source_identifier)\n);\n-- RLS: Acesso pela organização.\n-- Index: organization_id, source_identifier, expires_at\n\n-- Projetos\nCREATE TYPE project_status_enum AS ENUM ('planning', 'in_progress', 'on_hold', 'completed', 'archived');\nCREATE TABLE projects (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,\n    name TEXT NOT NULL,\n    description TEXT,\n    status project_status_enum DEFAULT 'planning',\n    start_date DATE,\n    due_date DATE,\n    completed_at TIMESTAMPTZ,\n    created_by_user_id UUID REFERENCES user_profiles(id) ON DELETE SET NULL,\n    created_at TIMESTAMPTZ DEFAULT NOW(),\n    updated_at TIMESTAMPTZ DEFAULT NOW()\n);\n-- RLS: Acesso pela organização.\n-- Index: organization_id, status\n\n-- Tarefas (do Gerenciador de Projetos)\nCREATE TYPE task_status_enum AS ENUM ('todo', 'in_progress', 'review', 'done', 'blocked');\nCREATE TYPE task_priority_enum AS ENUM ('low', 'medium', 'high', 'urgent');\nCREATE TABLE tasks (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    project_id UUID NOT NULL REFERENCES projects(id) ON DELETE CASCADE,\n    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE, -- Denormalizado para RLS mais fácil\n    title TEXT NOT NULL,\n    description TEXT,\n    status task_status_enum DEFAULT 'todo',\n    priority task_priority_enum DEFAULT 'medium',\n    assigned_to_user_id UUID REFERENCES user_profiles(id) ON DELETE SET NULL,\n    due_date DATE,\n    completed_at TIMESTAMPTZ,\n    created_by_user_id UUID REFERENCES user_profiles(id) ON DELETE SET NULL,\n    parent_task_id UUID REFERENCES tasks(id) ON DELETE SET NULL, -- Para subtarefas\n    created_at TIMESTAMPTZ DEFAULT NOW(),\n    updated_at TIMESTAMPTZ DEFAULT NOW()\n);\n-- RLS: Acesso pela organização. Agentes podem ver tarefas assignadas a eles ou do projeto.\n-- Index: project_id, organization_id, status, assigned_to_user_id\n\n-- Sessões de Chat ao Vivo (pode reusar/estender `messages` ou ser uma tabela de agregação)\nCREATE TYPE live_chat_session_status_enum AS ENUM ('pending', 'active', 'on_hold', 'closed_resolved', 'closed_unresolved', 'archived');\nCREATE TABLE live_chat_sessions (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,\n    contact_id UUID NOT NULL REFERENCES contacts(id) ON DELETE CASCADE,\n    channel_id UUID NOT NULL REFERENCES channels(id) ON DELETE CASCADE,\n    initial_message_id BIGINT REFERENCES messages(id) ON DELETE SET NULL, -- Primeira msg que iniciou\n    agent_user_id UUID REFERENCES user_profiles(id) ON DELETE SET NULL, -- Agente atual da sessão\n    status live_chat_session_status_enum DEFAULT 'pending',\n    started_at TIMESTAMPTZ DEFAULT NOW(),\n    last_agent_message_at TIMESTAMPTZ,\n    last_contact_message_at TIMESTAMPTZ,\n    ended_at TIMESTAMPTZ,\n    resolution_notes TEXT,\n    custom_fields JSONB,\n    created_at TIMESTAMPTZ DEFAULT NOW(),\n    updated_at TIMESTAMPTZ DEFAULT NOW()\n);\n-- RLS: Agentes da organização podem ver/gerenciar.\n-- Index: organization_id, status, agent_user_id, contact_id\n\n-- RLS (Row Level Security) Policies:\n-- *   Cada tabela que tem `organization_id` deve ter uma política que restrinja o acesso aos usuários daquela organização.\n--     Ex: `CREATE POLICY select_org_data ON channels FOR SELECT USING (organization_id = current_setting('request.jwt.claims', true)::jsonb->>'organization_id');`\n--     (Você precisa configurar `organization_id` como uma custom claim no seu JWT Supabase).\n-- *   Políticas mais granulares para agentes vs. administradores.\n```\n\n**Observações sobre o Schema:**\n\n*   **Criptografia:** Para campos como `channels.credentials_jsonb` e `api_credentials.credentials_encrypted`, use extensões como `pgsodium` do Supabase para criptografia transparente ou gerencie a criptografia na camada da aplicação (menos ideal para consultas). Supabase Vault é a melhor opção para gerenciar segredos.\n*   **Índices:** Adicionei alguns índices básicos. Analise seus padrões de consulta para otimizar.\n*   **JSONB:** Usado extensivamente para flexibilidade (`custom_fields`, `config_jsonb`, `properties`).\n*   **Enums:** Tipos ENUM do PostgreSQL para campos com valores predefinidos melhoram a integridade dos dados.\n\n---\n\n**II. Estrutura da API Hono (Modular)**\n\n```\n/src\n  ├── index.ts            # Entry point principal da aplicação Hono, setup do servidor\n  |\n  ├── api/\n  │   └── v1/\n  │       ├── index.ts        # Router principal da v1 (agrega todos os módulos abaixo)\n  │       │\n  │       ├── middleware/\n  │       │   ├── auth.ts         # Autenticação (verifica JWT, injeta user/org no contexto)\n  │       │   ├── validation.ts   # Helpers para validação com Zod (ou usar @hono/zod-validator)\n  │       │   └── rbac.ts         # Role-Based Access Control (opcional, para permissões granulares)\n  │       │\n  │       ├── modules/          # Cada funcionalidade principal é um módulo\n  │       │   │\n  │       │   ├── organizations/\n  │       │   │   ├── organizations.routes.ts\n  │       │   │   ├── organizations.services.ts\n  │       │   │   └── organizations.validators.ts (Zod schemas)\n  │       │   │\n  │       │   ├── channels/       # Gerenciamento de canais/integrações\n  │       │   │   ├── channels.routes.ts\n  │       │   │   ├── channels.services.ts  // Lógica para conectar, atualizar, etc.\n  │       │   │   └── channels.validators.ts\n  │       │   │\n  │       │   ├── contacts/\n  │       │   │   ├── contacts.routes.ts\n  │       │   │   ├── contacts.services.ts\n  │       │   │   └── contacts.validators.ts\n  │       │   │\n  │       │   ├── messages/       # Envio e recebimento de mensagens\n  │       │   │   ├── messages.routes.ts\n  │       │   │   ├── messages.services.ts  // Lógica para rotear para o serviço de canal correto\n  │       │   │   └── messages.validators.ts\n  │       │   │\n  │       │   ├── leads/\n  │       │   │   ├── leads.routes.ts\n  │       │   │   ├── leads.services.ts\n  │       │   │   └── leads.validators.ts\n  │       │   │\n  │       │   ├── analytics/      # Endpoints para tracker e visualização de dados\n  │       │   │   ├── analytics.routes.ts // Inclui /track/event\n  │       │   │   ├── analytics.services.ts\n  │       │   │   └── analytics.validators.ts\n  │       │   │\n  │       │   ├── ai/             # Integração com modelos de IA\n  │       │   │   ├── ai.routes.ts\n  │       │   │   ├── ai.services.ts        // Lógica para chamar Gemini, Anthropic, etc.\n  │       │   │   └── ai.validators.ts\n  │       │   │\n  │       │   ├── content/        # Proxy/cache para WP-Headless\n  │       │   │   ├── content.routes.ts\n  │       │   │   ├── content.services.ts\n  │       │   │   └── content.validators.ts\n  │       │   │\n  │       │   ├── projects/       # Gerenciador de Projetos\n  │       │   │   ├── projects.routes.ts    // Inclui sub-rotas para tasks\n  │       │   │   ├── projects.services.ts\n  │       │   │   └── projects.validators.ts\n  │       │   │\n  │       │   ├── livechat/\n  │       │   │   ├── livechat.routes.ts\n  │       │   │   ├── livechat.services.ts\n  │       │   │   └── livechat.validators.ts\n  │       │   │\n  │       │   └── metrics/        # Endpoints para buscar métricas agregadas\n  │       │       ├── metrics.routes.ts\n  │       │       └── metrics.services.ts // Lógicas de agregação complexas\n  │\n  ├── webhooks/\n  │   ├── index.ts        # Router principal dos webhooks (agrega todos abaixo)\n  │   ├── whatsapp.ts     # Handler para webhooks do WhatsApp\n  │   ├── telegram.ts     # Handler para webhooks do Telegram\n  │   ├── instagram.ts    # Handler para webhooks do Instagram\n  │   └── gtm_server.ts   # Handler para webhooks do GTM Server-Side\n  │   └── middleware/\n  │       └── verifySignature.ts # Middleware para verificar assinaturas de webhooks (e.g. WhatsApp X-Hub-Signature)\n  │\n  ├── core/\n  │   ├── supabase.ts     # Configuração do cliente Supabase (incluindo admin client)\n  │   ├── encryption.ts   # Utilitários para criptografia (se não usar Vault/pgsodium diretamente)\n  │   ├── logger.ts       # Configuração de logging\n  │   └── errors.ts       # Classes de erro customizadas e error handler global\n  │\n  ├── services/             # Camada de serviço genérica para integrações com terceiros\n  │   ├── whatsapp.service.ts # Lógica para interagir com a API do WhatsApp\n  │   ├── telegram.service.ts # Lógica para interagir com a API do Telegram\n  │   ├── instagram.service.ts\n  │   ├── gemini.service.ts\n  │   ├── anthropic.service.ts\n  │   └── ...               # Outros serviços de terceiros\n  │\n  ├── types/\n  │   └── index.ts        # Definições de tipos TypeScript (HonoEnv, tipos de dados, etc.)\n  │\n  ├── jobs/                 # (Opcional) Para tarefas em background (e.g., processar filas, agendamentos)\n  │   └── ...\n  │\n  ├── config/\n  │   └── index.ts        # Carregamento de configurações (env vars)\n  │\n  └── tests/                # Testes unitários e de integração\n```\n\n**Explicação da Estrutura da API:**\n\n*   **`api/v1/modules/`**: Cada funcionalidade principal tem sua própria pasta.\n    *   **`.routes.ts`**: Define as rotas Hono para aquele módulo, usando validadores e chamando os serviços.\n    *   **`.services.ts`**: Contém a lógica de negócios principal, interações com o banco de dados (via Supabase client), e chamadas para serviços externos (que podem estar em `src/services/`).\n    *   **`.validators.ts`**: Esquemas Zod para validar payloads de requisição e parâmetros.\n*   **`webhooks/`**: Endpoints públicos que recebem dados de plataformas externas. Crucial ter verificação de assinatura aqui. Eles geralmente criam/atualizam dados (e.g., `messages`, `contacts`) e podem disparar outras lógicas.\n*   **`core/`**: Utilitários e configurações centrais.\n*   **`services/` (fora dos módulos API)**: Uma camada de abstração para interagir com as APIs de terceiros. Por exemplo, `messages.services.ts` (do módulo API) pode chamar `whatsapp.service.ts` (da camada de serviços) para efetivamente enviar uma mensagem via WhatsApp. Isso mantém a lógica da API do WhatsApp isolada.\n*   **Isolamento para outros Frameworks:**\n    *   A API Hono em si é o componente isolado. Seus frontends (Next/Nuxt) farão requisições HTTP para os endpoints definidos.\n    *   A autenticação via JWT garante que o estado não seja mantido na API, facilitando a integração.\n    *   O `tracker.js` (que você precisará criar e servir, talvez de uma pasta `public/` no seu projeto Hono) será o componente que seus clientes embutirão nos sites deles.\n\n**Fluxo de uma Integração (Ex: Receber e Responder Mensagem do WhatsApp):**\n\n1.  **Configuração:**\n    *   Usuário configura um canal do tipo \"whatsapp\" na UI (que chama `POST /api/v1/channels`).\n    *   A API armazena as `config",
      ],
    },
    {
      role: "user",
      parts: [
        {
          inlineData: {
            data: btoa("iVBORw0KGgoAAAANSUhEUgAAAosAAAepCAIAAAAJ1N7aAAAgAElEQVR4Aey9T+gkx3n/3za/4CUkRCCCjU978CGEHBLwwZegwPeQ4cv34GN8+eKDvOSmHOZgCPnlEhIE5juBzY8VYrL+hQTsxQchE6L4EEZBFlp08LDsemUcS598sPEuWsnsoqy0+rPqb6qefp56urqnp3qmuruq5/1hma2urnrqqddTU++pmp7uosQfCIAACIAACIBAegSK9FyCRyAAAiAAAiAAAiUUGoMABEAABEAABFIkAIVOMSrwCQRAAARAAASg0BgDIAACIAACIJAiASh0ilGBTyAAAiAAAiAAhcYYAAEQAAEQAIEUCUChU4wKfAIBEAABEAABKDTGAAiAAAiAAAikSAAKnWJU4BMIgAAIgAAIQKExBkAABPYQKFZb/JuKwJ7YzP30VNhHa7c7gFDobj44CwIgUI42W6GhJoETH39NIDPL6Y4vFLqbD86CAAhUCl2W5/g3JgGSohMffwxhhmOPu9YVYSh0Fx2cAwEQKEso9DTyEDKDz358MoRpQjDoBzLuWlcModBddHAOBEAACj3oNN1hPGQGn/34ZAhQ6NmHGh0EARA4iMCMZ8kOgZz8FGM/KGZzqcQQoNBziSj6AQIgEJfAjGfJyWW4wwHGHjeYmVljCFDozAIHd0EABEYi0DpLXrh8g/I7Xsvy/K0HZx0ihFMdBBj7SFFOsxmGUFPoeYw97loXeHwP3UUH50AABFq/hw6ZInkCqs2tHYI0zKlry+Kp9VlPH86eXRxQi651P6Zu/Wp5BnjSY5AhuAiONPa64tg6qFozndvN4c1d64ovFLqLDs6BAAi0KjRNLiGvzYkpUk7ghBhY7Lwsw0s2p91j6jatVTkhM/jsxydDcJRCRl2zVqRRR260hrs107nddICd7IrhHoUOZ3EiJbtYnsC5E4nyON3MaLwQED3FFKvt06/d8/41M4vVVteKmg6cEAOLQaETHY/5jL3wkdbjExgUut/tDBMdxWO5NY50nUgrYwUtQjvhs+TXXrmrZbtFoc3mIf1d2pQvrxfFcsPrjM2lYvHsWXle1sqwdq4vUbXF+lW73q2sFMtrLcLPFhbrZ90uN2cWxaWN2U9+dc2uLDfXlmzPGpTZ1iZqTRtvN1LatL6rru6IdLPVoPaEaZTnjD1CBPM1wRBqWPQYo3Sx2naPvdaRVo9jNdKWy6fsCJEx4IWbB+SmGsl2QHImfZ/SNdJqHbFvkK7gBCl0yxug/n3JKRTggdJFc/bnGIIbZKcQ+uh9ZIzZjBd22MW9uVx++rV7zcyGQrtZr9xcMlPb5pJI7GZJMtYoQxJISry5xPqqivnTkZFMEv6z9VNF9Y2yKt9o2oZYFXA73lZ9/aaFg1SRhJ6pnRv2Mwd9Hd5mUEHQg42xZzNOhnCUIQhz88GlVaG9TH/sKcg80sSmhM9Ep0VxqwFWK6Y+TUpkvcR5c5D3jS8UWoK0J8EDZYhBmI1NhrCHlR6FSDcJMMaM405dCHmtdd+tLeyKtVqA0or22tJfQOsycrWXniUlsz4gz55dkCkzsXL5ZtM2h6djVVLXkuq1TDPz8pK7MSlLFWOfumbcY1Vgf7RB35OqO9mNkyEGNENwIQ4Zdc1adiTUR1oZFsc9xRqR3T/SesQXCu0CX5tKzPun9o9DPsQgzMYmQ6iR8UDhcC8Bxphx3P0Fin2zNDP9nLpoEaiz9VOL9av0anJayrSpmghh/X1aWWhXaKeXEiO7yG6s3Z3xtqadh6+uFzEU2nZBeVK9v7IbJ0MMaIbg5hx/UAWOvfJ890gLjGNrMfMNhd2w4aHihofzubStF7y1Q8OPu9aFDQpdgyjv22YihGYX6VmcYwih0JoYkVNm+P1iM+67Zsl7H9R+/dwopncReRSZJe+l5ULks1mG5z4zF0taEmzHSbWx0LbLLRuYtSr84UAblLQkVNO178t3K7RxtXJDfexoM8iesyeVe4x9FnPHoZ1gCC5kjUFlThWr7b6xZz/86ZEWGMf2YjyWnB5LZJsDuHL+gPhCoV3gu8WDB8qhA20W9RhCKLRupCd7ljFmMybYYRf3XbOkF9OWYmZG4z/6fpeu2KrStgm/jMx9Siblci1dkaVOdqF3XClWmC+/3U519eGgum6o2nvvkN7qwq7PLr6xrNbQfDFRra6+Uoys1fx3nzYanhBGxp7NOBnCUYYQY+z5I60Zx9aR1l7MXlBmRjJf6qjqegP4iPgertAhPxuf0x2FeKAMMQizsckQ3LvFm5H7Hp7aKMp05m2NO2V2v/YdDyivCTD2bOaHIRxlCLU5p3vUtVbRYBNJs59d2A5U6JCJlZuvkd2Dxnz0kA+bfSrKZ2dKxLKjzHJ3umjO/hxDOCI0CulQo0g1URtvA4yKmv1d7TbyGWM244UdjhP3w6DtrmU2FdWf7Jan6W0Prxh7NuNkCEcZQg9uu4dKWka4a13YDlRoMh3yOiIstcnQmBOPdyOEZhfpWZxjCHEGesj4OahFPRJ0Oo7bJziWDopCKrSPj9dUFhj7LOaOQzvBEGY4nLhrXWgOV2jvx2dhv4YclPKwc3EIzS7SszjHEOLE8cDfNe7/+KVHgk7Hcfv4+ZoxZjMm2OFUAB4fgiwsMPZsxskQjjKEGY497loXtsgK3X1Xl+rKCL4Vy3JjLn+n7Sn+VaKaT/nLdnWthznLN3zhSzPMN/UD3tZH3skhNLtIz+IcQ4jzbtml0PtGUXXhhrtGg4cK3wmItzyXl9z+Z+0SHjvMGjeKkltZqSHXaGv/54P9cBhjNmOCHd7fNXm/IHE8AcaezTgZwlGGMMOxx13rwhZZob2FdeNKTvuNEf1U0V7eVgmzSdO3R6LQ7ocK9bsC8TXubqLUVeQ7bJ3J19q5ryGtG2bKpl+s26bVHWda31ohNLtIz+IcQ4jzbtml0HtGkR8piTXfwcf9IGfHpbP2ZzDVraxqY6/xEx2/rWgdt2+NbMZE3Li3vr+Q2STA2LMZJ0M4yhDivPWakCfM4a51YTtcocn63td6/9Vk2j6NcoHWuwLVqoTdDsaosrty5IDb+oj/ITS7SM/iHEOI827ZO3ikgETBJOyKmTdd9A9a7NK5tlbuUOjGh7nWIee15T4XHkWAMWYzJtjho3pdC2IkkvO2ydizGSdDOMoQZjj2uGtd2A5X6OZ7o7FiNr8irxdjATbvz9Y0Z7ZOl7qKk97W+7woO4EKbaeM5m19xP8Qml2kZ3GOIcR5tzSGhzHbzGzm1G7Q40aCeMXR3zvMdIH2IWdsdowKGR69EowxmzFBDuN1EgLZjJJhHJ2E+ZiNdmOLrND77uoSPnXu2uXmpU/7fV74rNNyZ+ew2/rIzEsx66Y5+7MMQbTwqESr9AbdG4g/TtmVtAmxW1Jr0d2Zbh2HbqioL1aqDno3A5JRcViCMWYzXrJzOBuynY4Cu3o2eSepPE+GxDeyQnsTVmMKbp0Z9XpaFeD7sKjLdtRZfnLc0Lf1kR6F0MxznPTwmiEcJcwaqaQl0RgzjVU1Dwy+dqG+0W0vL1A3h+IrCmu733ogqTRbdkOOc1xb9sOBeHtYgjH2ID9t0ewcnhZXrNaBHQp9oELLvYVpDO16PWz+8mu1bGPGUQi/oc7JF+8W9W6Jxn/XyNH5vcIUp/DAQy67sZSdw7E0clo7wK7mnGlDMUjrIfE9XKHjTIWdokhNmPWQe1JNNG3o638IzUHCmJJRhjBZFPpG7bDyQw85xphSaDt9yc7hzt5kcxLYodDJKrT7HWrcDcbDpmzZM8jmzT2MozxlzFKhxxtyjHGYIA1gNTuHB2AwgUlgh0Inq9DJaQDeLerdklx0Dv7gNUnF7MZSdg5PIKcDNAnsas4ZgO/UJkPiC4UOFZsQmlNHfPD2GUIotEn0L/1GGePg8YrVQHYOx+r4tHaAHQoNhQ4VG7xb1LslFFr6YjmJh9mNpWgO24vsF+szrXxna/PA6OVG5yFtCETDnjPOaBDSG3shXYNCh4pNCM2c3whBvjOEUGiT6F/6jTLGIOYpFGo6TE8OffK5m+QeFbC/lKv8feLKzWK1vXD5Rs3/9GbJmnuJHTSxJ+bgGO40Icxm7DW71gQapNDy9kOiSfCkcjAAIhLIaORQr8Vh78HestqTYh4lqdiawBq6FYtQ3XX2RPJlUFF/5zT2vK61BjRIoVtrnlpmCM3ZMwGEKCHODqPnsBzqBJGhZbTk+7jUGpqEmR9Dhl1uHxUUWkaU3puRoaUTUrILWnpjT7rQEnvOgkIziX3/h9DcZyP784AQJYTZYfQc9mZMmhYvXr198ertUIW20yXJskpGoTsfIx72+XSsT088CHMae17XWqlAoVuxtGSG0GypNq8sQIgSz+wweg7TobySQpdlSQot+ZT44vO3HDRex2hVxi6341NPEcB63skdeRC80ZX12PO61hpaKHQrlpbMEJot1eaVBQhR4pkdRs9hOfQSdCirHO/QoINC9xlAgrdPpbmV9SDIoZegw7zGnnShI2ZQ6A44tVMhNGsV5ngACFGimh1Gz2GZB1988wGlqYAUayYqbqzQtG62P7s6tz+2wvfQLSNLMLacO5ksD8Kcxp7XtdaQQqFbsbRkhtBsqTavLECIEs/sMAY6LMWaiYobKzQvp+VCMSh0y8gSjC3nTiYrEIIUayaSHXviakcwodAdcGqnQmjWKszxABCiRDU7jIEOUzFZ5XiHUdCdlJFA7PNmEgjBG2zeYZqIQrrWW6G10e3b7wuI7dvvy5XuxWr7G393Q96oho767Cyw8rpCRHdcunBqiWgQ1C7nqTGUt0lGHQ+Mu8wG3tZ3Rj1NytVA7En5HN2ZQAg5jr2QrvVT6GK1/foPzkV6i9X2/qNPyrIkqZbYfPz40/uPPpFiJh8KLXRyTjSH1IH394FCr7YZDYRm3Fudl1mSznqHrVWQ2UEgEHuHhRmcCoTgDTbvME0OIV3rp9BnDz6Uq9t1nz09/vjxpzV51kVVGmtoBSOPpDekDr+/DxR6jgrd+muri1dv5zG40/PSe7ul5+AYHgVCyHHshXStn0JTQJrq+985f/naHTn75HM3Vz96uxY9tYamyVkuEcnljvkhNGtdnuOBB0EOdUKGQdd2rlJoOzSKgh6noAeHyVHleB9mBlwFVy59yc7hXMB2+wnsXXNIN7sczobE91iFptXzMy//wgNSrLa1TFFomo+tLKukVzvFwxCaKfod1ScPgv6sRulitQ26t5Qob20Q2AP6yEYFlhspSGLtPRYpaufGM+ZhHK/hQ1vKzuFDO5pWPWCHQh+l0PT18ws/u9+6w6Cnb17/nOkJmSfhtN4Vu7zBu6X5biEm8koFgu4tVQnvwjx3UFSXBofsrtAjCXmU2P+l6K4o5ZGf3VjKzuE8xsE+L4G9OefsY5bT+ZD4HqXQxWrrXcJNeKhhKHROgyXMV29IyaGX8AaAd2iaIt0tFlqiK9WuPzy4LOmOFsvlUml5mLfJlhJcyXroOSYRRGJ8Al4sTu1wfOAjt9gd0H4K/czLvxDv9U+tKFN/3pGcqnm7PFqsz9QsnNm9hPwedXOd6VkPgnwI631vKRkHlVTbrW2dNtf/r0msq+z5CHTpYUx/sGTncPpIQzwEdq0pIcTyKhMS334Kvav/0lIzUVVhheYfXrmtTFwptotqgvkS327fpFgzUVUUhZblNN1UStTYDBDe064y+bC77RzOCpYcnDU+ZudwLmC7/QT2eY+9kPjGVGhZUVHDctg9CnM5G0Izl74c7GcgBG8AeIf9W7fbLfMR6PwELzDu/SOLGl0EgB0KHVmhSZWPnpG7Ru1U5/BuCX+3yACIMx7sGnpGAg2FnupNnFm7mHPC55zMQmvdDYlvZIUmTDJB50htl88hNHfVnU1+IARvAHiHvWhU13fn8l1IWN8CMYYZG6NUdg6PAWX4NoAdCh1HoVt/bTWzewnh3RL+bjmF8XDM/JzdWMrO4WOik05dYA+fc9KJWrgnIfGNo9DhPuVbMoRmvr0L9BwQAkF1F8sOY3YOd/PP5SywQ6Gh0KHvVrxb5v1uCR0HMcplN5aGcXizlMv1w6maixIOvSbhmLrhHsYrOQz2eP6NYikehIPG25B9DOkaFDo0AiE0Q21lWw4QooQuO4xNhw98plkNX/iMGV6y1oA9OKZu09qoOU3sozafRmNNCIeOveRGQrNrTeRBCk2G8Dqz3481R8PeHIyBiAT20k6nAPVa/Dn8mWZiwiTCZ8zwkrUG7MExdZvWRs3xsI/adjKNeRCOGHvJjQSva63IgxS6teapZYbQnD0TQIgS4uwweg7LoU4QGf37unZW1f1nisV67Xa5ObOgG9dUt3o1t61ZbtTt2s0l/TLP2sR6STc/ko1vV7oqzDdHqtV1N8qhu79bV9sNtvdilFzBO0priTbiQZBDnSDX9409PXJ4oNUGnjlwvxqxxQeFIl3oaAUK3QGndiqEZq3CHA8AIUpUs8PoOaw3k2RaDHqmmX2EDk2Cdm4kYZWp0+ivydos1UzprbalsNVismWSbmq1MdLFtHxLi1zB+OEyq9wWg1Ei38+Ih71f5bmU9iAcN/aqG0/zWJFB0jLw/DE4AE+va60tQKFbsbRkhtBsqTavLECIEs/sMHoO06G80iWEREYEu1htr995eP3Ow9fvvu+gna0XIpeyGnbrGLveXW4aTxpVM6nUcom6hLtFtOiuNMl2GoslO2XzWeOuTjv3R0552EduPZHmPAgy6iRfNHvP2LMxXfDHMdO75sAzZfhDn4yawUBIFzpagEJ3wKmdCqFZqzDHA0CIEtXsMHoOy6GXaD2UCdSg26nQvKpRfGn+3K2dWkQ57aT3nD8L8CljmdOuWJW7uxXl0OhJ4Tl6ywk16EGQQy/Relgbeyb69ml6Mtbqw4D6TCO0Nk4HgyE+d7QAhe6AUzsVQrNWYY4HgBAlqtlh9ByWia/5TLNb7zwqy/Ljx59SlWK1fe+jxwqa2z62AizL3PZfUPFEycpqDElaEipT8ox1MS6rITnt3LALKZqz5awyqFwfP+lhH9+BFFr0IBw39sxIUGG2mu097taMueVSbfUMB8HrWmtDUOhWLC2ZITRbqs0rCxCixDM7jDEdNrOi+dtxpZj9QpnLyLfLVYZRUplgJaEFtXqmbaEm2ba6eoezqd/aYJSAH2gkJvYDXZi+WjwIMmDUk3js50QakHxhgl1ryzp7SAAhXYNCh0YghGaorWzLAUKU0GWHMTuHo4RpciPAPsldkuS76KEHQEh8eyu0Nrp9+306LFbb7dvmehA5/I2/uyHbEX4/3QaUfyblY93xlP0c1LdxIchn3kH7NIHxcTFG6GB2DkfocwImgF00Zbxo8DcrI7QYEt9+Cl2stl//wblIb7Ha3n/0SVmWJNXSpY8ff3r/0SdSzOYPNNsOZFa64hIhNF3pmaaaEA69v08IoPGCG+JNxDJNjBGND2EqO4eHgDC+TWAfV6HpKxL51mPwgIfEt59Cnz34kJB5vnt6TNeJ1MsMNNsOZLbuuz0KodlSbV5ZHoQj7u8TwmW84IZ4E7GMhzGi5YFMZefwQBxGNgvs4yr0yOENek58P4WmHtQXxybvv3P+8rU7cvbJ526ufvS27m51cUh1/x6ZeW1is17Yb+r5Z5B0FclZVd19k0/f3fOVIOYaEnc9CX3J746r7/n32q8V6P7shHdL890iTHRChkGzvAyJ5r17zuwlQPVLNurjpBoRkqkv9hnlug7x/uiE4Dra0kgGsnN4JC4DNwPsHXPIwOzHMB8S32MVmlbPz7z8C69DxWpbz1QTa+1qTHNNp5l7rbpWGmnSNOeqWvtvNiQuSC1lVCXVtXoqd9+34yE0xYO5JjwI+rMapYvVNujeUupiDJUkbDp8Mjjk41PzrBk8cjoL8h7G9H3OzuH0kYZ4COxQ6KMUmr5+fuFn91tHm56+1W8k9C8ZZLbVmSrtFtC1VbaajrUFvQrrmNmVffdZwfSgIRW1buHd0ny3EBN5pQJETQS7/d5SDrZSV/t5yUbaC5+OMqebY6MWrqQPshtL2TmcdPiDnQP25pwTDC+DgiHxPUqh5RJugqG/jfauHTtCoVs2MGlytid4vq5u4UaFO28nZHyVWpIoS3uz/pbGONAhNLnsbP/3IMihl2g9rH9iq+4u5S6cNEHdFT4dJk678vnRFj65uJ6dw7mA7fYT2KHQ/RT6mZd/QYOGtFnSMpLoSm86pN9f8RDkidUcS1oSOlOnzapKrZjZmLt7oLIgSTN3e4swbVOnlf19M7700TlxeikPgohu/3tLUQiXywV/KOoKn7n4oCrnIuZS2cXBw5i+/9k5nD7SEA+BHQrdT6FDRtXZgw+v3LjXLGkm1NYrxZpXADkJ11cD7b3ZEF9E5m4nJLO+VmWdNgWWS7pSjTWg6brNwbsl9rvFxosFmvYwzAhpDV81eopiuWx7ZCFft7AjdqllZzeWsnM4tYgf5g+wx55zDovDULVC4htfoYfqzSB2tYTvaSCE5h4T+Z8GhCgxzA5jdg7bMPnvbvMxz30ijBLJYY3kiT0ykxlDCOkaFLp1E71lkIXQbKk2ryxAiBLP7DA2HR7yTjXdjH3d3V26XrLliQj1ArsNTXWmiX0qTyZstwnh0LGXXLibXWtyhkJDoZujYmdOyJDaWRknmEB2GD2HB75TDWNq/z98nq2VpGsS3ZWJxnitQHtrk+Z62Cf1ZbLGPQhHjL3kwu11rRXxiSt0K5P2zBCa7TVnlAsIUYKZHUbPYTnUCSKjf2W3gxVfL1JtOZt5014LYjegzQWb9KcuDXQZcj0C71c3ytunSdrrGdZrd8mC+aWG/SzuJLphaoe7E2YL3gl9mLxpD4Ic6gQ52T325K5Zv/5nz7srT93ntFfMaOHbZ7l1W3OAxSMiXegwCYXugFM7FUKzVmGOB4AQJarZYfQclmv46UIeeg26U439TaOb/gxNo5Sco1Y56nfylrmckoSbXMmMNeK+a7ZTKxt2wsxSXTXNBWwbqb142FNzbxx/PAhHjD01ctS9LzhpP7HRcDBDh1K1KtHHite1Vp5Q6FYsLZkhNFuqzSsLEKLEMzuMnsN0KK+i05KgU9fvPLx+5+Hrd81T76o/M/d5F2upSdCtV+yqmQq6tW5j0myWd0pc02+drVxQTbODSf3vYU/Kt9Gc8SDIqJN80Wy9hm4Ze7UvNViX3f0Ia4OhOt0cYFG7LV3osAqF7oBTOxVCs1ZhjgeAECWq2WH0HJZDL9F6KBOoQafkkUmqmbF51uXI2ndfebfSkZJO5Gm/nLfIpQD7ktj/wjMxv0Z1x4Mgh16i9bA29moK3bhjUu0s34DBDb9Buiw+d1iHQnfAqZ0KoVmrMMcDQIgS1ewweg7LxNf/TjVm7nMaamhqmTRSWjsrJ81c2VhDm7r18jaH1t6mBp0UI1XweP6tNR0lsJGNeNgjW8/EnAfhiLFXHwdmX2W5pKsTDAo1lpwwq8wBcHlda20BCt2KpSUzhGZLtXllAUKUeGaHMarDZtajPyuljXmTz9rtcL6sTE2mVX2lw9qcnWlNxoKvFKs3YAIoM3DNVJTQRjUSFXtUz0Y0FhGCF25zSKPIdMcMk5a7V9kPerUBFq/vIV2DQofyDqEZaivbcoAQJXTZYczO4ShhmtwIsNOVDbJujhsR+S7amm1+kIvbWou1kPhCoVvAtWaF0GytOKfMJgSdQ49LoRy6Kzuli9X2N/7uRv1tdsz7oV63+mBMyyZ+rPgu6K6w+/C8q+xw+RracK1EtJydwxH7PqEpYB9QofXVgybG9VlllKiHxLe3Qh96P5dRejxkIyE0h2w/CdsehGK1pWelkHPFanv/0SdlWXpPNvv48af6uWe28DHvB1XXKK58cdn8jrMOTTY37UbnetPrbakarVs94MjDeICFkatk5/DIfAZqDtiHUWj66kTmDYpezDd44HgIiW8/hT7ifi6BPqdbLIRmut5H8syDcPbgQ/mBjW7B0+OPH39aX0D3kkZtmNLyXpJLfriM1mDOc/9Lvc4sd7KWaqlcO9/nwMPYp+o0ZbNzeBpMsVsF9mEUOnacDrUXEt9+Ci0WdYLcoylY8hs+2wluXV0jIp9eGpuOthjf2GW5kRsEuYWSy1Lf8jeai5+xu2vx20rWYiuEhvqW/53zl6/doV4Uq+2Tz91c/ejteqeU4KlrMWTruTEw3FPO5Aogd8GPM13/TY4/3morbrp6U18D0mjUOCkXj6iSynm3OVYbujLCnWsq1YpRnU8umZ3DyRE8yCFgh0L3VmgZaSLJYfcSsrMfTcAmKVMx2ZMpzxaj6U0l7fWZUplnP/+uQ+LaIAm8W3a9W7RC0+r5mZd/4cWgWG3rmbWIV6PBSDUHt6rfUswKui3mf5NU0iMsrbVd4626NpjHn9jX/kqmMcIOSaa3ASD5ary2dETbN59gNLTauSQPsnM4SYq9nQL2XXNOb5RJVgiJb2+FJqNiWiYaEexitQ24n4ua96q1CeXIfLdjHlTrLVOPJ9oR+EuXR2gr2SZaIcgYoK+fX/jZ/Vb/pZg9y4E2AXVRdFdXWr2zQ6Mpxu11rdn6Grrl0eO2lB1FLOQ8FGnE9RqNxhg74xJVruuVbVO/tGLUBVJLZ+dwagAP8wfYodCHKLSmRmNIRpI+bJ+RzVDlSc3Nznsn1maVw8b84bWkj4ebyL9mKwQJdLHa0iXc1FH9bbR37VjbGDCV1M32SOB4YNSWyzwY7E2ea0LoRpSUUeNN8eeCqhhn2YV42OfFyuVm4cYX5Kpp/fapZ6d71Br3dN2di2fAnuObJXz0hcS3t0JT8/3vJaSmQlFoyTOTY3Oak9N6ktUbj+EoIpQMoRmhmbRNeBCeefkXlEPaLGkpRld606EWb6fQZjDwIlo0UiJfGxhVMZOn9565trWpT8jimM1t1utqVW0U1J7mU3qI1RptGDEBUgLsxqNLtX1BXour8KnlJnyQncMJs+zhGrBDofspdI/B5Zz/r+AAACAASURBVBdVU6EotJ3pzLaiu2FQazE9fborhrDL7TMe/viAKePswYdXbtxruKYCbSXXbWibotW3xWpgkP7awcL3iqpsGmWs/tR6Wtl3462laJVlajYb1UbsRwn5YkUsLZf8iENTWC4rU540ul7ie+gWJshqEjjg7dY0knvOjCGEdG00hc59nOQ3qw5BPGRIDdFuDjZrct7tcHYYp3a4B9vd5H0j5lNW9yep3bbGOTM19nF6uaeVcSH4g2SPc8edDukaFDqUcQjNUFvZlgOE3aHr8d7ODmPT4XHvXNTBtuOUF6t6Sf/BCfWNOq/qRIdN7BM5MmWzTQhDjr36IBm4382uNRuEQjeZtOeE0GyvOaNcQNgdzB7v7ewweg6PfueiDrYdp7xY1UrSpYe1CxDdtyFexckOPeyT+TFpwx6EgcdebZAM3W+va63NQaFbsbRkhtBsqTavLECIEs/sMHoOy6FOEBm6sF/yG7j0DChpm+D7FMm1eXJvInePGnc1Am1Qy+UAvF/trmng/WvO0Ubc5fpOohumGq6Pn7Eb4/i+TNaiB0EOdYKc6x57/s86+UrR+jUs9THZ/LkmDycecEdhkS50WIFCd8CpnQqhWaswxwNAiBLV7DB6Dsvv6+hSW3oNvnORSLCeDfnyfDMDUgH3NbGdFaUWRUDXlVOSaZTc5u4w4oSZf85nrKrqUcJ8tBEP+9H2sjTgQTh87LmbLZhI8yc4YiKhbyb0wJCzMsCOQup1rdUWFLoVS0tmCM2WavPKAoQo8cwOo+cwHcqr6LQk6FTwnYvUxGd10syeTkT1FGlPV6seEXJWaLe+sSXopsF8Uguwtm0qVbN1zY0ogT7SiIf9SGuZVvcgyKiTfNFsvYbeMfYo0upulG7rxBtOejBwujnAjmMqXegwA4XugFM7FUKzVmGOB4AQJarZYfQclkMv0XooE6hFx5OdOZC0JNRvzbWKSkknp7L2VXXdWY5SqxFjzfvjiVt+Ts8Gpv1feE7rxrStexDk0Eu0HtbHXvWpzw0KN2Caw0mNq5bhFweJ+NxhLkihyRBevXh3YJ3rKYyBiAQyGiTUa3FY3gj971wUfrOXtg1qmTbN3OotekjyPY3tNFL1R1wS69LRiRMe9om9mah5D8IRY482ZpbLRbVnIsprr3jwhpOMCtq2kbPeADsKite1VltQaPMMg/B/rRBPJzMcFEruJZDRsKG+xHFYVrB7b/bCJdVFXs27yvCKmGZdo9z8JwtjmyFGmjosS6mqQZ7A4/T3CCsxsR/hxrRVo0Kw48fFtzmc1Ojg4Ve4gRr5flkhXduj0NPGBq2DAAikQCBkKjnCTzUtHmFlflUHxp4HsBlDCOkaFDqPYQovQWBCAiFTyRHuQaHb4Q2Mvb3R1HJnDCGka1Do1AYk/AGB5AiETCVHOA2Fboc3MPb2RlPLnTGEkK5BoVMbkPAHBJIjEDKVJOd0/g4BO/1+T64Oyz+ktR6ExBcKXUOGAxAAgSaBkKmkWQs5RxIAdig0FPrINxGqg8D8CUAqJokxsEOhodCTvPXQKAjkRABSMUm0gB0KDYWe5K2HRkEgJwIkFXidhEBOA2UAXydhPmaj3cyg0N18cBYEQKAcc8JCWx6BEx9/Ho35HXbHFwrdzQdnQQAEQAAEQGAaAlDoabijVRAAARAAARDoJgCF7uaDsyAAAiAAAiAwDQEo9DTc0SoIgAAIgAAIdBOAQnfzwVkQAAEQAAEQmIYAFHoa7mgVBEAABEAABLoJQKG7+eAsCIAACIAACExDAAo9DXe0CgIgAAIgAALdBKDQ3XxwFgRAAARAAASmIQCFnoY7WgUBEAABEACBbgJQ6G4+OAsCIAACIAAC0xCAQk/DHa2CAAiAAAiAQDcBKHQ3H5wFARAAARAAgWkIQKGn4Y5WQQAEQAAEQKCbABS6mw/OggAIgAAIgMA0BKDQ03BHqyAAAiAAAiDQTQAK3c0HZ0EABEAABEBgGgJQ6Gm4o1UQAAEQAAEQ6CYAhe7mg7MgAAIgAAIgMA0BKPQ03NEqCIAACIAACHQTgEJ388FZEAABEAABEJiGABR6Gu6Ztlqstvg3FYFMxwzcBgEQOJgAFPpgdKdYcSpxQrvFanuKAw59BoHTJgCFPu349+w9KWVZnuPfmAQYe89ooTgIgEDmBKDQmQdwXPdZKqDQoxJg7OMGG62BAAhMTQAKPXUEsmqfpWJUfRpztZpmW4w9q7ECZ0EABI4mAIU+GuEpGWCpgEKPSoCxn9JQQ19BAATKEgqNUdCDAEvFqPqU5rp2TK8Ye49IoSgIgMAMCEChZxDE8brAUlFT6AuXb1B+x2tZnr/14GxMVZtTW4x9vECjJRAAgRQIQKFTiEI2PrBUOIUOkedmrfLs2UXx1PrM2TlCUK8tK1OS6DYbWKzbiD4b3aA2btIMMJtxAkdBAASiEIBCR8F4KkZYKpyEUE7IawwNdu0qayKQkmgtJpmBxaT83kR0g36LjP1Uhhn6CQIgQASg0BgJPQiwVDgJKVbbp1+75/1rZtobbrhaSl9DMrslUM5KottmYLFuI/psdIPauEkz9h6RQlEQAIEZEIBCzyCI43WBpcJJSFOMn37tXrHafu2Vu1q2GwotqmYT60uF/VusX7Xi/ep6QRnFcnNtWSWLYnmtLM83cmwPy7JuinbOzS46/V3a0P1VOGexfpZ3xV0vbKPWzqaqyJ40mzsvS+3eed2BXU6e241941LNAfaqKMhPz3LlIWMfL9BoCQRAIAUCUOgUopCNDywVTtt2KbSWZ9Ls+rpZy2qlauXmUiVUm0skxlxFCrt267pIX2lLMUmcl5tLVmuNzC83pvrZ+qmi/Stw+1Fg8exZSWrqfU0uNo2Iin47aT/79/WiaoLd9sW74YDYZD/9jkOhs3lrwFEQGIIAFHoIqrO12arQlLn3VemWJ12ihaxYdmWpVJDzaTVshJz+dgizW5jaYstrZv1K0mss1K25O5jW8jdLlluvOWOc1+VVXVNx4cl2s1bTgVY/zSKbNhLcxxHGPttxhY6BAAi0EoBCt2JBZjsBloqaeNSl15xq7Gk3c0QOJeFrp13skkyqMk4gX10vOhS6LqK9FdoslM2St9mcyxEIZvG9WDzl1v2uDDvZ6oArJqZMQnW8ymfs7UFBLgiAwFwJQKHnGtlB+sVS4RSlKcak0Pc+qP36uVFMRFcSvkKTVvEeNa+zN5cKfyNaLOiEtxIN3eWu1q+inS3N7drlNt9YV9VbarU6YKW9sWJWHYdCDzKMYRQEciEAhc4lUkn4Ga7Q3sK6n0K7LeJqKVxdHWYuDauupfrs4hvLXWvo6otk3gunC8rYZu1CLbfFXX0+WC6fomr0nXFbc1SyMm6LyScD65v5APEKXemmnDTfNFOdmgPmowD/La9JGb5wDAqdxLCHEyAwFQEo9FTks2y3qdDyWyA6tevVE+wkD0Vo3Q7BIH7KAr32+aCrUcae5ZiB0yAAAgcTgEIfjO4UK7JUdMnJIKoWLGbBrZsdZvV3abPzCrLInTX7Ae6qsSDjjP0Uhxz6DAKnTGCPQu9aEiG/L4F5DDKWiiBdCRbLRKwNuoauNuftZ4L6VWwBHz4Y+zwGEXoBAiAQSgAKve2rtYeVDw1I2uVYKhLR1FNxg7GnPTjgHQiAQGwCQQqd22IorYl7TtMr9yUtwrMfn4w99rsf9kAABNImAIUeXGzmNL1yXwaHNnvR7dVBxp72XALvQAAEYhOAQg8uNnOaXrkvg0PrJWCzL8zYY7/7YQ8EQCBtAlDowcVmTtMr9QWvkxBIeyaBdyAAAvEJQKGh0D1G1Zw+bfTo9tRFgX3qCKB9EJiGwCEKfeHyjb1riLI8f+tB7b6Ps9+K3NXBOU2vc+rLNG+4g1oF9oOwoRIIZE+gt0KHyDNPKGp5au6jxLdWDvgB6C61s/nyu1VJqIZajAcW6zYiZ3tbYxrZj5WyLOfUl4ziAewZBQuugkBEAr0VmiaLkNdOlRXBa010q6CclUSrEckMLCbluxO9rc1pep1TXyK+i4Y2BexDE4Z9EEiTwCEK/fRr97x/xWrbzIFCE4E5Ta9z6kuab8hWr4C9FQsyQWD2BKIp9NdeuatFes+zjNbynB96WL27J+Jyo26YbJ9KVD3XqCj4+buyipUEPceX7rLMt1TkpwbVHiVU2wO31X1PtCl6OLFdUrda40x+EpHuhVuIz2l6nVNfMnpvA3tGwYKrIBCRQDSF1vL89Gv3OhWatdY8j88K6uYSqy8Jm5Jep6mS2ZEwz/jjJwpX+nq2fqpo/wrcfhRwjyYkaTeZ1ZMH3XfnLlNZEze4Ub8XlUjPaXqdU18ivouGNgXsQxOGfRBIk8AhCk3zxd7X+i636Jkkqifyrs+qZatV1jaF5gfrstCKBU64taxdRi+vlWfPLtzjg7iYE/tmK1zGmOJVeHm+WVq1brXW2mhRqF5AoQcY82f2ycuL9Vks22TQfCyrLNKejRzGaucYO1DoY+ihLgjkS+AQha5Lr9Ghxoq5mcMSWHvGn2QaI3Z5SutXle8k89X1gq4Gl7OccGUqURxLoZ2WCxPVi5NQaLq2/8nnbtJ7QD63yVviiSs3i9X2wuUbknNUYjCFLlj1odBHBQiVQQAE4hGIptD3Pqj9+rmh2aymuxWaRJr3qPmnWZtL1cN0jQzvUGhj01u8tu5Ls35Xi2lxSa3mrSm1y+1vfdd3ub1GK/tn66f0SnpOCyCvL95P7+TnWFJMBFtyjh26wyk0L6Oh0MfGCPVBAAQiEYim0LKIpEQ/hXb72NWqtLo6zHxJXF1+9dnFN5a71tBl7fKu6itttrnnSrEzklWl1m77mj8llOabZroOrWbNlbTfrHMZvnBs/mto0V2doJFpB8Du30/bAC+WywVjNbvWvOFs8nhFqzNNnlLoapAs1mdtFXWeucqQNrF1LjVRGSRXTCmn0DsLLyq3C9cDbmBHL457uwre48ygNgiAQGYEeis07WnTlNHx6gn2KR/OaXr1+kIyTENeJPni1dsXr96WQ13GvTlIBq1GVhKpv1km/a7rcVVXSjshdVZJXY1VsaAVl3JJq8nOcuMk3+Ys1mcthsWatC5CbKydq+/GbVGvCeXgYUkP+2FGUAsEQCA7AocodJ5ya/a91V/LV8gD9WtO06vXFzqUV9rlLsuSFFryKfHF52+5t4doniydtarZOMnamNa6Vd1KI+0qVp+gfK6oVZbOGPOUqwaBWfgq0SV1XdqBQu60r+DtOVVPfR5obcJ1+8AUATywMqqBAAhkS+B0FNr7Enq8wzlNr15f5NBL0KGsnr1D82axSlYpLEsoqZteAfMZ9fairGKhJbpZkXK06Ne1uGGQXKmMGw1fbipB1/5Ugr1boclA1S/VyJFJwXukHVQHARDIiwAUenCpntP06vVFNPjFNx/obW0p1kxUbw8nqqJ6bq/Y6ZxL8dtKcihRXwV7J61Skln7NbGrYq1t1mZnXerYvKqIUejd/uxWaF5z02eDsqQm2PeD/xeMB1tARRAAgRwJQKGh0D3GbaBUSLFmomqMFFo2nEnROLO2QBbNpKvHlKDymeWmrSLnVcvtSjO5Dm+H+wotW+GmPJtw/lB1a0s5UtsRYJGmvsVZTgvGHqFCURAAgfwJQKGh0D1GcaBUUDFZYXuHpj0rfnHka5/7SlX3FU31fCD2VN2HXyAAAgcSgEJDoXsMnUCpEEn2tr5dS+Mp9Hgtud7FTgVij90s7IEACExMIEih9YSL9GEEJo5zpOYDpUIQUbPeockcXDdtAzF3miMRPMhMIPaDbKMSCIBAugSCFDpd93PwbE7Ta2BfWn9tdfHq7RzClaKPgdhTdB0+gQAIHEEACn0EvLCqc5pe59SXsOglUQrYkwgDnACB0QlAoQdHPqfpdU59GTzw8RoA9ngsYQkEciIAhR48WnOaXufUl8EDH68BYI/HEpZAICcCUOjBozWn6ZX6gtdJCAw+UtEACIBAYgSg0IMHZH4KPTgyNFAnMKchVO8ZjkAABLoIQKG76EQ5N6fpdU59iRLccYwA+zic0QoIpEYACj14ROY0vc6pL4MHPl4DwB6PJSyBQE4Eeiv0hcs3itX2yeduUi9p7pD7O5Zl+cSVm8Vqe+HyjZwwDOnrnKbXOfVlyJhHtg3skYHCHAhkQqCfQpM8a1WWtHd/R8wpMgDmhGJOfZEApZ8A9vRjBA9BYAgC/RRaZgqdILe0Qrc4SjdhpIcEFfSUIn6skL41Y/XAIPvwX5O/WC4XdN4+PtAapjK6Vkt7CWUJq4R8OtSVOfXlUAYT1AP2CaCjSRBIgEBvhRafRZIvXr1Nd3ksy3LnVFIptHsgb/U0QDInd2lWj/SrhNiUc0/qrW7oTJWpRM2QeJdQYieThHwMdWVOfQntcwLlgD2BIMAFEJiAQG+FpslCpgzS6db7MH/x+VuuQ6TQVk2VCteW0eZZhEp0dTFRcHlkb7WwLgq3tnaNpZUSVmm5dZA30fpiohvr4ZObZWVKEt19q4r5pTfLfmMpZhe6Hd79wXdPPZwGARDIm8AhCq3XylqwSa3lrBwaQm0KTXlmnhYF3qfQWrZzAR9N1RLocLMvo1w56ItpnYSclUT9vH/ExeqSXD/y60x73MQ+rT9oHQRAYBwCvRWa3HrxzQeyyy0iLdqsE1U3WhR6szZfMbuVs0s1ltqi4NUiWxY7m7XZN0/7b07Tq9eXsa4cZE1tD7SclUR7Oc7lYubjnnxHkrJAYw3NocP/IHBiBPop9C44MnE3E1WVFoWuls5Gpe2VYUEKXdY2xvmSs11+JZEvTJLw5jgnvL7IoU5QC/oDXFubLJNm/2SxXi/rV/7RlQcmb7mhoWPPWz11x5W81k3RJzbabCED1Dzn2MbMWKPrG5wNSnEx/vrEGLeXKy43/PGQv1qRdmtjsjLY3q82EgF5gjegLIqAAAjMh0BMhZZtbZpQ5HA+tA7qyZymV68vOsQiyUFXDpKAGZm0gkuyZpI25S9olRa6EEhmR8KYt2ospklmSaFNmlLcoJiqVaxKcyF2QQo749a6mFQq7xbrXLvP/x72PlVRFgRAIGMCkRVapmnMKTIo5oTC6wsdyit9u0Ed1yPh+p2H1+88fP3u+8LECrMoWaWALtMuZCXX5VN9q+l2Te1ZYMl062BeeYsUGwtcjPZjjA0+3azoFa5t2rAdU4tXztY6f8qQHnBJ1f9eSQ97r7ooDAIgkC+ByApNIPSUnS+aWJ7PaXr1+iKHXqL1UC+4lUxq9dJpWuzKmprVzsnhuVoA16XaleEYsgTbY92KNbJhS82KWqFtZVPErfRtu/VavNLWreg0u9Tnf+HZpxLKggAIZE8gjkK3/trq4tXb2eOJ0YE5Ta9eX0R0m1cO3nrnUVmWHz/+lKoUq+17Hz1WOEW0JFFf3dqiLKyqjCSNLtaF2ampWWWzpFObbiPaSqw7SYrLx60V+SR73/DKGbcfK2TLXiqK02yi5/8e9p61URwEQCBXAnEUOtfej+L3nKbXeH0R0ZKEUmgjefRX7R5XGeaILyIz12+RBIoFSdQu3ap2oNmmulLMht8pvRzqxpVNtqC+XmYNJp039TjHfVxQ/Tp0vMXDfqgHqAcCIDAFASj04NTnNL3OqS+DBz5eA8AejyUsgUBOBKDQg0drTtPrnPoyeODjNQDs8VjCEgjkRCBIoWmCwOsxBHIaFLt9hVTsZjPgGWAfEC5Mg0DCBIIUOmH/M3BtTtPrnPqSwdBhF4GdSeB/EDgtAlDoweM9p+l1Tn0ZPPDxGgD2eCxhCQRyIgCFHjxac5pe59SXwQMfrwFgj8cSlkAgJwJQ6MGjNafpdU59GTzw8RoA9ngsYQkEciIAhR48WjK9/u3f/+NvL6/+1p9/73e/9a9vvPvB4A0P0ID0ZQDbMLmTALDvRIMTIDBrAlDowcNL0+vf/v0/fuYv/vkzf/DHxZe+/Gu/94ef/9bLOYo0pGLw4dLWALC3UUEeCMyfABR68BjT9Fo883+MPPPfr/3eH37luz+Vtqsyq23rXJzO2Vb3pBdIDEQA2AcCC7MgkDgBKPTgAaLp9bN/tSl+80kW6OJzn/uc3NSaHgmlZdjzSZ/StajYmGepLc+9sQ7VDTh7NGnv1VndPJSqHWanR5PRi06KPXpvYBAEQCCUQG+FvnD5RrHaPvncTWpB5EEafOLKzWK1vXD5huTYRH7TYt3/w48I0ef/+qXiS18Whf6f//tSjk8WaUrFoeMhkKceNjodWL26J/ZCPx6ydsfscDtTlmxin9IbtA0CIDAWgX4KTdOxVmVJ09pOH9ZXe4dNr2NhGLIdYvLS2QMj0nYZ/T/+11f/6Hv/8cLP7g/Z7CC2qS9i+ojxIDa6E3rY6HR3LX3W1pLnS5ozh9nRNsdOe9jHbh7tgQAITESgn0LLTKET5LlW6GZf5FlFv/5nz/vPuzdPA3plWSzWG/voXfV4oOoRwWbhWdumbNpPOUdYvXT24AvP3ypW2yeu3PzOT36Vss+7fJO+UAE51Ak5Jbv3rdb8J0XVhJNE9N9l2Nj4s9bajQh5hpQaJDJKTMnlcmGHzctmaJ1p606h233gcbjcONttzY03JgVvK0lkggAIzJVAb4UWECLJF6/epudDd87Iblo0kyVPbpy0UyXNgu5pgLUqbooUDzJJzGl69fqit0l6jgcJnkRZEnqZ62XyxzczXmgMuZSVUxomJpMHjFhoJlp94JpqSJoR65pzhjkldoZKeNiHagZ2QQAEEiPQW6FpspApQ+ZomaCL1fb6nYfX7zx8/e77qrMyP9L8y9NrNcnps6zg7pm7dtHEoq5s5pEUVnm42+ml1xc9GGQAkAE53DEe7GZz9bU8DQI9BiQtCS3bKm0GiRsZ6gOfqKeyUJ2u5+z3wWuuqmD+cy13Ujv6pIf9aHswAAIgkAeBQxRar5X1HC35kqkYqGmxNKudxfqMXm0Zffa8mnTrk68ylVlyTtOr1xc59BKth/JhzsTPBffcjgWlgua0jAdJ6EyVdnaqalY0d9WiocVnXd1uH3Y2N9pAFJ6jtYiGQAAEUiDQW6HJ6RfffKAXScVqe+udR2VZfvz4U5pNitX2vY8eqx7ytEhZRpyXSyPTdKy2Jd28qTKVoeySc5pevb6I6PYeDzIcTLhpGPAnMxLEKlPKKZk0I0Dy3Qa0Un05q0vagWOaK6qNbCnlfJAsr6LkTzMmPezZvQXgMAiAwGEE+in0YW1QLTO3qY1BNbNWs6G9tEcXoZWWraUqHuPDJHXnNL3G64vRY/OnP6hVQ6Qolku6vItGBo8Jkcm6fFaiy7prYryjpA2/Le4+E9R92FVR5bvmsMs9yfsJjYLACREYT6E9qPyVIWWrGdArl/9hPFWbnsWc+jI9zWAPgD0YFQqCwKwITKTQ6itoixMKnceoglRMEidgnwQ7GgWByQmMr9C0vSnfQBMBKPTkIyHIAUhFEKbYhYA9NlHYA4E8CIyv0HlwiejlnKbXOfUlYoiHNgXsQxOGfRBIkwAUevC4zGl6nVNfBg98vAaAPR5LWAKBnAhAoQeP1pym1zn1ZfDAx2sA2OOxhCUQyIkAFHrwaM1pep1TXwYPfLwGgD0eS1gCgZwIQKEHj9acptc59WXwwMdrANjjsYQlEMiJABR68GjNaXqdU18GD3y8BoA9HktYAoGcCEChB4/WnKbXOfVl8MDHawDY47GEJRDIiUBvhdaTxfbt9+mwWG23b5snWcnhb/zdDblps+UR/xfPvsX6Xcr2B8HdjXl/2WNKaGLH2Emh7qR98QMeBkRuJco3Dw2rVivlhsphPtSMHXAwKfYD/EUVEACBOAT6KXSx2n79B+civcVqe//RJ2VZklSLRx8//vT+o0+kmM3vmNo6TolJSajCdUmuH0n56RNzml6bfblw2XwUe/K5mwSaCujQP3HlZrHaXrh846BIqHDX7rYdbkxbCK+1q2Rca7ta8fOb2P0SOAYBEJgjgX4KffbgQ1ooeyg8PaYnXNXLdExtHafqNsyRKmxWNvKE3mQFutpXaPYkxxxPKkietSpLmkRaH2rZDu67CrcOfXD92oDpUWtXUe3PrjLx8z3s8RuARRAAgSQJ9FNo6kJzqv3vnL987Y6cffK5m6sfvV3vr5va3LajkVd3VKmte3YQqS8/BMk8ScgrXH9eIRX3q5t27VOzlhv7eEKz11k9lMi5pM6I5tuza3ogV/UoxHqPQo/mNL16fZFDnZBhIN96tJJysaw+ZalwVGL87xX9KmC2wIaficUPLt0VOw76y/KYLHajZkcPC7kV7W7ftJNsb/j/Be/wTaEFEACBhAgcq9C0en7m5V94fSpW23pmc2qTHEnUl8ibpZkx/bWxLmwmZ5pVuZQ6S9XtJ4Bq5uVC7KoUNhNyJRO1bxw5V53nuj3+n9P06vVFf1ajdLHaXrx6++LV23Koy7RR01HQEimB1ZnVk51tVCliKjb12HE1p7Y6nO7x02xS2RQ3m75JjpQZI+FhH6NJtAECIJAAgaMUmr5+fuFn91s7Up+a1dTm5szGLOxWwLzUtTk829YlvLQPkDbnWKmb1c28y7V3mTL5lUBTA/ZAVdRGWrvamTmn6dXrCx3Kq/4GRCv09TsPr995+Ppdcy2h++sYBg74rihw/iGx47rGlR3pnb7p8q4rQ6c87EM3B/sgAAKJEDhKoeUSbuqM/jbau3bMTYVuSj1XC2Atok4shZHVVlJRb4q0RjZsyRmXql75ak+0psH1WrzS1hV1WiyHJuY0vXp9kUMv0XpY+8TmmLcNAyecmnxb2tkx4QiLXZudqrYdh85m0zddN3QAHF9OeB5vChZAAAQyItBPoZ95+Rc0WZA2S1pmELrSmw7p91fMgqc2/t9KJQmzZNEcK2termr/52WyLmxOmOlUNirNFO1V98u7hXdNBngR7WZnXVGna16FHAickMKJl/H6IqL74psP9KK54XKs3AAAIABJREFUWG1vvfOoLEu6ZpBqvffRY9c7IWqA0zCoX1VQZUq5XetdE/HqM11o7PbZlPPON8mShOvKCCkP+wgtogkQAIEUCPRT6BCPzx58eOXGvUZJmdr4yi9z/Va1dK72FGmiNdMi/y03VnPpsJqHa4Uria7smEa96k6G9UVpZEpc0rXElDqrjTQ6tjdjTtNrvL60DAMX6+VSvptQ4d4RERfxXbHj4VR9etthx0W56ZtUkcTesMcsEA97TK9gCwRAYGgC8RV6aI+zsz+n6XVOfcloIAF7RsGCqyAQkQAUOiLMdlNzml7n1Jf2aCWZC+xJhgVOgcDgBKDQwyNebeX72sEbG7gBSMXAgNvNA3s7F+SCwNwJQKEHj/Ccptc59WXwwMdrANjjsYQlEMiJABR68GjNaXqdU18GD3y8BoA9HktYAoGcCEChB4/WnKbXOfVl8MDHawDY47GEJRDIiQAUevBozWl6nVNfBg98vAaAPR5LWAKBnAhAoQeP1pym1zn1ZfDAx2sA2OOxhCUQyIkAFHrwaM1pep1TXwYPfLwGgD0eS1gCgZwIQKEHj9acptc59WXwwMdrANjjsYQlEMiJQPoKPc19FiPGcE7Ta5598YeQupd3xDgPaCpP7AMCgWkQOBECvRX6wuUbxWr75HM3CRDNHfqOHE9cuVmsthcu34hE0J9eI5kdz8ycptdmX0YfDxK48IFRL2meweLuCW/N1QtIC8kkmtiTcQ2OgAAIDEign0LTdKxVWdLeo43izSmpz557gxMPxd6mBi/g9WWK8SB9DB8YtZL0kDR+VBpZqxWQBtJJeNjTcQyegAAIDEqgn0LLTKET5J9W6DaP7SS4qZ5bpR9CVD14qHpyVVmW/GSh6qmCMnvapxzZYtXzjgp57qB7ONVivZbHIqnnXDnrbb4Nmyeshm1mFOteX+RQJ8iRfeOhPdDL5aIKqntiVRW7etDdUfXsyUZ5iX5tSJjRZUefk+iGqVFI9mpE8PaqhcIgAAK5E+it0NJhmYIvXr198eptOaSEFOOEnQdJmc1kKhpN50WGjTzXz9EpU6chs1LLGKezdqImA3LWPHeybpOdGuX/OU2vXl90rGUAhI2H1kBL6DtiJ6ckUX90dBXr1iFhP8lVQ4Gl2owBbWqUMdGzEQ97z9ooDgIgkCuB3gpNk4VMGTJHywRdrLbX7zy8fufh63ffV1Rqk+BmyXLrFjB24mwRYlNx4cl2s5ZTYG7IarV7MnBD3pVvwyaF1bDNjGLd64seDDIAyBE5bB8POwK9PrO1W2PnBV3LarO8WyLXBFhnKxd4zIzC8IBGPOwHWEAVEACBHAkcotBlWcqUoedoyZdMRURPgmb9ZBTTzZG8oHE5UtVMzEaiRWJdGVWrXaGljlibICGsJmg7dpNeX+TQS7Qeyoc545QLorioRkjzrMvhoPsKXY+1lmJX0ok8f3SjWqppcSelhPBMySn4AgIgMDiB3gpNHr345gO9SCpW21vvPCrL8uPHn9JsUqy27330WLlvhZaWSDLbysRockhjWzc/zSkp61KuljFOc63Jq0ypFpUf4yfnNL16fRHR7T8edgbaBqgROwl/LejyuaxR3oySxpAQI9Ug4E+KbkiNPzqCWvSwB9VBIRAAgfwJ9FPoI/prZkd7HZBZvfB6x0yR5q/26xczt9KfLSbTqi1s5mSrwl4trlS7LIgLGmvc5BFdOLDqnKbXqH3hmFXBkUBbzn7sWoZKVV99NNPjxmq0yZAhUW/AtGIa4UE27SDpHltRsXc3hbMgAAIJERhVoatvGQftvky6g7bSx/icptc59aVPDCcuC+wTBwDNg8BEBOam0GZdJXufEzH1mp3T9DqnvnhhSvkQ2FOODnwDgeEIzEOheQs0yZ3KOU2vc+rLcG+q6JaBPTpSGASBLAiMptBZ0BjEyTlNr3PqyyDBHsYosA/DFVZBIHUCUOjBIzSn6XVOfRk88PEaAPZ4LGEJBHIiAIUePFpzml7n1JfBAx+vAWCPxxKWQCAnAlDowaM1p+l1Tn0ZPPDxGgD2eCxhCQRyIhCk0DRB4PUYAjkNit2+Qip2sxnwDLAPCBemQSBhAlDo7TG6G1434THQwzVIRQ9Y8YpOjj18nKPkkQTijRpYmgOBPQo9hy6iD/EITC4V8bqSk6XJsR+pOqgeTiCncQlfhycAhR6e8YxamFoqmjfuPACub8Tc5Wa6m8KGdGBq7PKknPOyxL+hCEwe5ZChiDIjE4BCjww87+aak8iFyzeK1fbJ525Sx6iAPFGjLMsnrtwsVtsLl2/E6LkvrspmxylVyiTrJc1TsJbLhb4RXb2AV3uKwyb2kb1gB4YSJwh/WZ4z5JFji+aSJgCFTjo8qTnnTSIkz5TpPeuseahl+9B+dWhnxymvtVpJekxl7WGVnoR7tac49LCP7wI7AIUekABDHj+8aDFdAlDodGOToGfeJCKHOkFua4Vu64iWSUnbxIYfeCYPWuHnXMlTqmghrJ5k5R6TVe1XcxW3f8052khZ8tOmnUQ3TLV5P3Ke4B25XWmOHRhQn7CMZshCHQkQKKHQGAQ9CHiTiF4WiyRfvHr74tXbcqjLqJZElfW2s1VH2m82gkop9zWxFVm9He3VlVPK+GZpc3cYccLMUm1cVNWVxxMmPezje8IOQKEHJMCQxw8vWkyXABQ63dgk6Jk3idChvJaluaSI3NYKff3Ow+t3Hr5+933VI62CkpaEKbhZ2vWwE9G6drq1rgg5KzQvl90ie4cRnW0qVdeL1dxQPk+W9LCP7wc7UNMn7zsOGQY6UZbnbz04w/o4hABDHj+8aDFdAlDodGOToGfeJCKHXqL1UMTb9kuroKQlUdr9590K7eRU1r6qrjvLCLUUuyWyE/lKyyuJVqbYwLT/C8+p3GAHnEKHyHOzVohQ7S5zbVk8tT5zPuwu2Shz9uxiZ90jzHZf2d7VaMNDXCk21eBOu10odNrxScw7nnMrt0R0X3zzgV40F6vtrXcelWX58eNPqUqx2r730WPVG/PAULdkVRva1ULYqWzbBrVoqCnWWEMbDfaeEt5ppHJLXBLryt9Jkx728X1hB5yuSFj3JnroaLfglX2lNLB8YDHX984etVprzfQNMuTxw4sW0yUAhU43Ngl6FnMSkRXscrlUKrtcLmhF636izCXVRV78RHD1Q6mqFFUzys1/lNMw0tRh+VRQM5VAGGJiP6g77IATlWK1ffq1e96/Zqb93OZqdWrb3mJBOqeaCCwfWGyve1Sg1Vprpm+QIR8UIVSaKQEo9EwDO0y3Bp5EmqI5TDdyszow9v042AEnKk0xfvq1e8Vq+7VX7mrZblPoV+XT03JzXtqV8XL5VFFc2pTnpdkZpj97qHIW62fdLrdfzErg+hLVXKxftWblI9o1aoV2yPmjWlEsr1k5F/n0HHOdrVT/wEavLdmR4pn/Y7eO2PLmUrF49ox3Dhjy/nCgxOkQgEKfTqwj9HTgSQQK3R6jgbG3N6pz2QGWFvulqVZiSjdlu6HQRgWtgoopI2CcI2J5Xm4uidBaIT8/Wz9VVN8ltxerFHdzqRL72q64qlIpouRwYnOJNVt80wkuVtZ8C2u0VldasddCuiYYsgaP9KkTgEKf+gjo1f+BJxEodHs0Bsbe3qjOZQd8OaH87le17UxLZF4c+0qpF9B21bm8ZpbUbpXJOufWslysXYy5vGlIpY2E0x9dd8anrFn+rOB62lhAH9AoN1F5QgSuLV3XTHMMWYNH+tQJQKFPfQT06j8mkV64YhWeHDs74HSrsTiuNKamx1Z1ajlGBbsVun52p0LXi2kBdmlPF60eOwdeXS/qCm0/MdiVekGr9h6edzfqzhpKZ+unFutX6VU3wZBjjRrYmQMBKPQcojhaHzCJjIZaNzQ5dnZgv0Lf+6D26+eGkLfucstvqPSON7Vlctp2uWVjXIppI03pZbWWr36NVDeLOQXV2mnTrb6FNVpXaLsxcGlZfT6oIbW4dOSRPnUCUOhTHwG9+s8zda9KKHwsgcmxswM1OWlomNmn9TKbOfoaLrlSzP3K2W41V5vQdCUXb0rvuFKMLvhiAa5vaPM1+fpKsepysM8uvsEayXW5If4a23W26pTvG1fc3+i58sSYNYfVdWquFYZ87GhB/TkRgELPKZqD9wWTyOCI2xqYHDs74OREvjelU7tePcHGIRHwrhGjTIbcNgKQd6oEoNCnGvmD+r1rIkb+CAQOilicSiweNYWetdyaPW31533tfRyH2pfrzhRDjhMyWJkHASj0POI4Ui9G0CE0sYvASDFua4bFw8nJrOV5uG7SHrt8e11riCG3BQB5p0oACn2qkUe/QSCYAItHTVEg0nEJMOTgqKDgCRCAQp9AkNFFEDiOAIsHFHpAAgz5uFCh9rwIQKHnFU/0BgQGIMDiMaA+xV2P5miNIQ8QP5jMlgAUOtvQwXEQGIsAiwcUekACDHmsoKKdHAhAoXOIEnwEgUkJkHjgdQQCk8YZjSdHAAqdXEjgEAikRgDLuxEiAsgjQM6uCSh0diGDwyAwNgGIxwjEAXkEyNk1AYXOLmRwGATGJgDxGIE4II8AObsmoNDZhQwOg8DYBCAeIxAH5BEgZ9cEFDq7kMFhEBibAMRjBOKAPALk7JqAQmcXMjgMAmMTgHiMQByQR4CcXRNQ6OxCBodBYGwCEI8RiAPyCJCzawIKnV3I4DAIjE0gmnjY5yQv1me6A2frRVEUy43OO8V0NMinCG+2fYZCzza06BgIxCLQFI8Ll28Uq+2Tz92kJqhAsdpKi09cuVmsthcu35Ack4BC13DUDpqQa6dxcJIEoNAnGXZ0GgT6EPDEg+RZq7KkSaT1oZbt1jaxhiYsHuRWVsg8NQJQ6FOLOPoLAr0JeOIhhzpBRrVCtzSj1tAkzAX/YZdbYLZwQ9apEoBCn2rk0W8QCCbgiYdeFoskX7x6++LV23Koy7h2RKFtgr58VklX8ARTHuQTJIAuNwlAoZtMkAMCIFAj4IkHHcprWZakx6TQkk+JLz5/y9lihdaqjF1u4kO4HCukQKAsodAYBSAAAnsIeOIhh16CDmX17B2aNqDQu0kLzN1FcObkCEChTy7k6DAI9CXgiYdo8ItvPqC0iLE+pLW1FDaNskLTutn+7Orc/tgKv7Yy+xA1Vn2DhPJzJACFnmNU0ScQiEogUDykWDNRucMKzWLN14nh99D2mwIodNRhOwdjUOg5RBF9AIFBCYjidrdCxURmvMPuujgbCBmgTooAFPqkwo3OgsAhBALFQySZRFoOD2ny9OoEQj49MCfdYyj0SYcfnQeBEAKB4uFJsncY0tAplwmEfMqITrDvUOgTDDq6DAL9CASKR+uvrS5evd2vsVMtHQj5VPGcaL+h0CcaeHQbBMIJQDzCWR1cEpAPRjfjilDoGQcXXQOBOAQgHnE4dloB5E48J3oSCn2igUe3QSCcAMQjnNXBJQH5YHQzrgiFnnFw0TUQiEOAxAOvIxCIEzBYmQsBKPRcIol+gMBgBLC8GwytMwzIjgVSTAAKzSTwfwCBEdYQaKKVQEBwBiwC8RgQLpsGZCaB/x0BKLRjgdReAq3igcwRCOwNzaAFIB6D4iXjgDwC5OyagEJnF7IpHeZJ5Lws8W8kAsw8hbhP6cPs204h0LOHnF0HodDZhWxKh3kSGUmc8DmgLM+ZeQpxn9KH2bedQqBnDzm7DkKhswvZlA7zJAKFHo8AM08h7lP6MPu2Uwj07CFn10EodHYhm9JhnkTG0ycso5l5CnGf0ofZt51CoGcPObsOQqGzC9mUDvMkAoUejwAzTyHuU/ow+7ZTCPTsIWfXQSh0diGb0mGeRGr6dOHyDcrveC3L87cenGFBfAABZp5C3J0PFPQnn7tJWRJ6KfHElZvFanvh8g3JQaKbQAqB7vYQZ8cnAIUen3nGLfIk4hQ6RJ6btRpCdW1ZPLU+c2YbBfqeim7wvCyPsHn27GJnB/eYZXpTDhvPBy/oZVlSASmmD+lZ0VN6n0nbQi8Tf+HmGASg0GNQnk0bPIk4vfTm4o7DTtHdo1KddZ0zqlh0gwcodKAPe4ox8ykHkeeDHOoE+Ud6LPkNpzfLYrFeLwv7t1ifUYFNlVEUy43NscU264UtttyUZ1WykCoui+s02sosYze0zDoCdyMSgEJHhDl/UzyJOFEsVtunX7vn/Wtm2onb1VJSSpl7VKpRvsPUQAah0FsZ33pZLJJ88eptej60LKmlvEpYLSYZNslKkLmAFWaj2rYYqbFK2mypzGK9WXKKzeT5P7+58vQeXg9DAAo9DNeZWuVJxAlkU4yffu1esdp+7ZW7WrYbCv0qL4qK5YbFb/MsrZkW61dJku3kTMuoazbHCPly+VRRXNqU56XZOqY/e6hyFutnd2+btzTd26bftP2Esb5E3lj/r8mysFhe0zvkrZ2yO/yeYxVkZj7lkPJ8oEN5JUkm/0Swi9X2+p2H1+88fP3u+8p10WCSYdZWB0VkmU8ZWW6kZU1NxD2hV+1llPQgZ+Q5XB2OABR6OLYztMyTyH6F1vJMml1bB28uWd0SO1bPFs+elefl5lIlwO62ZbLCNsVYvyXTVBFRtHp/frZ+qmj/3teoIFug1g+w2d501SPnvyrW8h22nOWEzyR1hdZrZVFrrdCSqd4Ju+SWNPZ8vQhX6FnIskLDby6VheTJE4BCn/wQ6AOAJxFR1uqOVzIXdyRqCm3XoEopWaWMKqu0UTv6o+vI1Cm3irUFltfMkpo03jPilJ6W3bzgrvL722w2rX12aWXZZdJHkLZO+UySVmgaNS+++cCT5FvvPCrL8uPHn8pIeO+jx2qItSm05JmVcZhC2/1uWVkr+xkn+c2VcRfgenQCUOjoSOdskCeRmkLXpNfKXmNP2wh5s5hd6apd7upabhY2o1ikpq+uF60KXdfaOAodYNM5JhzY59qHg7ZMV7etUyWt/olJugp9xBAXNda73OfVVx6L5TJwDV2W6kqxxtfZR/g3YVV+c03oAppOjgAUOrmQpOwQTyKiTO3SW6y29z6o/fq5VaFLK0i8QS2/tmJh21wqaE1sVK2h0GZV2rJffdAut246xGZr09pIq7c2c0+nDNiz9VNqdwH35U75DRHTN35zxbQJW7kTgELnHsFR/edJZL9CeytmX6Hd9jWtWVmVa2vQ6sqpzy6+sWyuodV1YWbL2FyN5TaQO68UM/pKf+4iNfkptvk0wH8dNv1irf6fV9c/1a4U290pn8ks19CjDte8GuM3V15ew9thCUChh+U7M+s8iTiFlocv0aldr55g4zCcADOfciil4MOU/R+lbUAeBXNmjUChMwvYtO7yJFJT6HCxGb2kWy7bdXH9O+bqSrHU+8LMp4x8Cj5M2f9R2gbkUTBn1ggUOrOATesuTyKpq9roHwUGBMLMp4x8Cj5M2f9R2gbkUTBn1ggUOrOATesuTyIDCtKcxDVKX5j5lJFPwYcp+z9K24A8CubMGoFCZxawad3lSQQKPR4BZj5l5FPwYcr+j9I2II+CObNGoNCZBWxad3kSGU+foixDszbCzKeMfAo+TNn/UdoG5FEwZ9YIFDqzgE3rLk8iUOjxCDDzKSOfgg9T9n+UtgF5FMyZNQKFzixg07pLkwhexyeQQtyn9WH2rUOhZx/iAzoIhT4A2ulWwSQyfuxTYD6MD/oOoONzTa7FYSAn10041IsAFLoXrlMvjElk/BGQAvOmDxcu3yhW2yefu0lAqIC9c1xF6IkrN4vV9sLlG7uJdSh0x6nd9jI/04SceYfgfgQCUOgIEE/HBCaR8WOdAnPPB5JnyiRVlnTzUMt2nV6HDHecqtuY0ZEHeUY9Q1cOJwCFPpzdCdbEJDJ+0FNg7vkghzpBZLRCt7Myj5g0f4v1elk9a9I+S5Luhm4e+lzdztxk2GdAu+O5PRK6Rkhg1nJxcNoEoNCnHf+evcck0hNYhOIpMPd80MtikeSLV29fvHpbDnUZRcGoLemsVWrvEc+ydJaEqmqU2yuvz2af9iBn3x90IAYBKHQMiidjA5PI+KFOgbnnAx3Ka1mWosdaoa/feXj9zsPX777voJ2tqwdAmyyluG6ZTBqsTlFBWmFDoR1KpE6CABT6JMIcq5PeTB3LLOx0EEiBueeDHHqJ1kMRb9PHVoU2q2laV5+zgCuFbjnbQSvjU0Iv4z7A9dgEoNCxic7aXjqTCH2bedT3knbd1r5tuvPUuf0S1W82gjO7h00KzD0fRHRffPOBXjQXq+2tdx6VZfnx40+pSrHavvfRY9W5tl1ukWPDsbGGbjmr7M0o6UGeUc/QlcMJQKEPZ3eCNZuTSIxf3RwC8kBRtNJbCexOGa6uVWoTbyj0IcGq1bHY61eKEdWiWCyXvAlelTKhajlbMziXg+abay49Qz8OJwCFPpzdCdb0JpFIv7o5BORhCk3zvr8Ebra/U7yh0E1YyIlDwHtzxTEKK5kTgEJnHsBx3fcmETnUCfJIb362+0gaa68AMqtVdVhd7atzeD2r8/jHOPbbzepKIvMjnjO5tmixoB/2UCYv3mzR5YZ+1OM3rarbpKrk1nOVxLc7097bw3OF7eEmjq6Zgg9HdyJ1A4CceoSm8A8KPQX1bNv0JhH5PlKu5i1W26Bf3ZC4kRwSjUruJMtKI0khnWJN1b+Rted3l7TGpLYIdyWwtp60Z7yQHE7w/xIwtYa25xrOSMloCY95NLt9DKXgQx9/sywLyFmGbWCnodADA56XeW8SoUN5FZ2m38VKPiW++PwtgdEU6GoNLYJJ+icrY7teVppYFTda21ayyrRSrNvSFpwe0zXG3JZxwZZbrM+orv3S1KzM+TtR1yyJvf4QIH2MlSB6sawdZicFHw7zPKNagJxRsEZzFQo9Guo5NORNInLoJehQVtjeoQgiyVvFRQsp71uLXlMZra8iivV6DFkV1QVUtlsxU6YWZlFoY45OVyotzVbZM1bo7dvv/83rd7/6/bfog5dEkxHj/8gE5E0U2S7M5UwACp1z9Eb33ZtEZNZu/uqGTkl5SVQua9mkLC+HDqufyZblZi1fVVvZrq7vNQLZVlLrpzZM6eqTgZXexXpjf0BlrLqS1SlaN7NKuyKuWd+ZASLioxugCTF59uDDb//43T/5l//8wvO3qN1itd2+/f6YPogzp5YA5FOLeEh/odAhlFCmIhA4iUixZsKhrJTVbC477bOKV5VRBfgCMLegpT3pSmubJWnha0873TV2eUXM32qbBjmPLiyTnMX6jM/IPrf6HtrZqvbHK2dcD+OkhGEccw0r9x998sLP7v/pv/38d/7hDWqLXr/w/K2v/+D82z9+985/fTS0Dw2nTjEDkE8x6vv6DIXeRwjnFYHASYSKyQrbO1T2kNxPIJD5fkP1EtfvPPzmD3/5le/+VKJDD4v86vffWv3o7Tfe/UAXH8gH3QTSgIwx0CQAhW4yQc5OAoGTiJ705VtMEeyd1nGijUAg87aqft4b736w+tHbX/3+W94P2b/y3Z/+5Wt3rt956Ffg44g+sEn87xMAZJ8IjssSCo1R0INA4CRCxUSSvcMe7aGofSiFkDyAx53/+ujbP3736z84118tF6vt7/zDG3/6bz9/4Wf37z/6ZK/ZwLjvtYMCHQQAuQPOyZ6CQp9s6A/peOAk0vprq4tXbx/S5MnXCWSuOX3w8eOXzh488/Ivml8t/8m//Oe3f/zu2YMPdfm96QN82GsTBTwCgOwBwaHZgAQFEAgngEkknFWskuHMr995+Dev3/2j7/0HVZHXxQtvrn709vZt9RTIns41fTj0fuzyHIyeHpxA8SbkE+g0uriHABR6DyCc1gQwiWga46SF+d/+/T/+9vLqb/359373W/8qV3K98e4HV27c++r333riyk0qSa+//08/+eYPf/nS2YMoTooPZM37GltfakAb8tqT+hY9FHpnQDzIO8vhxCkRgEKfUrSP7ismkaMR9jZAzP/27//xM3/xz5/5gz8uvvTlX/u9P/z8t17+k3/5T+/bhItXb//pv/38Oz/5VchXy7388OIuhzpBBrVCN5tY8o3bfv3PnpeHQptilXC/siz4B+ryAzu5wY2pO9Av2pqeTpAjMCdoG02mSgAKnWpkkvQLk8j4YSHmv/5nzxt5lr8vfZnyn7hy86vff+vKjXt9v1ru1REv7npZLJIcdD92lmLT+mYpgstJ+/tz+k28+Rk7pdSye7OkrF7O51LYg5yL2/BzUAJQ6EHxzs04JpHxI0rMP/tXm+I3nxSB/tznPlesth2/j4rrpxd3OpRX2uWmFkWwyb3rdx6+fld//63k1km0CK8+y6drt6OZ8yragxw3grCWKQEodKaBm8ZtTCLjcyfmn/mLfy6+9GVR6P/5vy+NeW28F3c59BKth3rBLdvZhPFsvaDHk/DKWCu0uX2b2dQ2Cj3nzW0ZUUJPcpAAASg0xkAPAtNPImoftIffrmjttp2STeu0NHWAmL909uDzf/0SLaP/x//66h997z9e+Nl98X/ohBd3Ed3m/dhvvfOoLMuPH39KVYrV9r2PHiv3tAZb9V0sl0amqYiJbnXghFllKkPzS3qQ59dB9OgAAlDoA6CdbpXmJHLor24OZXiAQtsqrL65KnRZli+dPaC7jjxx5eZ3fvKrQwkeUq8Z90Os2Do2Gm6z2hxybGiFvVwuaKvAZeuNbpd7sAuJVowIOdEewq3+BKDQ/ZmdcA1vEjniVzfjQSRJ4Ik9Y4UeD1mjJS/ujfOHZ/A1YmShvsI+3GqWNYeDnCUOOG0JQKExEHoQ8CYROdQJMqevGGppwMqm2eCk5RLtbOqlEi2sqgWXKVRtflJF2hXV5WWjVGXWH05Fa7WaQquypglW8RZ/J8wStjP0gb6Idh2DQm8dDKRAAPcUwxjoRcBTC/k+Uq7mLVbboF/dkPRaWSWZNMlKMFlsqYyVTTpjkk6hbYpEVU47W65bykzE/kH+AAAgAElEQVRZlkqh1QmVdBUTSXnMJ/FqAB8oEBzrqldQaCj0JAM83Uaxhk43Ngl65s3UdCivotPenTSowBefv+V6ZCWxmp536GtNNaWMVKTTtASn1+WmTaBJ02V97BRa2xfzzsNkUh7zSfxKwYdJOj5mo4A8Ju1c2oJC5xKpJPz0JhE59BJ0KCts79D0RIRW7hi13FRraF5WaQWtTi03UrFVjFuFtmZHraF1fmvFJIgf/WyrKL2Q+EaxBiOtBAC5FcuJZ0KhT3wA9Ou+N4mIBjd/deN9D+1VrBa2VoydOnqqq1TclZFMypK18WZtvpv2LNjOubrm0K2hVVnKFFv9mAxd2kc3dHtt9lPwoc2vWeUB8qzCGakzUOhIIE/DTOAkIsWaiYoTLWBlj1p/ncxraFNSFauyRaFl8V0Z4WqVcptczmIrphWn0HXzpjx5kVokheGEjqXgw4TdH6dpQB6Hc16tQKHzitfE3gZOIlRMVtjeoemDFtpefTq4Yq9WUiocyHxQl1PwYdAOpmAckFOIQmo+QKFTi0jS/gROIlRMCsuh69uhQmtXyLw2dubmnBKME3YyBR8m7P44TQPyOJzzagUKnVe8JvY2cBKhYrHX0NVm9WnpM64Um3jIj9d84JtrPIfQUgIEoNAJBCEfFwInkdZfW435pId8iO73NJD5fkNHlEjBh/7u+7+uNh/x0rzWwPYtT8j9w4IafQhAofvQOvmymETGHwIpMG/6MPb92B13X3fdGT9VL2nuX6af0kFXQyS0I9OE7HcIx6dHAAp9ejE/oseYRI6Ad2DVFJh7Pkx6P/a67nZBrZVsPOkSCt3FDucSIQCFTiQQebjhzdR5OJ25lykw93yQQ50gzN7v4NvYV78+55+3GR21N2i3G9Dux3LVfnR19UFV2h1V+9WN8nzv2GKxXi/lB3fmV3Z2uezuBN4w1ebrmHkCc8xG0VbiBKDQiQcoLfdoEsHr+ASmHQeeeMg1gHKf19D7sdvfo9d3lo1Sco5a9W6WnEldl1OSqC+Cq/LGGml77bJ/J8ws1caqNjUtYNO6B3l6h+BBAgSg0AkEIR8XMImMH6sUmHs+0KG8ik5Lgk5dv/Pw+p2Hr99930EzsuldrKVk0i2I7W1oqKBb65Jkd5Z3SlwTYJ2tXFCmnIuTpTzIk/mBhlMiAIVOKRrJ+4JJZPwQpcDc80EOvUTroV5w2y3oboWun3VyKmtfJavuLIdFS7FbIjuRr25AV31KUKbYwIT/C70JfUDTqRGAQqcWkaT9wSQyfnhSYO75IKLbvB/7rXcelWX58eNPqUqx2r730WMFzXwJvWP7mla99bOioUaMG2toe2u6hrXGLrcYqfwwPtgPAv4J5ecESQ/yBB6gyfQIQKHTi0nCHmESGT84KTCP6oNb0bbIpFFi/jOn+bIy9UOpqj4ttv3y7l7ucqVYU4dl7V0zNX5o6y1GhVw3jaNsCUChsw3dFI5jEhmfegrMU/BhfPIjtwjIIwPPojkodBZhSsVJTCLjRyIF5in4MD75kVsE5JGBZ9EcFDqLMKXiJCaR8SORAvMUfBif/MgtAvLIwLNoDgqdRZhScXLESaT57WEqEEb2Y0TmO3uWgg87nZvLCUCeSyRj9gMKHZPm7G01J5HB7s8Mha5GU5P5+MMsBR/G7/XILQLyyMCzaA4KnUWYUnHSm0SGvD8zFLoKusd8kqGQgg+TdHzMRgF5TNq5tAWFziVSSfjpTSJyqBPk6L77MxsBbrsbs9xxSim0+0UN/cImCRSjOSFsR2ux2VAKPjS9mlkOIM8soFG6A4WOgvFUjHiTiNy5Qt/u8eLV2/R86M5bDZtfovK9Jky60l4jxt6NKZRU+/dqPgnsHvNJ+pyCD5N0fMxGAXlM2rm0BYXOJVJJ+OlNInQor6LTkqBTLfdndndkLL07QW6W9fs9uQW0uldzEjBGcsJjPlKr9WZS8KHu0QyPAHmGQT26S1DooxGekgFvEpFDL9F6qBfctccKyR2eLMk2hT7FzW0ZVgJTcsZPpODD+L0euUVAHhl4Fs1BobMIUypOepOIiG7/+zOrvWt7d2W1y01JKaD3w1PhMKYfHvMxm5a2pvZBBoN4dEDCN6K+XDnAWvwqU0OO3yNYPJ4AFPp4hidkId4kUp8u3VY2fzftb4PrezWfEPDO7/LH49CM+2C/smvtVH201Ip0nKqVq23blPa7FXWvb1s03JRnOc5hE3Icu7CSMwEodM7RG913TCKjIy9TYO75MOSv7FoBd2hnxynPVK0kPaay9rBK/aHQqzrKoQd5lDbRSOoEoNCpRygp/zCJjB+OFJh7PsihThCZkF/Zrc+orEimTWyqp1rJLoq9hNDsnchTqqrnU9J+ivkyxGxUV3/03YjbjKm+Nmk1Yh+ZZdtxEt0wNXqkBeboLaPBdAlAodONTYKeYRIZPygpMPd8kOsP9EX7wb+yEwnWCs2/vTMSSwXc18RWdqUWRUDXlVOSabTb5u4w4oT5fL1oqz5+mMskNkum6Dfa7CIAhe6ig3MeAW+m9s7icAgCKTD3fKBDeRWdlgSd2vMrO7errJTVrovN+teJKK2cWUfdWpdyVF23gLbr6uVmlxFt21Sq1tvK1BCB3GfTg7yvOM6fBAEo9EmEOVYnMYnEIhluJwXmng9y6CVaD/WCu365liiiJEq7/2wVU6uoaLmTU1n7qrruLNNtNaL3xmtb5MoUGxjzf6E3ZqNoK3ECUOjEA5SWe5hExo9HCsw9H0R0+//K7ry2ZFUb2tUa2als2wa1aKgp1lhDW+nltTYFqtNIFUtxSayPH2TTogd5GifQamIEoNCJBSRtdzCJjB+fFJjH9EG2qZfLpVJZe5N2s6TlS7zcdWDqSjGjpuZP/VCqskfVjHLzH+Vwc2KkqcPyqaBmavRIx4Q8uvNocCACUOiBwM7TLCaR8eOaAvOBfWiK5viYp29xYMjTdxAeHEAACn0AtNOtgklk/NinwHxgH6DQZlgNDHn8kYsWIxCAQkeAeDomMImMH+sUmA/sAxTaDKuBIY8/ctFiBAJQ6AgQT8dEnpOILwDm60b3bWfq0UuBeQo+pB6no/0D5KMRztAAFHqGQR2uS81JZNz7M+ue+bqrz9XT9ZLmFzjLpbtPRf3ntvWaKRw1mY/vVQo+jN/rkVsE5JGBZ9EcFDqLMKXipDeJjH5/Zs2hrrv6jJ+ulaSfyNZ+KCs/t/UrJnHsMZ/EpxR8mKTjYzYKyGPSzqUtKHQukUrCT28SkUOdIEf33Z+5ujcF/TLGbjkbHbU/ubFH7mcz1X40/2qGNqjdUbVf3Sif0Q2Zu0MrbLuLDXo2BR8G7WAKxgE5hSik5gMUOrWIJO2PN4nInSv07R7D7s9sftjavLkE56hVb3WDZcEipyRR36bO8IbM0rfWhMe8tczQmeQDXkcgMHQoYT8vAlDovOI1sbeeWngTlui0JKhAy/2Z5SYRrkNKcd2C2K6xaRXtls2Nm0k1y9d2sZ1lna1ccAWcO8mkPOaT+OUFGofDEZgkvmg0WQJQ6GRDk6JjnlrIoZdoPdQLbrsFXW1fcz+VTCrxrM66nBnekJkJtP8vMNtPIxcEQGC+BKDQ843tAD3z1EJE97D7M/OeNjmqFLp5g2U5aaS6sYZulrc59BHA1KAqYqQik8oNmbsD5THvLoyzIAACcyIAhZ5TNAfvS1S1cNvWVkrr+ml1tbrDsjk95xsyd4ctKvPupnAWBEAgLQJQ6LTikbg3UIvxAwTm4zNHiyCQCAEodCKByMMNqMX4cQLz8ZmjRRBIhAAUOpFA5OEG1GL8OIH5+MzRIggkQgAKnUgg8nADajF+nMB8fOZoEQQSIQCFTiQQebgBtRg/TmA+PnO0CAKJEIBCJxKIPNyAWowfJzAfnzlaBIFECEChEwlEHm5ALcaPE5iPzxwtgkAiBKDQiQQiDzegFuPHCczHZ44WQSARAlDoRAKRhxtQi/HjBObjM0eLIJAIASh0IoHIww2oxfhxAvPxmaNFEEiEABQ6kUDk4cbUalG/M+iBzHwj5u6j3lM8DrQ8SLWpmQ/SKRgFARAIIQCFDqGEMhWBplpcuHyjWG2ffO4mlaAC8kSNsiyfuHKzWG0vXL4RA6IvrspmxylVyiTrJc0DKZfLhX6KR72AV3v0wybz0V1AgyAAAtMQgEJPwz3TVj21IHnWqixpEml9qGX70O53aGfHKa+1Wkl6YrR+brQv4V7t0Q895qO3jwZBAAQmIwCFngx9jg17aiGHOkH90grd1lMtk5K2iY15WmRRPTDSVuXnXC3W62X16En7dEl69JXZoHaPyar2q7mK27/mHG3EPjLLrp6dRDdMtXk/Zp6wHbNRtAUCIJACASh0ClHIxgdPLfSyWCT54tXbF6/elkNdRvVTVFlvO1t1pP1mI6jyHGgtu3o72qsrp5TxzdLmuu+arVJzSSfM52u30a2qK4+nSnrMp3ID7YIACIxPAAo9PvOMW/TUgg7ltSxL0WOt0NfvPLx+5+Hrd99XPdcqKGlJmIKbpRVmJ6Jaj/WymeRW1eXlsnu89A4jOttUqq4XU6aUx1MlPeZTuYF2QQAExicAhR6fecYtemohh16i9VDE2/Zfq6CkJVHa/efdCu3kVNa+qq47y6i1FLsrxdSGthPz+ucANjDh/wTzpbMH/+//9///9vLqb/359373W//6xrsfTOgSmgYBEBiHABR6HM4zaUWkl/ojovvimw/0orlYbW+986gsy48ff0pVitX2vY8eKwrntSWr2tCuNqCdyrZtUIscm2KNNbT9Wpo3sqnNTiOVW+KSWFf+TpckgP/P15/9zF/882f+4I+LL335137vDz//rZch0tPFBC2DwEgEoNAjgZ5HM55CH9UpWcEul3z9l5HG5ZIuFOMtZ1rT2jWuusjLqKn5Uz+UquzRTrVRbv6jHG5OjDR1WD4V1Ewd1ckIlYn5r//Z80ae+e/Xfu8Pv/Ldn0awDhMgAAIJE4BCJxyc9FyLqdAtvWuKZkuhU8si5p/9q03xm0+yQBef+9znZAPj1ICgvyBwOgSg0KcT6wg9hUJHgNjTBDH//F+/VHzpy6LQn1184+LV2z0toTgIgEBmBKDQmQVsWneh0OPzJ+YvnT0wIm2X0Wa7e7X9/X/6yf1Hn4zvD1oEARAYjQAUejTUc2hoYIWeA6LofRDmL509+MLzt4rV9jf+7gbdze33/+knZw8+jN4iDIIACCRCAAqdSCDycEPUIg93Z+FlK/Pt2+/TbWG+8Pyt7dv6h+az6DM6AQIgYAlAoTEQehBoVYse9VG0P4FdzO/810df+e5P6akkL/zsfn/DqAECIJA6ASh06hFKyr9dapGUkzNzpoP5Bx8//pN/+U8qsPrR2zPrOLoDAiAAhcYY6EGAxACv4xPoCNI3f/hL8udP/+3nHcVwCgRAIDsCUOjsQjalw+MrE1okAt1R//aP36VrxxYvvDnEBd6IgibQHQucBYGIBKDQEWHCFAhMRmDz8/eeuHKTfoUV/QJvrU9ITxZjNHx6BKDQpxdz9HimBN549wO5wPv6nYcRe0mqXJbnJ/6POUREC1Mg0EUACt1FB+dAIC8C9x99Ihd4f+cnv4rlPCsTFHqLm63GGlSwE0IACh1CCWVAIBsC+gLvv3n9bhS/odC0ecAcokCFERDYTwAKvZ8RSoBAdgTkAu+v/+D8g4/1cz8P6QorE9bQWEMfMn5Q52ACUOiD0aEiCCRN4Ds/+RVd4P1H3/uPIy/whkJjDZ30WJ+vc1Do+cYWPTt5AtfvPKQLvH/nH9445gLvgxWaPiJQ9V2vZXn+1oOzLK5BYw4nP7AAYCwCUOixSKMdEJiCwNmDD3/nH94oVtsnrtw8+AJvVqZ+u9wh8nyY5RY5P3t2UTy1PuvnYYudzuvV2dspAok2T5IAFPokw45OnxKB+48++aPv/QfdwfuwC7xZmfrpH9UKee2rlEeXv7Y8SM6ZwymNHvR1UgJQ6Enxo3EQGIXABx8//voPzklgDrjAm5Wpt0I//do971+x2jZzjlbcfo6VJRR6lGGHRo4mAIU+GiEMgEAmBP7m9buktX/yL//Z6wLvuAr9tVfuapG2vzDWEmvlc/PsojB/i/WrVr9N5nL5VFFc2pTnpdnTrv6WG6qrRNedtYXNxvWra66w3Fxbct1iea3XhwPmkEm84Wb+BKDQ+ccQPQCBYAJygfdXvvvT8Au8WZm0ju5PN5fLT792r5nZptBFsXj2rFJi+nbZyKpS66ISZvf1syi0JM7LzSVbxcgz123IeecXz55+M4dg3CgIAscRgEIfxw+1QSA3AnKB98Wrt99494MQ91mZ9quyljSqFfKqa3lb0JslibHSXaPKsjg+9wu4BbRdKS+v2QW3K2/bUtag0CEjAGUmIgCFngg8mgWB6QjoC7w3P39vryMHK3Rdeo3AN1bMzRwtn2b5a5fLKnO/Qtf1uF4eCr033CiQDgEodDqxgCcgMB6B+48+WbzwJl3g/e0fv9vdcFyFvvdB7dfPDc1WG9pOXJVCm+u89C436bEUUNWr9TF2ubvDi7PpEoBCpxsbeAYCQxP403/7OanvN3/4y4624iq0t7BuU2i6KMxsU7dcCFa7Ukx+Ay0KXbuOjK8FM7JNf2RwQ8e4Uqwj6jiVAAEodAJBgAsgMB2B1Y/eJgHuuMD7MIWmPW2q2/HqCbb3PXTj7K7vwq8t1ZfTwbV2WWvPZw7TRQstnxgBKPSJBRzdBYEGgRd+dp/u/7XrAm9Wpnbdii2HajUcfhnX5lJ1+Xd4lf4lmUODIDJAYBgCUOhhuMIqCGRFYPv2+194/lax2rZe4M3KlKRCVxdvy3b3gE4yh6xCC2dzJgCFzjl68B0E4hE4e/Dh7//TT+gO3i+dPdCGWZkGFL/YC/FBXGUOmg3SIDAgASj0gHBhGgTyIiAXeBer7ZUb98R5VqZBZC8LbSYnmYOAQQIEhiUAhR6WL6yDQHYE5ALvZ17+BTnPygSF3torz7MLKRzOlQAUOtfIwW8QGI6AXOD91e+/9cHHj6HQWEMPN9hguYMAFLoDDk6BwOkSeOnswRNXbhar7Td/+EtSaLzyJ5XTHRXo+cgEoNAjA0dzIJANge3b79OPpKFMFDNwyGbszsVRKPRcIol+gMBgBKBMhBYcBhtiMNxOAArdzgW5IAACQgDKRCjAQYYEEuMQgEKPwxmtgEDGBKBMFDxwyHgQ5+k6FDrPuMFrEBiRAJSJYIPDiIMOTRkCUGiMAxAAgT0EoEwECBz2DBScjk0ACh2b6Kzt0QyF1ygEMhopUCYKFjhkNGjn4SoUeh5xHKkXUZQJRrKb6KM5bB/LvFif6fF6tl7Y50DrvETT0Tgk2j+4lRwBKHRyIUnZIZ6hTv3uj0feSpoxphzqmm9Nh+lplU8+d5PKUQF9R0y628mFyzdqhqDQNRw4AIE9BKDQewDhtCbAMzUU+igCjFGjTTrtOUzyrFVZ0iTS+lDLdmsnsYZuxYJMEMCVYhgD/QjwTH2UPh25AJ1BdcbYD/6EpT2H5VAnyD2t0C0OqzU0CXPBf8tNS/HUsqS/qTkGf+ZKAGvouUZ2kH7xDAWFPooAYxwkRkMY9RzWy2KR5ItXb1+8elsOdRnnkii0TRRWllXSFUwz5XFI00l4NScCUOg5RXPwvvAMdZQ+zWARfGQXGOPg8YrVgOcwHcqr2YtbbcuyJIWWfEp88flbzg1WaK3K2OV2fJACgToBKHSdB446CdCc6+mT962kN0FLlbcenHkVT/aQmXSyTumk57Acegk6lNWzd2g6BIVOKazwJX0CUOj0Y5SQhzwjuzV0iDw3ax2ozWfPLoqn1meu9QPtlN0Wri1DWjnCGQaSUGS7XfEcFg1+8c0HlKYCUqyZqOyzQtO62f7s6tz+2Io2vLu9mP6s9Gt6V+DBaRCAQp9GnCP1kmcop3CUE/I6jJo6Txr2w4S2Ra07Knac6vDEP8UYI0VleDOBDkuxZqLykRWal9N8nVgBhR4+imghQwJQ6AyDNp3LPPM6ySlW26dfu+f9a2balZar1VDTIU4drKYdFTtO9egCY5wukD1bDnSYiskK2zvs2WaKxQM5pOg6fMqTABQ6z7hN5DXPUE6NmmL89Gv3itX2a6/c1bLdUGgrdZtnzd2kimKxftVqtslcLp8qikub8rw028jV33JDLSqBdGdtYbMUfpX2S+0Nqq4tuW6xvNb4QLCrITLlWqELmowlY8Sz6YrtdHV9ibzgDlbcGONEUezfbKDDVEwKy2H/BhOtIV1L1D+4NTsCUOjZhXTIDvEMtV+htTyTZtdl0qrd4tmzSonp22WTyWJm0pUwu298RRQlcV5uLtkqRp65bkPO/a1sryH+brsypYxXFSVHEudWsJ3bba6SrhsPq88c7AZjHDJUUW0HOkzFsIaOyh7GTpoAFPqkw9+38zxT1xRa5uXuREOhWRfL882SxFjpn1FlWRw3CrgFtF2jLq/ZVawrLyvyHZeVeQ3JclvWyuybEVf6EzHmU2ZJbdPdrhpV5pJzV+jWX1tdvHq77zBLtjyP/2QdhGNzIwCFnltEB+0Pz1A1ha5LrznV2NNu5mjRMstfuwZVmd2yVz9rHGjmNHRR+bmzoZq0O5uvrhdQaPOL5xP/4/F/4hjQ/fEIQKHHYz2DlniG2q/Q9z6o/fq5odlqn9kJoRJO+6Wv2jr2viFW1auFad9dbr0U3rE9vrlUtOzD64oi23pD3nP1hNbQMxjh3V3g8d9dCmdBIBoBKHQ0lKdgiGeo/QqtFqytq2ojxvaiMLOHXCmxt+o1yq13mOtS587y171W1KkCGayu89pxpZjbAPdNyQeF6tKzzy6+sazW0Ga/3fxVF46xWjsLnFPrixisuDHGbIZMdg4PRBYcBgILs7sIQKF3kUF+CwGeoZxC05425Xe8eoLd/Gq2UaDWBJ+9tlRfTnNma8mkMxljC+E0szoie4Kn0owRvJolASj0LMM6VKdYWo7XP39ZGSS3su3Ml1wF1VJra7v+9S4oO74vvS0wxqHCFN1udg5HJ0AGwWEgsDC7iwAUehcZ5LcQ4BmqtyY1pLSnQlfbyLKHfLwDU1pgjC2E08zKzuGBMILDQGBhdhcBKPQuMshvIcAz1JTy1hD7/JxhjC2E08zKzuGBMILDQGBhdhcBKPQuMshvIcAzVH6imJSuM8YWwmlmZefwQBjBYSCwMLuLABR6FxnktxDgGQoKfRQBxthCOM2s7BweCCM4DAQWZncRgELvIoP8FgI8Qx2lT0ktZydxhjG2EE4zKzuHB8IIDgOBhdldBKDQu8ggv4UAzVB4jUKghW+qWVAmigw4pDpCZ+sXFHq2oR2iY5iholDNDmN2DkcJU9MIODSZIGdQAlDoQfHOzThmqCgRzQ5j0+ELl28Uq+2Tz90kIFRAnmpVluUTV24Wq+2FyzeiEEvESJNDIo7BjbkSgELPNbKD9AszVBSs2WH0HCZ5pkxSZUk3D7VsR6E3oRGPw4SeoOkTIQCFPpFAx+kmZqgoHLPD6DkshzpBZLRCt7HaLIvFek03Ny8W6zMqU93t3N6i3ebYYps13Zh9uSnPqqSr4rKK5aatpSHypL9DGIdNEGgSgEI3mSBnJwHMUDvR9DmRHUbPYb0sFkm+ePU2PR+6LEuvvGJjtZgk1SQ9cbXCbFTbFiMBV0mbLZVZ3zdLTql2hknu7tcw7cHqyROAQp/8EOgDADNUH1o7y2aH0XOYDuWVJJl6K4JdrLbX7zy8fufh63ffVyBEg0mGWVutDNu7poss8ykjy420rKltHV/oVXtxkx6HuMZhDQSaBKDQTSbI2UkAM9RONH1OZIfRc1gOvUTroV5w28Vxq9zSyvh8vQhXaG/93ScAh5aVDh5qAPVAoB8BKHQ/XideevoZSu95HhKMc/uFpj+505LMzz3EflCd6TEGuekKeQ6L6L745gO9aC5W21vvPCrL8uPHn1KVYrV976PHzlDrglgWySYMYQpt97tF6pX9YZMeh2Ebg3UQKEsoNEZBDwLNGWrsX90coNC2CqsvFLpHuKVoM+5yqmdC1FjvclNQimKxXAauoctSXSnW+Dq7p0/hxeNxCG8TJU+aABT6pMPft/PeDJXFr27oK04odN9Y6/Je3PWpk0qDw0mFO4XOQqFTiEI2PngzlBzqBHVGb362dI+Wwssl/Zym2tqsXf5jJZXUVV1BZHc3+cIhXV52PFXmYn2mDNBKq7aGVmVNG6ziLf7GzRJccc0OZy07hwdCAQ4DgYXZXQSg0LvIIL+FgDdDyfeRcjVvsdoG/eqGlNPKKsmkSVaCyWJLZaxs0hmTtJm2hE2RqMppZ8s5r8yUZakUWp1QSVdxuJSHcbiGYlnOzuFYHffsgIMHBIdDE4BCD014Vva9GYoO5VV0mn4XK/mU+OLztxwLK4mVFO/Q15pqShmpSKfpxzb8k5s2gSZNl/WxU2htX8w7D4dMEZAhW4hsOzuHI/efzYEDk8D/IxGAQo8Eeh7NeDOUHHoJOpQVtndoUIjQyiU/cuOoliU0Xxa03EjFVjFuFVqtxHoNrfNbKw4XMsE1XBNxLWfncNzuizVwEBRIjEMACj0O55m04s1QosHNX91430N7FauFrRVjp46e6ioVd2Ukk7JkbbxZmztIehYsdVfXHLo1tCpLmWJr8GD5NAZv8NgGsnP42A7vqA8OO8AgeygCUOihyM7SbuAMJcWaiQoLLWBlj1p/ncxraFNSFauyRaFl8V0Z4WqVcptczmIrphWn0HXzpjx5MULgBMsIbUVpIjuHo/S6aQQcmkyQMygBKPSgeOdmPHCGomKywvYODRQttL0gHVyxVysDFw7EOLAXPcxn53CPvvUpCg59aKFsBAJQ6AgQT8dE4AxFxaSwHDpQhwqtXSHz2tiZyywlZJL1+413P/jOT371zR/+cvHCm51Pwki2B4M4ln7gBun2/0AR9zQAACAASURBVGXvXULlOrK00e3iL0oU3bTANGVqpEENTFMDN9TAk8KGf1BJ0wMP3ZPGcKuFJ92qQf5gaOp60rQxFJ0N6osK3Wz5mjbYRgNRprDaA5NqykZCAycHyZKwLacPMj5CKhkd9H4c562ItWNF7NiP3K/YO2LvT4g88VixYsW3dsSXEbkjAkr7QwAM3R/2AdZccoSyKNmKinbXYWhZRq9dBwifMrkkjEq8i7/La3ff+PTGKx998/zxz62DaJbX7npocBegpOoADilIkOAWATC0W3wHpr3kCJW52+rAsQsDQ6N2c0rCWFt/mYJEyYdOff388c/JHvPzwLELL7z35aundxZXbt28/9gHg8s0yrUMcHCNMPRbCIChLUAQLUIAI1QROqXzeoHxzM6dI1vXX/7wyrPvfEYGmJ9Pv3nxxfe/Ykq2mpI2uO557Oa53FYlAUTTOARgNEwMGQEwdMje69x2jFCtQN4NjIsrt2afXHvpg+1MSn7mrUsvvv/Va2evLq7cuvfIvH4qo4mWwdYyOP9QzWIU4E9DIxjaAANBILAJATD0JoSQbyDAQ7CRhmBlBFzAeO/RHlPyM29dYnbkwDNvXXrpg+3ZJ9cWV25VtdgymKNmgHRa++CtiqZqf90Pf3V0PjG2t8XE/YdpNJkv5AWh5gsHegddZxviLMPjKLc3OxupQKBtBMDQbSM6aH0YoVpxbyswEiW/dvbqi+9/9fSbF0mn+fnsO5+9/OGVI1vXa1Cy1UzLYN5Hx+e8lj2PXbwiqF7FX0yZolXQeIFQsDJJJoqowpaBHUUtHDqqFdWMGAEw9IidX73pGKGqY5ZRoh6MN+8//hPXvnp654X3vsx8F+/5458fOvX1ka3rZ3buZNTaIMkymKL8yTzNAco6s3PnzM6ds1fvGjUbdCvYmubEi2lMvGauytYTaDkB73UWbeFgtAtBIOAEATC0E1iHqhQjVCueZRj//T//6y+nx/7in4//1W/+++KNe5byndsPT652N1LyG5/eWF4zWdBS00KUDSZdHLUCmVFzwi232elp8Go+mcxX9Ck1mwwtTn8TdCwYuldaNvDjBhppCAIBhwiAoR2COzzV/o1QiVM8GXCad/kyrrNZKkAw/vt//tcTv/79E3/9i+gnP/v+T3/+o9+cWly5RZQ8OXH5qaPnSYw/9x3eev7456989M3bl75N07nS7eSv5Xcm3fR57Of/eH+9Xj/a+47NvvXQfA3N5GDJvpPpVNA0mS1WueOIJmYj0UnjKii1cKhQEqJAoBYCYOhasI21UHqEqrvrpi0EA2boH/7qqKBn/veTnzGrUWD/kXPPH//81dM7J7642TElW+5J+90SKB+Nz51R355EVIVphj2dTggSnWwudOvU8nW2JtkiDq3ZBEWDRgAMPWj3tt04a4RqsOumLcsCZujv/csi+vMnmaBFYLZkSl7tPmgLo+Z6LL83V8ga+LdomZKcYbOQNwF3OHjTRBjiFwJgaL/84bk11gjFUTNATSjedWOe+mmsSMfzK8FVNFUyJ0+0+mmmCCGjtLp8kjmv1+lWkScJrid+/fvoJz9ja//m7w96e+wa+7eoVTXyjJ+gZWkwdA0QUWTICIChh+zd1ttmjdT8e6T5Eu+BYxfoTWNKNGW0PZKLTc6dLkzWJkEpZFI1M7L6sTJxmyTxu5Q3grpOf0IE48nV7o/+9SRNo//3377w/PHPT3xx0x8jTUssv5tZdcO0+MG/QJMaMHRdOFFuoAiAoQfqWDfNskZqivIn83TmXqAfHz2vjcpiaJ4ex8M20SzPMWliTUJ6YNer3CYrJ2bWulZfQgzjydUuvRG2/8i5ty9964t9KTvY4FTOuBKAw7j87UFrwdAeOCEcE6wRiqNWgKI8e7aiorlZDM3pgpTV0VKaiwmlYTF0KJ5n/4ZisCM7gYMjYKE2DwEwdB4ySM9AwBqhmIPTu24oi+U5ECs1JrxGkDIVe8dzavVr8mIu9uTkM7SRQxNr4x3hjKb0mWSj0actpeoOzuBSraouBByqY4YSjRAAQzeCb2yFS45QLJYOKMRiEhWz5YnYXaN+h6ZFbTVzjknaSDR4WKrSq9xqZq6XxRW3qzq9+cuweGPRBkOCM3hDe+pmA4e6yKFcTQTA0DWBG2exkiMUifEM24qOEzqz1SVhNIv0Gw7OYEdwAQdHwEJtHgJg6DxkkJ6BQMkRisRYmKMZGkeZxMiE0vrgDHYELHBwBCzU5iEAhs5DBukZCJQcoUgMc+gMBGVSSRjzinefHpzBjiACDo6Ahdo8BMDQecggPQOBkiNU5m4rb4/jyGin46SSMDq2ooL64AyWbbN3V4tXEJu9mxAmDhUcDVHfEABD++YRr+3BCNWKe4KDMW1wf+ex27yb75GkpDi/zLylg94sVO8k5msxc9I4mLkIA4HWEQBDtw7pkBVihGrFu8HBaBnc63nsSd4t8kdCMnXTJRi6CDvkeYIAGNoTR4RhhjVSh2G0f1YGB6NlMEfNAMFs7YPPwl5vtFMntIq5bbwArffXxevRtF1ebKETCToWr1en5OMd8+LMm/k0cTqsnC7rk8BTqrJstdK4vVY6okDAEQJgaEfADlMtjVD4bAWBgB4Ri5n4HUA+5zWaLUudx74W9JxcWRZMqVKMWe9iqhIJJ87iQHISHMsLbcTtkruVDk3M2/PEddRKoJwzLBzKFYIUEKiPABi6PnYjLIkRqhWnBwejZTBF+ZN5mgOUdWbnzpmdO2ev3tWgCdqMJ8cq0WBcPSGWx86QoJ7rEpsWymsmTvC3mWyYYKhS1hT/tXAoFkYuEGiOABi6OYYj0oARqhVnBwejZTBHrUBm1JxwyyXoYoZO5mo65bmvQas6V7nFpGKxJM6krk+aS5I/5tAKOvz1EgEwtJdu8dUoHoJ9NTAMu4KD0TKYSTd9Hvv5P95fr9eP9r6jItFseevhnuGVzFVupklzxVsWYpIVZMx0my8vf6gmkhclqAgrie0QNkgZO8OwMzto4ZAthFQg0B4CYOj2sByBJoxQrTg5OBhbNVgvW2fQpOTVeMIrstVrZcZGqbi8wcOGvH6ZjN8US/Mwz70Tqkq4tlUcStQHkdEjAIYe/SNQBQCMUFXQypUNDsbgDM6FvlkGcGiGH0pXRgAMXRmyMRfACNWK94ODMTiDW3FTWglwSGOCFKcIgKGdwjs05RihWvFocDAGZ3ArbkorAQ5pTJDiFAEwtFN4h6a8wxEq/evhcMDsEMZ2QAvO4HaandICHFKQIMEtAmBot/gOTHt6hHJ2PjMY2qNnJ+13j4zr0BTg0CHYqEogAIbGc1ABAWuEcnk+Mxi6gl9ci1p+d12dt/qBg7euGaphYOihetZJu6wRiqNmgCredD6zIOCs05j5xCmDofUOHNph46RpXSpluLqstEldwRncpLEFZYFDATjIcoEAGNoFqoPVaY1QfHKFedxjufOZzbMpRDjmXkHG1sEUBlXbZzWHirMFo//NCM5gR5ACB0fAQm0eAmDoPGSQnoGANUJRlD+ZpzlAWRnnM+sTGdfWSZCLafK8Jz2BNo5rzDAtpCQLRv9ND85gR5ACB0fAQm0eAmDoPGSQnoGANUJx1ApkRs0Jtzz5SZ3dyCc8yQqzGHogi9sMKOPDKZ4HgjPYEZ7AwRGwUJuHABg6DxmkZyBgjVBMutXPZzbWro2zlI35NAuY6+EZJoWYZMHofxP6NpgfhiZQ2UqMH1fKqu0bh7J2Qm4wCIChB+PKLhrS3giVHC71UraaWNvL4PHRy+r36i4a666O9mB0Z2NCc9pgZ7vsEvWqSPJpUanyb0FWQi6xbLOWv60YZ32XVJXGwaoDUSDQLgJg6HbxHLg2jFCtODg4GC2DXe6yywS4gIYLsixVCUm6pjJxWaX5pdAqqqIWDioZf4GAKwTA0K6QHaRejFCtuDU4GC2DOWoGCJkyu+zmK5JlypSBhbgtMoovjJQCamWFb6la65ur6O1/sVAd/7OvulLvLmQpkVdmydUaTdEpVVme5vZmZSINCLSPABi6fUwHrBEjVCvODQ5Gy2B+/8B8ab/0Lrv0DxmSHSlZECqF9M/EkmS5FHkgye425QsmlwVylGhi3p5PWDPrzHWyhUOuHDKAQEsIgKFbAnIcajBCteLn4GC0DKYofzJPc4CyNuyy06vKCWqMX+bXJEozZ8Wjeq5LKUZZNV3Ws+ocJWayKBTPtw1VOW62cMiRQjIQaA0BMHRrUI5BEUaoVrwcHIyWwRy1AplRc8KdfF2LGZEDa7n+LBnTZFHmck2nPPc1yupc5aVMJUKb9Y8o2lClFFh/uYFWOqJAwBECYGhHwA5TLUaoVvwaHIyWwUy61XfZbSemrMaCdjxH1iybtUDNHCrEUnNoSb1qrk2OKlQS+5JNYu25TrZwyJVDBhBoCQEwdEtAjkMNRqhW/BwcjG0azDPY6XRqsKw8pF1MbdUrXvqtMONNMcGm4p+xUSrWR8UEc6t/PDGmEvM5VZfmYf5WkFCV5ek2ccjSjzQgYCEAhrYAQbQIAYxQReiUzgsORscGp0mzNJTdCjrGodvGoLYQEABDh+Alb2zECNWKK4KD0bHBYOhWHisoGSACYOgBOtVdkxyP1O4M90tzcDA6NhgM7dfzCWv8QQAM7Y8vArDE8UjtCAGbAPTrQ44q3KQ2OBiDM3iTB2rmA4eawKFYXQTA0HWRG2W59AjV7fnMJug275p5yXBSUuzAmU71ORXJ7bbJko5iaRgdVdSW2uAMbqvhlh7gYAGCqGsEwNCuER6UfmuE6vx8ZhPMJO+aOXY4IUlbZBMbZXm7rV3QVdyC0VU17ekNzuD2mp7QBBwScCDiHgEwtHuMB1SDNUJx1AxQczedzxyfTUE7Y+S+GMGjcsuNjOltM7RpxjhmQiTwlh21OyclLy+yFOqNvTpUqdwxqyk6pcq9vxgu91W1U0NwBrfT7JQW4JCCBAluEQBDu8V3YNqtEYpPrjCPeyx3PrPY2Jo+XEKlGLPe+IBlBpKzOJBcpnZzIDNX30rAgrEVnU6VkMH4DM5xTp8KKO8AATB0ByAPpwprhLKGbOZpDpBAxvnMfEiExsZgXD0hlnNsmkXruS7xeKG8niIn+NtMNkwwVGl7HIYsGB3W1JJqy9Ejj7YEKtQAgc0IgKE3YwQJRsCiFo5agcyoOeGWS9Dx8rVSbtCkQZ5xrk7p50BmZWQ7fxmfdtT1p2Vx5VY0W7784ZX+TEDNQGDICIChh+zd1ttmUQuTbr3zmdWaNplpMHT6gGXOFFSdmkOn5WUKfQUQJagIK4lxqXAgc7tIWjC2q7xLbc+8dSmaLQ+d+rrLSlEXEBgPAmDo8fi6hZa2Si162VpSaZI/Ja/Se2TypOaeD2RuATtDRaswGnq7DZ744mY0Wz519PzN+4+7rRm1AYGxIACGHounW2nnMKilFSiaKBkGjDSBnn1yrQkUKAsEgEABAmDoAnCQZSMwDGqxW9V5fAAwzj65RhPoe4/2OscPFQKBsSAAhh6Lp1tp5wCopRUcGioJHcZ7j/aeOno+mi3f+PRGQyhQHAgAgQIEwNAF4CDLRiB0arHb01M8dBhpAv3MW5d6wg/VAoGxIACGHounW2ln6NTSCgjNlQQN487th/uPnItmyxNf3GwOBTQAASBQgAAYugAcZNkIBE0tdmP6iwcN46FTX0ez5bPvfNYffqgZCIwFATD0WDzdSjuDppZWEGhFSbgw7tx+SNelLK/dbQUKKAECQKAAATB0ATjIshEIl1rslvQaDxfGlz7YjmbLF977slf8UDkQGAsCYOixeLqVdoZLLa00vy0lgcK4vHaXLMcEuq0nAXqAQDECYOhifJCbQCBQakm0wYNIoDC+8N6XOOPTg8cHJowIATD0iJzdvKl9U0vyZNCa7bGViNNHrVs8amouW6xvGMvaacrRBHrf4a2d2w/NdISBABBwhwAY2h22A9ScphZ6b+jJ356j1pIA36ixXq9pZ86+w1ttwGGTq6GzIMuQEsGkpLiQcjqdmLd4JAWs0m1E0zC2odWtDlyS4RZfaAcCWQiAobNQQVoOAha1ED2brMxhImkzatJ2jvqNyQXcWZBlqU1I0o3R5r3RNoVbpduIWjC2odKtDlyS4RZfaAcCOQiAoXOAQXIWAha1cNQMUDmTobM0mTTJYRlYiNsio/jCSFlU3XM1mc+n8dWT8nZJuvpKLFDra7Li9WpVRK9fqxRTyXqtbpvWFJ1SlWV9wzSGq6GezorjkozOoEZFQMBEAAxtooHwBgQsajGnxUzJB45dOHDsAkdNGUM7s7K57CzZkdabBaHyPdAm7ZrL0VZZzjKUL6YyVf/WLJlaSWpiVlQtTDSKGxa3GLRgbFGzC1VHtq7jkgwXwEInENiIABh6I0QQ0AhY1EJR/lyv18zHJkOf2blzZufO2avmGRcmC3KYA6LGxVQSsybRJHfquS7RrVFWTZf19dI5SsxkUSh+X8xQpZveZsiCsU3VbevCJRltIwp9QKACAmDoCmBB1KIWjlqBzCiTt4TRZEEOc2At15/zGVrTKc99jbI6V3nMpGI9RdYkH3N5TNGGKqWg3b+MT7tqXWjDJRkuUIVOIFASATB0SaAgJhCwqIVJ93eXd81JczRbnv/j/fV6/WjvOyoSzZa3HpoXCW8npqzGgna8AK1ZNmuBmjlUiKXm0PJnabWQTY4rVBL7lk1i7a6cbsHoqprGem/ef0y3TOKSjMZYQgEQqIMAGLoOaqMt0ya18Ax2OlXvfwlqnE7pRTG15Exr23KSa7zkJdhU/DM2SsX6aKVaMLf6RymqOlaS5mH+VpBQ5cDZbcLowDxWiUsyGAoEgEAvCIChe4E91EodU0uaNEMFqthuxzAWV142F5dklEUKckDAGQJgaGfQDlGxY2oBQ3v00NAEGpdkeOQSmDI+BMDQ4/N5gxaDoRuAp4s6hlFXVDuESzJqQ4eCQKBFBMDQLYI5fFX+U0sQPvAfRlySEcSDBCMHjwAYevAubrOB/lNLm611pstzGG/ef7zv8BYuyXDmfygGAmURAEOXRQpy6d1WwKQeAp4z9Buf3ohmy+ePf16vdSgFBIBAWwiAodtCchR6PKeWUHzgOYwvvv9VNFse2boeCp6wEwgMFQEw9FA966RdRC34bAUBJx5qrPTeoz26sgz3QDfGEgqAQFMEwNBNERxV+VaYCUoIgTM7d27ef+zb83NyJY6He/adz0zD4LKhImB6GWEPEQBDe+gUmDR8BE58cfN/vfT6D3919C/++fhf/ea/L96450mbX/pgO5otXzt71bRnqPyEdpleRthDBMDQHjoFJg0fgf/7//n/nvj175/4619EP/nZ93/68x/95pQnJL3/yLlotrSMISZbr7fxfzAIKJ8Ov68F3UIwdNDug/GhIvDDXx0V9Kz+ff+nP7cWlntp2OLKrWi2fPrNi1btajQHQw8HAeVTy9WI+oUAGNovf8CakSDwvX9ZRH/+pCLo6Ac/+AFfFNYjAnTS5ysffWPZoEbz4fDTYKbCtRuifGq5GlG/EABD++UPWDMSBH70ryejn/yMGfp7k3/48dHzvbf9wLEL0Wx5ZueOZYkazcHQw0FA+dRyNaJ+IQCG9ssfsGYkCJxc7QqSltNosdw9Wz519Hy/G5zoLO6nsr4oqNF8OPxUe+o5mILKpyPpcKE2Ewwdqudgd+gInFztPnX0fDRb7j9yjiavz77z2b1He32169XTO9Fs+fKHV9IGqNE8JIamXd1ked7ner395e5qMKRbqSHKp2lvI8UjBMDQHjkDpowWgdXuA2LrF9//qi8QnnnrUjRbnlztpg1Qo3kwDF2GnoNrVCUC3iismp/2NlI8QgAM7ZEzYMqYEVheu0u8kn5RqwNYVrsPaDafOYlXo3kwDE0Gl/ncyGRDFVA+7eDhQhX1EQBD18cOJYFAuwic+OImjZtvX/q2Xc0btc0+uRbNlnkzeDWah8TQvzx93fofzZbplKES8MZ2KZ9ufDQg0CcCYOg+0UfdQMBC4LWzV6PZct/hrcWVW1aW0+jzxz+PZsu8bwZqNA+eof/uD1dNkpY73MxGvTuNnpuvKIXDH88n8Uv304XMWr2uEg4uxCkuQnI6fS6KKGoq9DesfOr0sYLypgiAoZsiiPJAoF0E6NzN/UfOrXYftKs5T9vN+4/pa0HmErdx66i/fGNNGdPT5V+evp5OLMXQi4PR9F1DPzP39npxcDL/WDJ0JAPB4LNei7NdfdiCn/dMIp0QAEPjSQACfiFw79EezWiffvNiN1dr0IXQkxOX84BQo3kwDEQGl/k0qDeeDdtzaDlj1gSsJ9ByYi3I2+DscA5GVT7N8znSvUAADO2FG2AEEDARuHn/Me2/mpy4nDevNeUbhicnLkez5Ruf3sjTo0bzkBg6Sb3C8tSMOZ1icq0Z3l7Nn4uiSKxyC4a2VrMTkul6/UxRPs3zOdK9QAAM7YUbYAQQsBBY7T6gSywyNyhbwk2iZS6EVqN58Ax9/V5i93OKs8VPzvGPzYuDkf5NWjR8NX8uZ00bDN3kAUTZIgTA0EXoIA8I9IjA4sot2n81++SaOzPevvRtNFs+f/zzgioGw9DWdDbF0OKnZfVW2MH4rTFO4amzudCNVe6C5wZZjREAQzeGEAqAgDME6BfiaLY88cVNR5VkXght1RUcQ/ObUGR53qdF2KOKKp9arkbULwTA0H75A9YAAQuBVz76hl60Xl67a2U1j957tEdr6cXvjavRPJhV7lFxbb3GKp82f4igwSECYGiH4EI1EGgFgRfe+zKaLQ8cu1DMozXqyrsQ2lKlRnMw9HAQUD61XI2oXwiAof3yB6wBAmkE7j3ao0Ozn3nrUruvdr/84ZU//Rb76umddKVmihrNh8NP9eadQyqlfGr6GWHvEABDe+cSGAQE0gjs3H5I+69eeO/LdG7tlLwLoS2FajQHQw8HAeVTy9WI+oUAGNovf8AaIJCHQOtXa5zZuUOL53k1croazYfDT0OaDddri/IpOxkBHxEAQ/voFdgEBDIROLnapYH1yNb1TIFKiQUXQlt61GgOhh4OAsqnlqsR9QsBMLRf/oA1QKAYAbqEqpWrNZ5+82I0W5a5ooNGc3wOD4Hihw25vSMAhu7dBTAACFRDgF7v2n/k3MUb96qVNKT5QmgjLTeI+VYuNMFmwKdBuA4MHYSbYCQQSCBAJ2kfOHah9tUadM3lSx9sJ/TmRDCa5wATcDJ8GoTzwNBBuAlGAoEEAjfvP6Y16uePf15v/9Wz73xW/qgyjOYJ9AcRgU+DcCMYOgg3wUggYCPAV2u8+P5Xdt6m+M7th8UXQlsKMJpbgAwgCp8G4UQwdBBugpFAIAOBMzt36GqN185ezcjOTzqydT2aLctvrcZono9lqDnwaRCeA0MH4SYYCQSyEaCbqcqvV5OWjRdCW5VhNLcAGUAUPg3CiWDoINzki5HUq/HZBIHWfUnbmvcd3jqzc6eM8pv3H9PMu/xbZhjNywAblgx8GoS/wNBBuMkXI5swE8q6GxNffP+raLZ86uj5MldrlLkQ2nrgWrN8MY2iaDJfmfpX80kURdOFmYawcwRa86lzS0ddARh61O6v2njVq4dzslK9ExPrlVLoVUV9s/y9R3v0bvYzb13aODMmOp99cm2zXiWRtpxm4U/+9hyJkMCfLuFQJdZ0qeW+w1ucIgJg6AQcfUbSPu3TGtSdgwAYOgcYJGchoHo1GLoOAgq9LGQbp928/5iuwZicuFygrOSF0JYGy3KiZ0okVuZwOmrStqWWophDZ8LiOtHyqevqoL8eAmDoeriNtJTq1XX4qd68c0ilFHquHp6LN+7RzPXQqa/z6qCTvZ9561KeQGa6ZTlHzQAVNBk6Q5UxhyZijtQ/rHJnwOUyiX3nshLobooAGLopgqMqr3o1GLoOAgo9h48MX62Rt4hd8kJoy0TLcnNazJR84NgFmsSv12tLXmtjhpYB+vHZCGpBhFwjkOsj1xVDfxUEwNBV0Bq9rOrVdfhpSLPhem1R6Ll9jGivczRbnlztpmt66uj5aLaseqC3ZTlF+ZMoeb1eE0NzOgV+fPS8NkMxtMnKWOXW+HQYIu90WCGqqoMAGLoOaqMto3p1EUNbP1Ja4zVr+HJ3VY/nwi2l2u788Tl06utotkxfrVH+QmjLRMtyjloBivIM24oKnWBoC9n+ouy7/kxAzZsRAENvxggSjIDq1bkMXYaeNyopx8HvTqPn5qtcS4SS1euTDJkSBdc5arMV5ginlKiGM5wOA3y1xs7th1zNKx99E82Wr3z0DaeUDFiWMwf/7rK4r5qXtVksHYgrUgxN82a57WpbbrbCbquSrmhNjH3UmkYocoAAGNoBqMNVqXp1LieRQJnPcjRsVWSSqxm2xIqjVQtmymcmFte7rdDr4vm492jvmbcuRbPls+98xldr0Cp0mQuhLRNLWs5i6UCsUDG0mk6r98SwH9pC3H2UfeS+KtRQHwEwdH3sRlhS9epcKopmy1+evm79TyfKiVeuknzyNnnRDFdSVbVgpnxm4gYzFHodPTir3Qf0qzNdrXHxxj061aRG9SUtJzGeYVvRGvWiiDsESvrUnQHQXAYBMHQZlCATI6B6dS4Vpcn4l6fFJQ1/94erJm2nGZpeHRJTqum7kqFNCqTwu+I8KvonZGTi4nVxHpU4purjLF43lIgFapJ8XS+Pq8QoOrgQi9JSfn5QCpLOrEpXRuKhf5tPoulCAbI4GE1eX6XWt8k2hV53j9Py2l363eFPK9t0OGjJC6EtE0taTmIszFFLG6I+IMBu8sEY2JCHABg6DxmkZyCgerUipBQV5TG0Sc/E2VmEqjhS/LpskKsOW4lRTIeLg4piLcNYXnAq8ehq/lwU/zjNudvrxUHJ8ZJ66SuC1mmIZVqyOKi+VWwvpgZbZ4HD88sMcN0knfjiJnmN7pPOfMF7Y83K7xsEcKyPBgAAIABJREFUSYzbaEU3FEZ2twiU9Gm3RqE2GwEwtI0I4gUIqF5tEaGO8qC8MWAztGBE+kfvf23iRU2WFp1rYzTNr16f6Kmt0qwn0LJenpfHb58pseyKOJdqV1NwXYtpRhxW6BUA7CTrtbNXqep9h7f4N+lKNZW0PHO31YFjFyrVBeFuECjp026MQS15CICh85BBegYCqldn0A8v5NrUuxZvSFmJdoogSyK5j+eTLhmaKuXmWLxb0pLt1fy5yfxj+rRaakYVehnAuk6iU7v3Hd4qc7VG2pgeLU8bg5RWEIBPW4HRtRIwtGuEB6Vf9WqmNDtgU69c6Y1my+v3ErufbTH++VZQNfHix/r3XTG9LiDLEnNoMQ/OXOW2fsCuydBiW9fk4DT+bmFjwiSt0OvhkXj++OdU+9NvXtx4tUbavh4tTxuDlFYQgE9bgdG1EjC0a4QHpV/16iISYkLigM3HGbNqwcdRFH1v8g+a53jde3qQ3+2KXyjLXZG2DDMYV2mbzDPfFKM31Ax5Y3E7s1IjUVQqovQDdurnZxMHCUXXjwRdCL3v8BatQk9OXK661q383rXlqM8dAvCpO2xb1AyGbhHM4atSvdoiwkSUZIo/mbQGEyh+R4yaqdDr+jl549Mb0Wz5/PHPV7sP6GqNlz+8UsmIYm8iN1wEKj0GEO4eATB095gHXKPimAQle8OyxiYoMSG3fmN2aXPiTbTcihR6XT8AdCH0ka3r4pyQK7do/1Xe1RqZxvVleaYxSGwFAfi0FRhdKwFDu0Z4UPpVr84lIW/YujMLaX2efibfUKlCr9NH4t6jPaJkPv6TptTRbHnii5slTenF8pK2QaweAvBpPdw6LgWG7hjwsKtTvXoDFY2Pp0sBotDr9Bmg+yiffeczs1Y6oHvf4a3ltbtmel64F8vzjEF6KwjAp63A6FoJGNo1woPSr3p1KUICT1sIKPQ6fSRe+kDsdnvt7FWr1hfe+zKaLQ8cu1Bm/1UvllsGI9ouAvBpu3g60gaGdgTsMNWqXg2GroOAQq/TZ4NeDUtfCM1Xazzz1qWNr3b3YnmnMI2vMvg0CJ+DoYNwky9Gql5dh5+sCeUIowq97ry5uHIrmi2ffvNiZpU7tx/S/qsX3vsyU4ATu7ecq0bAEQLwqSNg21ULhm4Xz4Fro16NzyYIdPmIHDr1dfGF0ObVGgWGYTQvACfQLPg0CMeBoYNwky9Golc38UT36NEU+czOnQKz6VWyaLak7ViZkt1bnmlGnLiaT6LJfEV3TFOgSBx5mQj45dNME5G4XoOh8RRUQAC9ugJYKdGO0Vteu1vyQujZJ9ei2XLf4a3FlVspq0VC2nLawfXkb8+RPAmYJ6bR79/7Dm9lKmwpcTGNqbolfWNSk/bpmFofTFvB0MG4ygdD0aubeKFj9OhC6JLHh7384ZVottx/5Fz6nbI0QxM9m6zMYSJpM2rSdhP0ssqCobNQKZfW8dNYzihI2QiAoW1EEC9AAL26AJyNWR2j98xbl6LZsvyF0JMTl2n/VfpqDctyjpoBar7J0NmAiDVq+jddCAnJsos4cbpYcz6vX8dHoEfi8hOpk4mZA9lVIbUAAfZdgQyyekcADN27C0IyAL26ibe6RG+1+4DmxBt3UnGLbt5//PSbF+kEb6uUZbk5LWZKPnDsAv3snZ5zcxUxH4ufkEVQcrDkX/5ZOVLL1vIqEiJkVZz5OB1QIvhbGgHLp6XLQbBTBMDQncIdemXo1U082CV69NPyi+9/VclgvlrDKmhZTlH+JEqmipiwo9nyzM6dMzt3zl41ji3jCbKeRTPdqvk08TfNrRWXx7Nu+wUxs2ylhkI4490CgOIhAmBoD53ir0nWSO2voV5a1iV6dCH025e+rYrEmZ079DOzeQyZZTlHrUBm1JxwyyXseKlaGWaybFZYkDoV2Z5PeK5tBZQy/C2NADurdAkI9oAAGLoH0MOt0tNebSyUMrY0W7PYgHNTgW35Q6gtXlFJSmsyoTP0bt5/TO9mW4vVSXNyY29f+pZM5as1LMuZdH93edecNEez5fk/3l+v14/2vqMi0Wx56+GeUZNwFbGrSsxiZZGn0tVfye4WMXOeUoa/pRGwfFq6HAQ7RQAM3SncoVeW7tVe7LoBQycfLLq9anLicjK5QozeA993eIv2Uqf9XkGXJWoudItvRCbLZobpy1MUTaZTzKEtMBtE2/RpAzNQtBgBMHQxPshNIGD1am923SSMpEjF6e+g5tD0VvYbn97IwKV0Et0q/dTR8/TSGc+bSyuAoNcIWH3Za1tHbBwYesTOr950q1dz1AyQVnPxM6MemvVOp/HGG1q8NGdX9NOjFKO3hKQI8ahaJSX5yXxlzKETOnh7jpmaXRdJxKvcprje45PRjGpJjFK1YhWl0xdCV1QQi997tPfsO59FsyVtlQZD14PR21LdPI3eNj8Uw8DQoXjKCzutXm2O2kzJpXbdEPVKsiQ6FMGYGBUBk4wkTc2fKTKOF0rp102jiB0k8mVFVl1rYw5tl1S7cBt7wEKvsb5sBfQr8vPHP8/OrpJ68/7jQ6e+vvdorxvLq5gG2aYIwKdNEeykPBi6E5iHUonVqynKn7zrhvbFcjoFfnz0vIbBINqYmPmsigyCXmsZ8bMlsTGTrfwpU6YZ3GqXUNt15N9UXWuDobOVaNPrhwiH+uXLlcy7ELpc6WypbizPrhupbhCAT93g2rJWMHTLgA5bndWrOWoFKMozbCsqIGKeXRvsS5y7gaFVUTqFimbGSlsmuSa1Kv/YqXoOnalEFWv0l1FqpKWw8L1He3Qg9mr3QaFgtcwOLK9mEKQbIwCfNoawCwVg6C5QHkwdVq9mDk7vuuFFbysQQ0E0KMlYz4Ut1lS8a5K4KC7FJpOJ3rajJA0FxLhygZpSea16MRfXIhmi0iTN0EaOoaQNF1rotaHS1lF8IbQtXTregeWlbYFgOwjAp+3g6FgLGNoxwMNSX7JXs1g6EONBDM1Lz+aPxGoOLSQNMSM5Jk69r1YxdLKE0E6KYz6OqzO+F2ilmqFzlTR2JaPRWFOuAnqr69XTO7kStTI6sLyWXShUHwH4tD52HZYEQ3cIdvhVlezVJMYzbCsqYDA4NXxUyragJHpl1WXJlbkQOqvchrQOLN9gAbLbRgA+bRtRJ/rA0E5gHarSkr2axFiYoxoWMLTGorXQmZ07dDlVaxqVInalSsDf4BGAT4NwIRg6CDf5YmTJXm1RshUVjQFDO3BppQuhK9Vf0u+VdEK4XwTg037xL1k7GLokUBATCJTs1Zm7rQ4cuzByEEuiVxslujtyceVWbQ15Bdu0XH45E+8QiFfy9IsAeVUb6bJk/GYBJZunhBqCCJZAoE2flqgOIvUQAEPXw22kpdCrmzjeKXp8IXQTC/PKpi2vex67YNkEyeZVGaebHCzCE3XRlcw3czcoQraFQNqnlgCiPiAAhvbBC8HYgF7dxFVO0Xvt7NVotnzpg+0mFuaVtSxvcB57VU415WV4oa6gFLaauXm2Iz0bAcun2UJI7RsBMHTfHgiqfvTqJu5yih6doc33RTaxM13WspyjZoBKZW9/VxrFeXDyn1zdZn4VAXlGOx/2JoSmC1oQlwXEvDuW52Kcol5sYElF3nSsjZy1x7vi9SZ6tSeeqlIWjucv+248TQ6xpWDoEL3Wm83o1U2gd4fezu2HTS6E3tgoy3LeR8fnvNI75PT+QeH7Cga9Ksal9wbjX6QX0+QieJ48iZu51AhOkezOUkzMepWdJUX9ce0bgRiQgOXTAbVsUE0BQw/Kna4bg17dBGF36B3Zuh7Nli+892UT8wrKWpZTlD+ZpzlAWWd27pzZuXP26l1Ds8GLCYZWFCmnuiqipsIrUmCUjYk8mSKn0IqLjSxdkaGQ59RUqspv40ZzAg5aPg24JYM2HQw9aPe23Tj06iaIukOvlQuhC5pmWc5RK5AZNSfc5rq0ETbZVFhB7ClJ08wyw+IMOLkMLtlcFCCO3VY/U5vCWWFdpKDdQ85iZw25keG3DQwdvg87bIGnvdpY0WQwjFGe0/IC6hjReBIm/xjzuLxiVdMdoXfz/mN6devm/cdVTSopb1nOpJs+j/38H++v1+tHe99RkWi2vPVwz6gliywTc9xYdhUzbaa8lCEH034tlhKJ5DlOMubNohyni4fGgZONtvodtHzqt7HjtQ4MPV7f12h5ulfX3XVTo/L8Ik0ZOtZMY767UTuNXn6TKuS0eCF0Xq3tWc4EaZGlQl26Un5Fited4wQRM8sKS6W/qKD6jiVeOKMUUzgnHHO8WVseAANMb8+nAwTHnyaBof3xRQCWWL26wa4b542l4Tce5svVFihDv/j+V9FsOfvkWrlW1pGy/F5HBcp4hgB86plDss0BQ2fjgtRMBKxezVEzQAWLd92I6VAU77ARUxia9phzGvpZUc+oSISmSmq+xYxK2sSlkslbrPhwDFNzXl2qrMw3K1LaM222qlSmlUEvU6ZqoqMLoS0z2L9WOqLhIgCfBuE7MHQQbvLFSKtX8++R5ku8B45d2LzrhqhX8hnzrGJXxXIkI2fBJBOvdCYJPZFoFLGDNJtmRTFnq7okwNoSk61lqpDLtJlSLeU57rLQy5GqlnxytRvNls+8dalasYrSLiyvaALEW0YAPm0ZUDfqwNBucB2oVqtXU5Q/maczz+X+8dHzGhXJdjE9WqypSNOgWEWYCTbmYvIHSknbZhGdTany18b4gw/GUHWRYVTEskomyrRMmzOV63YmQhZ6iby6EUcXQlvmuLDcqgLRjhGATzsGvF51YOh6uI20lNWrOWoFKMozbCsqsMtkuwRDxlNWmp1a+28EHdNxUZSttBFdWhPapFbluKzUZBotdE+n/MqvqkWoINHpIllEKc/5yyjl5NdJfuro+Wi2vHjjXp3Cpcu4sLx05RB0ggB86gTWtpWCodtGdND6rF7NHJzedWP9Dm0VTK8YC1q16M5gREWIElwZEVco8GYZJWkoiF/u1Wr5qKrFXPxgbYiyx6w0ivKv5EU2W8pZYzJgg5DMrRFzdyG0ZUzrllv6Ee0eAfi0e8xr1AiGrgHaeIuU7NUslg7E2NFsl1eezWmvufJsiBnJMfsyQZszcqOE0E6KYz6Oq5OaLDaWZtlpMUWrmrNVK7I3lec8IIxGTn7l5Fc++iaaLV/56JvKJSsWaN3yivVDvH0E4NP2MXWgEQztANThqizZq0mMZ9hWVMAj2U5Rn7d4ya8CbGVjm0uiVx4O+r3fxYXQlg2tW27pR7R7BODT7jGvUSMYugZo4y1SsleTGAtzVAPXmO20KnchOYdmgm7+rYIBacXkizfuRbPlU+b7d63ozVLSruVZNSCtawTg064Rr1UfGLoWbGMtVLJXk1jQc+h4STteJZf+bvytoiR6JR+uV0/vuLsQ2rKhXcst5Yj2ggB82gvsVSsFQ1dFbNTyJXt15m6rA8cujBq79bokeiVRoguhT652S8o3EWvPcvMAzvIWyS9H5rclsaChVzfKK4IkI9CeT1klAu0jAIZuH9MBa0SvbuLcFtFb7T5weiG01cy05XXPYy/PrKakCE/U9VXSNjPXMhbRUgikfVqqGIS6RQAM3S3egdeGXt3EgS2iRxdCv/j+V03sKV/WsrzBeezlmdWUlOGFulhS2G3mlm8HJDUClk91BkI+IQCG9skb3tuCXt3ERS2i9/zxz6PZ8o1PbzSxp3xZy3KOmgHSZu2DT1WhmTX+pV9viVOb6MQeOZ0pN8zFpXRhg6G1aLwMLqXoQBu53S7eNKe3z5sb5BJL5ylrh5zAvhtyI8NvGxg6fB922ALq1fhsgkBzd9GF0PsOb7m7ENoy0hrN+R1APuc1mi1LncduMKuqQtHuYqp2r1OOShcxDqcDSk1CRrGxZO/492oRJj5mJULxaH/NtnzKOCLgFQJgaK/c4bsx6NVNPNQWem98eiOaLZ8//nkTYyqVtSynKH8yT3OAss7s3Dmzc+fs1btGXQl2VCfWSJa09rZpxjUZWpK14Nl8PWZWZpjn1FT9WGfRlk8NHyHoEQJgaI+c4b8p6NVNfNQWenQh9JGt602MqVTWspyjViAzak64NbMKmiRu3DZ/Xib2lBkGByeIViyGy2Vw5nVLT15Bla6rroTB0ITZWUNr2LDaA4Yelj8dtwa9ugnAraB379Eevai1c/thE2MqlbUsZ9JNn8d+/o/31+v1o73vqEg0W956uGfUpWhS/ZUHsiZWmlcxY7NEcg7N15bQbiuWErxLejjJKsjpYr07UaVh33iClk/H0/CwWgqGDstfPVuLXt3EAa2gRxdCP/vOZ00sqVq2FctlpUyT6r2wyXQ6kXSZ9caXWIcWM2QuFRsup9pEsik9CWGzoBGmqTpWuWfLqk8C5DtGAAzdMeBhV9feSB02DvWsbwW9lz7YjmbL185erWdDvVKtWF6vapRyhAB86gjYdtWCodvFc+Da0KubOLgV9PYfOdfBhdBWM1ux3NKJaL8IwKf94l+ydjB0SaAgJhBAr27yHDRHb3HlVjRbPv3mxSZm1Cjb3PIalaKIUwTgU6fwtqUcDN0WkqPQ41OvtvfPSgcYvzX655Dm6B069XU3F0Jb4DW33FKIaO8IwKe9u6CMAWDoMihBJkYg3avrns/cHNIxMjRdSXJm505z+CppSPu9UnEIe4gAfOqhU9ImgaHTmCAlFwGrVzc4nzm3itIZo2Po5bW7nV0IbXnB8ruVi2iICMCnQXgNDB2Em3wx0urVHDUDZGv585mNvTRq54w6nlFuljX3xIhF7Ol0IvNP6VMi1eaZyXzu86WEjFI9d9KF0C9/eKVe8SalGlrepGqUdYQAfOoI2HbVgqHbxXPg2qxezSdXmMc9Vj+fWf14bM+KVbo8eYL3zKqzJlhaH7hsbJP10REWelVNfOatS9Fs2c2F0JZtDS23tCHqAwLwqQ9e2GgDGHojRBDQCFi9mqL8yTzNAcracD4zHzFhEayaGdMkOnVyhWJodQaVtNIgdW21LyELvUpm0YXQ+4+cu/fIPKKrko76wk0sr18rSrpEAD51iW5rusHQrUE5BkVWr+aoFciMmhNuY2XbOpoxXtgWB0kJhqYjlxlak4ADZuh//8//+svpsb/45+N/9Zv/vnjjHjevIDD75Fo0W770wXaBjLssdqi7KqC5YwTg044Br1cdGLoebiMtZfVqJt3q5zPT/QcSxtQxyWpWnMrg2bYopxhaBGImtybhvjmJ0PvF/3nniV///om//kX0k599/6c//9FvTpUhaboQ+u1L3/bSKMvvvdjgoFLzC58D9X6rHKhP/Qa9unVg6OqYjbhEm71aEKv8N53Gr3dxCk+dzYVu+3xmZmhJ1lJTEG+KRYf+TdCz+vf9n/584yHbO7cfRrPlvsNbvSxxZ55U098uuxa7Hxga53K3+Dg5UQWGdgLrUJW2ydBDxSi/XYTe9/5lEf35k4qgox/84Ae8FJFXlC6Enpy4nCfgOt3ye6+77FpsKxgaDN3i4+REFRjaCaxDVWqN1ENtpqN2EXo/+teT0U9+xgz9N39/8MCxC1TjavfBG5/euHn/sWXA5MTlaLZ849MbVnpnUcvvHDUDZAx92+D0lIWSFBfziWy/ei1f/lBBiMQvHlj77hLR5OKJ0rGaT6isse6i3mIQlapNevR+g6jM8xWXFHQtJ+T7qOWKoK4JAmDoJuiNrix6dROXE3onV7uCpOU0+n//7QvPH//8xBc3SS3teI5myxfe+5KpupcLoa1mWn43J/1MyaV32anLmQWVKn6N61OTWoOERU5edDGdTOjqSvFaodSlX0qQbxqSfpGoatICnr+1YLmg9ajl09b1Q2ErCIChW4FxLErQq5t4mtE7udp96uj5aLbcf+Sc+fLX25e+pTfCSJKumHz70rfRbPn88c+bVN2wLFtOeijKn7y5jgOUtWmXncG8+hUEyaQWeaajMRtP5gtiZkXQQlLNnDWzK+Jfywm04mqZryMNIQquuOXT4OwficFg6JE4up1molc3wbEkeju3Hx7Zuv788c9Xuw/W6zVfCL28dteTN8W4IVYgM2pOuJOkqN7n17S6Hc+EJcqSlzXfGlES+5+poNfVfPJPC0XQ1g49NfcGQ2c8tuysjDwkeYMAGNobV4RgCHp1Ey/VQO/eoz2+EPqpo+f3Hd566YNtXhVvYkylspblTLrVd9kZC85MzEygIiUxqWXmJWs5KgLG+vZ0+o+qmF7ENtiaK6AV8zD25lVyUA1hy6c1NKBIBwiAoTsAeThVoFc38WUN9PhC6J3bD+nUT1LCL5c1sad82RqW5ygXZClf2hLvaqn1aPUimMiRVKsXvaWIFaXFauZyi9dprk2vgq3ICpOh5TRevpWGN8X4m1aOs5DcPwJg6P59EJAF7Y3UATW6NVNroPfyh1f+NIy+enqHjFjtPph9cu2Zty5Zh4ulX/9uzWipqIblOQYkyTJHCMkdINCeTzswdrxVgKHH6/saLUevrgEaF6mBXskLoY9sXd9/5NxLH2wvrtzi6loM1LA8p3YwdA4wnSe359POTR9ThWDoMXm7cVvRq5tAWBW9Mzt3otmyzII2vU1G+p86er71H6qrWp6PEhg6H5tuc9rzabd2j6w2MPTIHN6suWH2apsVjLeJmsFRsXRV9Gh79KFTX5ep50+He796eufpNy9Gs+WZnTtlipSXqWp5ec2Q7AsB+LQv5CvVC4auBNfYhdO9ur/zmW3ezfdNUlK8B6zeSIrLJAXyFTXMSaNXrJDoturCdfoejsmJy4dOfb28dre4uoLcqpYXqEKWJwjAp544otgMMHQxPshNIGD16l7PZy5PqwlJ2rHD+3Zk8xICiQa3GrHQK9Z98cY9OtKkWGxjLi2VU9UHjl145aNvNhZJC1SyPF0cKR4iAJ966JS0SWDoNCZIyUXA6tUcNQNUmDZycHqWRrXHJt51I2gyfXgyb8lJ7rjRMXNzq9xEo7bwqF03yU016kwMTdEpVVm2tpJWiIZdw2tnr7Z1IfTiyq2XP7xCp5iVvH7jjU9vvPDel3xASiXL7ZYg7iUC8KmXbrGNAkPbiCBegIDVq839lEzJ5c5nFvSsTpmgCgVTqhRjUruQJ0dpmziLA3QMhS7KO2qJqyVTq1xNzIqqhWZTla6p9ZCFXrH+Z9/5LJot233na3HllvUT9cnV7qund8yF8Tc+vXHg2IWXPth+6YPt2SfXyMhKlhe3C7meIACfeuKIYjPA0MX4IDeBgNWrKcqffCwzBygr43xmQZtqshvXYNCkmv7KObGaReu5LtFtobxm4gQBm8mGCYaqRHNbjljoFWjv7ELoF9//iqx65q1LL77/1Y+Pnn/pg206bXTn9sMDxy7QNLq85QWNQpZXCMCnXrkjzxgwdB4ySM9AwOrVHLUCmVFzwm2cyMi1GDRpkGecrVN47rtJXk2bjSmyJvmY++NvCYYqNsdBgGHZqPvI1nW64WqjZEMBcwH8z/5jy5phHzr1NU2jy1ve0B4U7wwB+LQzqJtUBIZugt7oylq9mkm3+vnMmavcTKrmircEmTlUUHVqDi3vF+bCqoD5C7XMZCWx34QN6lTJZGk3jrXQK6ik+wuhX3jvSz65jA3jaXR5y7mslwH1BOinqIqZ9UrJGsQDba0ZVanZhexQfOoCG490gqE9cob/prTaq/WMNoMmxWio/ols9VqZsVEqLk8Dny2fcfyyGp41zKKQqltURqp0fsuhkujdvP+YXpJ3fZan2TwmYzNxvV4fOvX1oVNfpy3vb5edZWClaPoR2Fi8RpGUTvHjirXBLyXTeULap52bgAo3IwCG3owRJBgB9GqGokagJHp9XQjNa9pm0147e5W2ZfN6yXq97nWXnWld1XANuq1RxLaK3n4w34GwJfqIl3wa+zANdWoEwNAaC4Q2IoBevRGiAoGS6NHbW/wedYHCdrOsaTS/1L3afWBZzlEzQMbwK/0moxt2SsJbxAsk+qcFvQRC6xhCTG29s/PkSwzx+opa9ZBq51NKZbXWKk3yjQQhpVWrFZRkER2T6ysGWxsli22Qyz/SogRFZxqsForkao663DrxqqOwmOrTBpRAzHAAB9l3nIKAhwiAoT10ir8moVc38U0Z9PhCaHqhukl1NcrSNNrkZlJiWW6yL1NyuV12kvOIQgXHUMhgvnhznRCjPPGOgeJAaYzIihMSGlSqka8QYP3pAInYdaS5XFXNBpe2QRMzv+RIpJsy2LKCo4upeRm2tIAbIixVKXmIKRiSfy2fJjMR8wUBMLQvngjCDvTqJm4qg97J1W40Wz77zmdNKqpdduf2Q7ojy/p+YFlOUf7kzXUcoKyMXXbJrecxB+npoJwDC/o1GEjmxmwd3wytGVuxmCFvlpXfB6RSZlYrIKBSSiRsuUWMuawwqawNmqDX5g6GLIPTLY25dzJfzOXF2UpZJcRyngbLpzlSSO4ZATB0zw4Iq3r06ib+KoOedSF0k+paLGtZzlErkBk1J9wJ6pVv/wmiSxKeNNskMJFAlJQWVuRqyquwVsuTV5VlsTizbVGRegytCT9el4+pnS0x1MqW65YKfCbz1f/IOfJqPvmnhSLoaojlPAfsrJx8JHuBABjaCzeEYgR6dRNPlUGPzuY0D/lqUmNbZS3LmXSr77ITjBVPiDUdGomxxSaBxUmKnoRwTKkJDbFW/SWAdQgxa+rMeYriqRJOzihiUml1G+JGZG7w41qtlgoiNte3p9N/VI2shFis1vpj+dTKRdQTBMDQnjgiDDPQq5v4aSN6iyu3Sl4I3cSMGmU3Wl5ap2Aj+QqYmFLy3DWeI9M0U6QapCXISGeIigR90j9FWKa8DqsXr/ROJ1YbB7TuiL44KNW6iFAn/llWKUH+vpGwWdnA9TE+opylSgmrmgxghLRqoxlOgJCyTbdKA8wGcKA9n7JKBNpHAAzdPqYD1ohe3cS5G9F75aM2sMgKAAAgAElEQVRvotmy3vVTTQzbWHaj5Rs1KIE0Z6kc/O0WgfZ82q3dI6sNDD0yhzdrLnp1E/w2onfg2IVotqx6IXQTk0qW3Wh5ST3JiWbpQhB0gEB7PnVgHFQqBMDQCgn8LYEAenUJkHJFitGjC6GfOno+t3x/GcWWV7ELc+gqaLmUbc+nLq0cvW4w9OgfgSoA9N2rWxnfbSXiZ7uiH+yqAFQoW4zeq6d32roQutCKOpnFltfRiDJ9IwCf9u2BUvWDoUvBBCFCIN2ruz2f2SZXwy8FWYaUCCYlxfuy1pnJSQGrdINoGj1TGV0I/acLm81ET8LFlntiJMyohAB8WgmuvoTB0H0hH2S9Vq/u/HzmAu4syLKgTkjSHh61k4ckEwJW4SZRCz1TFZ2sue/wFt3HbGb5EC6w3AfzYEMNBODTGqB1XwQM3T3mAddo9WqOmgFqHh8GyXtnk802WZDDMpB/aPNkPp+qzSfJHSU6Fq9X680wav1apZhKss5MTqlK2t0kxiilldCF0C++/1U6y4eUAst9MA821EAAPq0BWvdFwNDdYx5wjVavNtmXKbn0+cxqo6dedpbsSMl696dIJJqVJMulCMYku6+sRLGkLQvkKNFzZz52KrUM3p67LPRMxc8f/zyaLd/49IaZ6E+4wHJ/jIQllRCATyvB1ZcwGLov5IOs1+rVFOVPPpaZA5S16XzmTJYVvC2IWZNokjv1XJc4m5WYJ1qosyZylJjJgv7j+bahqlUvWeixbroQet/hrS4vhObaywTyLC9TFjJ+IgCf+ukXyyowtAUIokUIWL2ao1YgM2pOuJOvazEjcmAt15/zGVrTKc99jbI6V7XFpGJryk6HU8WfRNGGKqWglb8Mi6XtjU9vRLPl5MRlK92faJ7l/lgIS6oiAJ9WRawXeTB0L7CHWqnVq5l0q5/PzAcUS7LWxyar35k1y2YtUDOHCrHUHFpwsNITI12oJJZhk1h7y26y0GPtdCH0ka3rnOJbIM9y3+xM2mP7UT8ESblxxsL06eh8BYYencubNLjNXi3GS/lvOlXvf4khNePQZiVpvOSVPnJZ0jIfaSyYW/3jibFMYCX2+E2r41I4rjBe9G4CWKJsJnr3Hu3RK/E7tx8mpH2KpC3vdpediUXab2auGU5KinWUjrbVmUZ4G0771FtTx2wYGHrM3q/cdse9OjmkVrbO9wKZ6J344maPF0KXhMyyvPNddqaZ5R+ShCT90JH4uUP/3mHqH0vY8ulYmh1aO8HQoXmsV3sd9+rEkNprQ51UnoneSx9sR7Pla2evOqmyJaWW5Rw1A1QVv9LPv4CkTFDrH/Er+sLpcuFELlnoxY94BUMtoPANTsmlkZQ833zFiyXSAPW+gqZorVi9IZiydNAJ7LtBtzL4xoGhg3dhlw1w3KvHyND7j5yLZkvfLoS2HirL7yb7MiWX22Un6Dm5YU4wpUoxHoB4mxwbwlkcsN/tl0qENuJ2yd1KsSZmRdVCsamKKxpLwPLpWJodWjvB0KF5rFd70aubwJ9Gjy6EfvrNi03UdlDWspyi/Mmb6zhAWRm77ARtWj/vGzSpJ8RyokyCeq5LdFsor5k4QcBmsmGCoaoDED2rwvKpZ9bBnBgBMDQehQoIoFdXACslmkbv0Kmv/bwQ2rLdspyjViAzak645RJ0MUMnczWd8tzXoFWdq+w1qVhPkTXJJ5fIDVVKwXj+srPG0+QQWwqGDtFrvdmMXt0E+jR6dCH0mZ07TdR2UNaynEm33i47tfRMhps0aa54y1zOFGScmkPL9/dT2lKr3KwkRsr5troOPNK8CsunzRVCgwsEwNAuUB2sTvTqJq610FteuxvNln5eCG0107Lcyq0Y1TNaOV9O8qdgYvVPZKvXyoyNUnF5mmzb8rS9XmjgN8WSFQhjee6dUFWxGaGLt+rT0MHw134wtL++8dAy6tX4bIIAu5UuhH75wyuc4m0Ao7m3rqltGHxaG7ouC4Khu0Q7+LqaMBPKWmPiM29dimZLPy+Etp5Uy3IrF9EQEYBPg/AaGDoIN8HIoSFAF0LvP3LOzwuhLbgxmluADCAKnwbhRDB0EG6CkUNDYPbJtWi2fOmD7SAahtE8CDdVMhI+rQRXX8Jg6L6QR72jRoAuhH770rdBoIDRPAg3VTISPq0EV1/CYOi+kEe940WADirZd3griCVuOoeEd1iN123DajkYOgh/gqGDcBOMHBQC9I7Y7JNrobQKo3konipvJ3xaHqseJcHQPYKPqseIAP0C/fSbF0OZQGMOPcjHFAwdhFvB0EG4CUYOBIGb9x8/dfR8NFue+OJmQE3CaB6Qs0qaCp+WBKpfMTB0v/ij9nEhQAdxT05cDqvZGM3D8lcZa+HTMij1LgOG7t0FMGAsCCyv3d13eGvf4a3ltbthtbnv0Tx9cGcN/Gwl4sjP5D0dNZSGW6Rvn4aLXKeWg6E7hRuVjRmBF977MpotD536OjgQ0qP5vsNb0Wz55G/PUVtIwHzfm+693nd4q43G2uRq6CzIMqREMCkpbsGaTifmvRtJAav04KJpnw6uiUNoEBh6CF5EG/xH4MQXN+mejJ3bD/231rLQGs2Jnk1W5jCRtBk1adtSWzpawJ0FWZb6hCRdU5m4rNKicKv04KKWTwfXvoE0CAw9EEeiGT4jcO/R3tNvXoxmy4B2WJl4WqM5R80AyZsMbWpQYZMmOSwDi/hWKz2rVfdW8S1VNBGOr74SC9T6mizzykkpoNavs5TIK7NkPZqiU6qUxUP9y74bagOH0S4w9DD8iFZ4jQDtsHrmrUteW5lvnDWam9NipuQDxy7QddeFu7OYlc1lZ8mOxMyCUCmkfyaWJKuJW5rJejhgKhTcLQvkKNHEvD3XC92mqnwshpJj+XQozRpaO8DQQ/Mo2uMbAju3H9KPsosrt3yzraQ91mhOUf4kSiZVTNjRbHlm586ZnTtnr5qvxZksyGEOCB2LqZwPaxK1qVddH81ErshbTZf1JDtHiZksCsXz7YQZJZEJV8zyabgNGbblYOhh+xet6x+Blz+8Es2WL7z3Zf+m1LXAGs05agUyo+aEO/m6FjMiB9Zy/TmfoTWd8tzXKKtzVTtNKtY/MxsL2prMk98DlIIB/2VnDbiNA2gaGHoATkQT/EVgee1uNFvuO7y12n3gr5WbLLNGcybd313eNSfN0Wx5/o/31+v1o73vqEg0W956uGeo305MWY0F7XgirFk2a4Ga6ViIpebQ8mdpNaGmOguVxGaxSazdsHe4Qcunw21o2C0DQ4ftP1jvOQJ0h9UrH33juZ3F5rU5mvMMdjqdGiw7nU5oQqte8dLvgRlvigk2Ff+MjVKxPiommFv9oxRVHStJ8zB/K0ioKkYk/Nw2fRo+Gt62AAztrWtgWPAI8A6rgI7gzgTd8WieJs1MK5DYJgKOfdqmqWPWBYYes/fRdocI3Hu0R0dwv/HpDYfVdKLa8WgOhu7Ei8lKHPs0WRlidREAQ9dFDuWAQCECr529Gs2W4e6wMhvneDQHQ5tgdxR27NOOWjH4asDQg3cxGtgDAju3H9LBW8EdwZ0JFkbzTFiCToRPg3AfGDoIN8HIwBB48f2votnypQ+2A7M7x1yM5jnABJwMnwbhPDB0EG6CkSEhwDusQjyCOxNojOaZsASdCJ8G4T4wdBBugpFhIPDv//lffzk9Fk3ffeLXvw/xDqs8lDGa5yETbjp8GoTvwNBBuAlGBoDAv//nfz3x698/8de/iH7ys+//9Oc/+s2pizfuBWB3CRMxmpcAKTAR+DQIh4Ghg3ATjAwAgR/+6qigZ/Xv+z/9+bPvfBaA3SVMxGheAqTARODTIBwGhg7CTTAyAAS+9y+L6M+fVAQd/eAHP+DTMQOwvtBEjOaF8ASZCZ8G4TYwdBBugpEBIPCjfz0Z/eRnzNB/8/cHDxy7EIDdJUzsfzTXB3GXMBciJRDo36cljIQIGBrPABBoB4EX3vvyiV//nqbR//tvX3j++OcnvrjZjuq+taRHc9rt/eRvz5FpJGCuGdCFm/sOb1W03Ty9xAxXVAPxTQikfbqpBPJ7QAAM3QPoqHKoCLzy0Td00uf+I+fevvTtYJppjeZEzyYrc9i66soqWAIQk5XNcImiEKmCQHXXVNEO2ZYQAEO3BOQ41JgDMcIuEPDzObJGc46aAbLcZOistqjLqSJ5CfR6vda3UU0X61NT/pFA3Hyl/olbqpitZWAeZ+q7JpUevsOKrpomFfq+rCybxpnGvhtn80NpNRg6FE95YSf1any6Q8ALN6eMsEZzczWbKfnAsQsHjl3gqCmj9S2mipkpjXlXULCkWyNFs/I6ydCK3sVtkfqOSQpJplaawMwaejtk+dTORtwPBMDQfvghECtUr95er/G/ZQQUtj4+CpZtFOXP9XrNfGwy9JmdO2d27py9elc3SfOnTFMT33iyLAi1DEPzzFkJr+YTTmMNVl3aCIQEApZPAYqfCICh/fSLp1apXt0yOYHv1+ttha2Prrds46gVyIwyeXPDiJcFHYuQNc9VpCukM8NZiZkMLevTdXH1CEgE2FnAw2cEwNA+e8c721SvBkO3j4DC1junp+dbTLq/u7xrTpqj2fL8H++v1+tHe99Rc6LZ8tbDvXSTFKWKdWo9+xVyWQScSM8U0Ovd6ZmzqittxahTfH7eRu2YZOPB0Ek8ECtEQPXq9vkJ02iFbaEDespszTbBpMmXt2iSa6TFInJqbYSZmDmQpHOlWb8pplLUb9U9Yedrta351NcGDsMuMPQw/NhRK1SvBkO3j4DCtiNXVqrGZ9vshmSsnNsiiKfXRYCJnwiAof30i6dWqZE6wU/W7liSsT7X6+0vd1eYKBcgoLD10fU+22bhJWbOyXVzSwBRQiAgn47ZZWDoMXu/cttVr9YMXYae06VSRPXuNHpuvtJqUwJVs1pXuL1eZ+lcHBQLtJPXV5m5Vd54VyhVdkoHBXy2TTZfb7PGmnbJ58F7n5Zsx8DFwNADd3C7zVO9WvMlpZT5LCTdLPKrQm8p5a0rzGTod+WGXEKjaY0K23Y91o42n21rp4Xj0wKfBuFzMHQQbvLFSNWrEwz9y9PXrf/RbJlOSZGoVpI9PQ2DoXnqD4b25SmFHWUQUH25jCxkekMADN0b9CFWrHq1Jtc0Gf/y9PVotvy7P1w1SVruydGl1uuP5xN+qVdNTxevU9pk/jHRufE27rsyRbDgdPpcFB1crLfXq1g+jhopk/nrmcvm8kgrMsMg1NXrv/g/7wj9WmE0XWgxVSMXEVPnaHqQ30uWBnNuhp4N9crvIgpbH58Ln23zEa8QbIJPQ/DSGgwdhJt8MVL1as21eQxt0jNxdmIOvTgYTYl0mQjp19zttfhlVxKwnkMz+QlqVPzNiaKI4siYWVfz56LMH7a53sXByeQ5UrWaU8BYshZUTZPjdI3/I0/ZYLPTc+gsPUX1xmAqbH3xtWmHz7aZdiJcHgH4tDxWPUqCoXsEP7yqVa9OMDQlbvxMMLScrSquVXPo+E2xBPXGE23Nl4oRjfmukJm+K2bA4o2tNHdqa1lmMX1uviD5P8wnUqdQqL8ZqFmvYYx8F2wy4a8IOWZn6lG2ZdSrvogobH18Kny2zUe8QrAJPg3BS5hDB+Elb4xUvVpzXmr5WmSlE9Mp6/W2nOnSrNcmQvFet6a6j2MSNd+X1rnKGMWCvB6e9XI4qXp3Krj8D/PJPy24VFJhDkNHk8lzxuy/2GxhmNKTXy8Y2pvHe1SGqL48qkaH11jMocPzWY8Wq16tSDGLjImhr99L7H7OZGgiabVArSbHTMOLg3IXE1E15VqMaE5naUa7aZVbfi0w17en039UU3lrdZrm01aNwgx5qBX9Up6RK996Uz9jG6wv1tKNdXWj3hhMhW2P7s2t2mfbco1GRiEC8GkhPL5kgqF98UQQdqhevZmhE2vaaSKnbcRieTqXCPltsu9N/mFKC9FM3jTvFPyn/tGv2kpt3ptiwipRSn0bMMOJN8WUQKJG5mP5mpu9B5pzzTfFWE9hvbI5ClsfH4SubRPngtGxI+YZn3LTs3XRho9ohWFT1z4NAxXvrARDe+cSnw1SvVozNF/KRFl5nxZhI5pGQGHro//TttFJNU/+9hyZy35n6/cfORfNlvsOb3FKrYBmaB2qpQiFLATSPrUEEPUBATC0D14IxgbVqxMMnSYbb1LEwrXxT78I5o2FGkmFrY8Pg2WbdZAcH/LMYhTgzwZNinkZh203wDC7KDsrOxupfiAAhvbDD4FYoXq15hUPqS5QkxS2Pj4Klm0cNQNkt3zhYM3p6cYYe9wXMldy8CLeHq9O1OYJswzMp/ZR2/pGrOnCumValkjXixQLgQIfWZKI9ogAGLpH8MOrWvVqMHT7CChsfXwqLNuIhslQpuQDxy4cOHaBo6ZMVpNMDlZ3XWT8/BwTevLXZy4rrpMWpC7fmKdajGBWtUhTCFg+Vcn46xcCYGi//OG5NapXt89PgU58WzRbYevjI2DZRlH+pFVusttk6DM7d87s3Dl79W6iSXoSnX4XjKmWOVgGxAxbza7XazlnNn67EOzNvEyMnagQkUwELJ9myiCxdwTA0L27ICQDVK8GQ7ePgMLWx+fBso2jViAzmphM69+Tt+eTNEOLt7XldDnJ0CtJwZQTM3RyUi1ZezJfrZRSH0H0zCZ2lmd2wZwEAmDoBByIFCOgenX7/NTiZDRQVQrbYg/0k2vZxqT7u8u75qQ5mi3P//H+er1+tPcdFYlmy1sP97TRzLyJBW01Qdb8zXIckDPneCItpuHGnFqqF+Q8ncasrytEKA8By6d5YkjvFwEwdL/4B1Y7D7sIOELAzweivdFcXeSs2VRw8HQa72xXU2MmZg4IYDQzCy5X/4wyPM32E0avrGrPp141a2jGgKGH5lGn7UGvdgevz9i6tC3BwU3g5d+imygZT1mXPh0Pis5bCoZ2DvGQKkCvdudNn7F1aVtLDI2foCs+mi59WtEUiOcjAIbOxwY5KQTQq1OQtJbgM7YubWvO0LRybv8w3ZpjBqrIpU8HClkfzQJD94F6sHWiV7tznc/Y+mybO48MWzN8GoR/wdBBuMkXI9Gr3XnCZ2x9ts2dR4atGT4Nwr9g6CDc5IuR6NXuPOEztj7b5s4jw9YMnwbhXzB0EG7yxUj0anee8Blbn21z55Fha4ZPg/AvGDoIN/lipEe9mnbEZr0eFB8rOZmvZChLpAye9P6R2myrSlC1dqrKbfLXI2xTzfDZtpSxSCiFAHxaCqa+hcDQfXsgqPrTvbqre4JTMOUwdCIZDJ2CrV5C2u/19KCUPwjAp/74osASMHQBOMiyEbB6dYf3BNuWxNcnpCbIiTkuGDoFW70Ey+/1lKCUVwjAp165I88YMHQeMkjPQMDq1Rw1A1TMPK45rcigzvgYSLlubCTLIJ3rGLMwcW981ON0YUyWY9nJXN0yLIWmC3lKpDrAOaXQqCzThgTXJyqPnBwuyRim4eo9JW2bmbK8dpei0Wy5vCZusuLon/3HFh/inWqF2gktwE191UpJywRVJJGbmZiQyC+bFhtLiunBsbQ5wHaCoQN0Wn8mW73aHHyZksvcE6zpVVGfGKFlWASITSVpU74IxpJqKKeo+rGZOVPLx+c4y7E/SyErUJqlpEyVdRi/QxvFjWDLbrCwbVl7M3WWbdFs+dIH2+z9aLa8ef/xer0mquaqHu19d/P+YxbjdBUoyaxKXPzNLJKZaJaicEmxdMFhplg+HWYjw28VGDp8H3bYAqtXU5Q/+Z7gA8cucCIHfnz0vLaUiVQMm/LehJhrLYJWxDxd2MvaMcFOxA0KirX57uD4TS5JpzaJc9UcyLJhvdYMbbIyF9JtaSlEQLWkrGU1lm2r3Qfsa7Mmi4/phitTIBmuQZmZRTITk1WJWEmxdMFhplg+HWYjw28VGDp8H3bYAqtXc9QKUJQnT1ZU2iv5bzKfT8WSsaS96VTdKWgyYkzMeQwdTSyKTjBoMUMTB+fYAIY2Hyv2r5VoRomzXz29Q4nRbPnkb8/NPrlmyRgrFvNp/N2KuTP+uSFSvyPQkyB+tNDfufSPGeqLGRdX3+eMAlnV2RaNM57p03FC4XOrwdA+e8c726xezRycvieYslieA9wkSaWCX8XYq0bieMxVzJqYExP3qlFZT6kpXQ3hmQxN+qmoKSDDOTYYc2gqIovHFBLzBTemjUAaoja0tqMj0zb2/nq9ptnzoVNfW/VFs2UyUbiW0CPw5ytjdpt7OxVzsPVkkEvNXPV8LKYylFmdZeNIo5k+HSkWHjcbDO2xc/wzrWSvZrF0QLdJDrZquE5EhEycIGZD8aBr8KQQMKIUJFUU1jMuLp5WqGshccsGvcqtBeUraHpGpxvTQoixakFX2yoybWOGpp+fT3xxM7NaFhO5iRuoUswqnac4VirTXqNkLiJyFaGrRPUcxF6idRetTollWjm+xEyfjg8G31sMhvbdQ17ZV7JXkxgPzVbUqxb5Y0xJbHsxONM207/0CjfZZv4abb07toGhZXn9HUuE6MvT9nySZmjxFUpmK+rV8gqk7C8EKnfcfzN9Om5IfGw9GNpHr3hrU8leTWIszFFv2+WDYQyXD8ZYNli2HTr1NfvU3GrFYvSmN0VN8qa1EWJdycRp3hU1x8SqmFeul7CkuabCix+p3LgBYg6eqs5q3Eij7KyRtj+QZoOhA3GUH2aW7NUkZs6xShb0o5X9WOEzRDVsW+0+OLJ1PQNKtXAtX9FjZpUBlaVYVb04Jt7215Ly1X/zZTBmcvXbBy1zM33LqFFdhlEjTKrh0xGi1HuTwdC9uyAkA0r26szdVgeOXQipqZ3bWhLbzu0SFfpsWy+ADKBS+DQIJ4Khg3CTL0aiV7vzhM/Y+mybO48MWzN8GoR/wdBBuMkXI9Gr3XnCZ2x9ts2dR4atGT4Nwr9g6CDc5IuR6NXuPOEztj7b5s4jw9YMnwbhXzB0EG7yxUj0anee8Blbn21z55Fha4ZPg/AvGDoIN/liJHq1O0/4jK3PtrnzyLA1w6dB+BcMHYSbfDESvdqdJ3zG1mfb3Hlk2Jrh0yD8C4YOwk2+GNl/r5ZbZmlvbC1QEmd5sgZ9jhUndR7oH9v8JvtsW77VyClCAD4tQsebPDC0N64IwZB0r953eItuMSLzSYDPKlmv1/uPnItmy32Ht9ppXw2GlkXo+ArzxirTHjC0iUY6nPZ7WgYpYSEAnwbhLzB0EG7yxUirVxM9m6zMYSJpM2rSdpftoYOqwNBNMLf83kQVynqCAHzqiSOKzQBDF+OD3AQCVq/mqBmgAiZDJ1RQhKbCfH4jLVvTTFbfTJR1w5U5hzbleeHbSJzMV0TPhsrEKrchK0QUi2fY20ESY9hBXVWrSNtmpphHc9Mp3JQbzZZ/9h9iiaVadeQzdmiicMqfidyCiHEyqJbKTNTZKlRSTIkH8tf0YCAmj9FMMPQYvV67zVavNgdfpuQDxy7QqZ9Fp0UaozDRpBiQY8JUYzPJSNqkHBGUiVJChohUOVvr0k001KwTq9xGhhHUBTsOWdh2XHtxdZZt0WxJd2NQqWi2vHn/8Xq9tm6yerT3nXnPVXEVKle4Iv+rUm2yzCyYmagM0X9LiukCQYQsnwZh8wiNBEOP0On1m2z1aoryJ1Hyer3OPJf7x0fP64olJcZUnMOvCdZkGS5I2fHsWP6ZLrIIOr5pWg36eg5t6mf12sLOQxa2nddfVKFl22r3AfvaLGbx8aO978zvcKZkfriYDotz87WKp0B989NSmYk6W4VKiinxQP5aPg3E6tGZCYYencubNNjq1Ry1AhTl0dmKCgOYaOmuQVpiThKsyaDx9Hq64IJJ2bhNmUSb0LMGQ9fxP/vXLMz+5cQ/pbx6eoei9P7g7JNrnCsDku0W80n8nUqtm0TEn+QrkUd0quPxN6w0WcqU+ZS+qjEJZxdU9SoxQxs9OkKL+i6nUoZ6KVamT5POQqx/BMDQ/fsgIAusXs1j9O8u71KYydiMZix30wgqR0pNqxRSwyeTsUniOjEeQNV4upjPV+ryQdYgkdX6RVQztFEbJfLY3I9DLGz7MSKn1kzb2Pvr9Zpmz4dOfW0piGbLZKJ0PDnICEq3kisN1tS6OFEzr6JSmcJFbR8mC1K9wvFsgRUQ3x1lklBLWuVzQmLaoAGEMn06gHYNrAlg6IE51G1zSvZqFksHYvvMkZbnLQZnpsXiMVIWjMMkT7MnXsM0EtWwqioTI65maDWTj8uzFW4RzNfOWOWL9JaTaRszNP38fOKLm5n2sZjMZcok+JWLBEVTmANKPOHfZK4QMVOMsPK5MRvnukQZyb5K3nhm4ln0ah5fSG1XIa0axEemTwfRskE1Agw9KHe6bkzJXk1iPDRbUWGkSbSVjK5dsFItfQiXxLYP07Lvhzb9S69wk23mr9HWu2O5hKqJVrFmvHJC89htRZhGbgyEmaLCgnELCopvaSmGJnmFLhhaIYG//SIAhu4X/8BqL8kiTMk0iHNUt7Yu0crZjp4MaYXhh0pi20tDLdsOnfqafWputWIxetOboiZ5V2NoRbjyx+qsGbbAgoWMMKeJx4ULqmUWzd8sJx7H5FMlUoi0h/rIsbN6eaJQaUkEwNAlgYKYQKBkryYxc45lF6zD0LKMPZIOxy82RD61rIZtq90HR7aupxrBpGgQqhDidA7wSwNRNJlO40Xn+BmglW/JqaY8h+MXC5IFhRYqqObLLK/eYDCzVVV4UyzlRCR0hwAYujusB1BTyZE6c7fVgWMXBoCAuyaUxNadAQWafbatwGxkFSAAnxaA408WGNofXwRgCXq1Oyf5jK3PtrnzyLA1w6dB+BcMHYSbfDESvdqdJ3zG1mfb3Hlk2Jrh0yD8C4YOwk2+GIle7c4TPmPrs23uPDJszfBpEP4FQwfhJl+MpF6NT3cI+OLppB0YzZN4DCEGnwbhRTB0EG7yxWndzAsAACAASURBVEj0anee8Blbn21z55Fha4ZPg/AvGDoIN/liJHq1O0/4jK3PtrnzyLA1w6dB+BcMHYSbfDESvdqdJ3zG1mfb3Hlk2Jrh0yD8C4YOwk2+GIle7c4TPmPrs23uPDJszfBpEP4FQwfhJl+MRK925wmfsfXZNnceGbZm+DQI/4Khg3CTL0aiV7vzhM/YdmobHbeZPCZbw64O41THZuschCoh0KlPK1kGYQMBMLQBBoKbEECv3oRQ/XyfsU3btu/wVjRbPvnbc9RgEuCT2Nfr9f4j56LZct/hrYqICAZW52aniupLL8RJ2vNFSqBOgnE6d53ioZZJ+zTUlgzabjD0oN3bduM67NWjGzc7xLbyY2HZRvRMidb1ZemoSdslKi70e2FmCeWZIk6UZtbkVaLlU69sgzGMABiaoUBgMwLpXu1yLpW30LnZzhAl0tj60wrLNo6aAbLWZOgs+yUdLuZ0ydR0IS+WlDdKqYuq6Hop485I874pea+4/VjI6yGlFM+91d1W8XRcVCovtpICCflT07jCgpl7VjvCT2Pfhd+UIbcADD1k77beNqtX9zaXar1hHii0sPXAIm2CZZs5LWZKPnDsAt1pVnhLqfwZmTjWCErmJX7NnNGaiTH7KjY2shZTqVgIJFlc1KRS0vJGim7x8EOWT4ff4DBbCIYO0289WW31ao6aATKNB25zNDesFsNi1rSGf4M0xs3EpMfQMawgY+hhsyzbKMqfRMlktun3Mzt3zuzcOXv1rtEiw636Tui8+6HltdGJSbXSJB8JQdL62VCzaJGi6DsWNypNyyfMUPpH8Nfy6QhaHGQTwdBBuq0vo61ebbIvD83l51LGtEaNqWIApWQeVTkgxmtVpC8AHNZrYeuwpuqqLds4agUyo+ZDIimXfWh4VtOkkai5dns+4VKx9XGmllGtSqdo5cTo+fytdIzhLztrDI0Nt41g6HB914PlVq+mKH/WnEslh9TFlNhajdQi1/hnja49YOCqSgtbV9XU0mvZxqT7u8u7/M2MZM7/8f56vX609x0/Fbce7hl1KreKpMywkchB8QxIhl7M5ytSxkvZ5gq2lcXVsiKqlFe8ScDM5SLDD1g+HX6Dw2whGDpMv/VktdWrOWoFMqM8rEvbjWFxM0MPl5YNPzJoRpovwfZsM/y+kaHX6oUv8XsIzaHlb9f0hY0fCvM7XJyoxWSCWWlyYVxlC5Ws0BfU3drRnk/d2jly7WDokT8A1Zpv9Wom3cZzKTU8arbmUTU9SapmcyjSFrZeme2zbV4BFZAx8GkQzgJDB+EmX4xsr1czAcum6WkQ/9xoCOjcIU902sO2/afFZ9vab+04NMKnQfgZDB2Em3wxEr3anSd8xtZn29x5ZNia4dMg/AuGDsJNvhiJXu3OEz5j67Nt7jwybM3waRD+BUMH4SZfjESvducJn7H12TZ3Hhm2Zvg0CP+CoYNwky9Gole784TP2PpsmzuPDFszfBqEf8HQQbjJFyPRq915wmdsfbbNnUeGrRk+DcK/YOgg3OSLkejV7jzhM7Y+2+bOI8PWDJ8G4V8wdBBu8sVI9Gp3nvAZW59tc+eRYWuGT4PwLxg6CDf5YiR6tTtP+Iytz7a588iwNcOnQfgXDB2Em3wxEr3anSd8xrZT2+jITj66JoG4Ps7Tp2M61emkkb7kMmF1RsQ4kCcjt4ukTn3aRYOGWQcYeph+ddQq9GpHwBbeqeyuzrKa036nq8Gf/O05UkECfArser3ef+RcNFvuO7xVto5YTnBw/gnZBrEVC1astb64PPBOG7yazxdllBkNKSPuQCbtUweVQGVTBMDQTREcVfkwe7U9GnoytltPjs/YWrYRPVOidbdVOmrSttXkrKjtrKSMmWuGk1LdxcTsWdNzhXr7N97yaQXbIdohAmDoDsEOv6p0r3Y2l9oIVvkxLim5mk/0XUlUS1JgY81uBNLYuqmnjlbLNo6aAdJrMnRWTRLqRXyj6HSx5jPX6XbJqbpo1L7KKqZBw1NGUGvRdKlXnuOiXFM8R0+SK2vTYlROZEynkyiaTEwyJnkhnEPQWo8hoRIn8/mU78BUiWrtIGV5Fo7N09h3zVVBgzsEwNDusB2gZqtXu5xLbUSPx9RqkoKg5yv6VCXLq1IlHPy1sHVQQ32Vlm3mtJgp+cCxCweOXeCoKWNULH9INug3/rlZL2tk+oITZXHr9knzFsvFVCoUJBdrjuvWFUg6l5nqKnK6NVoyLVckbq9WQkpVWj75GFnNNL4ZkC3aBknKnEgBVaNRi6Gw/aDl0/YrgMY2EABDt4HiaHRYvZqjZoDA2DRSr9d8+288dxCDo5ysyJHNnliIYTj+J/J1LJ6hpOR5XpWYr4hK5YCox9aUqp68yRj2VH9RtZZtFOVP+hE97fczO3fO7Nw5e/WuodqgQJNZddgUMP2c5DPh7pgB2dH68TBzqe5kiiJB9VexcYYqbZjB4wl5ZYbRSKlHp8fV6EeOVKnnUD3X4q9aVVCkbSptOWz5tGXtUNcSAmDoloAchxqrV5vzJKbkcnOp7FmOGpiMYTqeyjC+nMUBY7yTQakkc76yFkNnXIeiaqHYVMUVdR2wsO26+sL6LNs4agUyo+ZDkoTahJ3DHJDOimmYnaVztSeT7CvasSmFmZmUFKlKPhu2vPyWqamYMUwasImhcxSoVW/W2m6AndWuWmhrFwEwdLt4Dlyb1aspyp8V5lLJIUyipgffrKlM/nQqHpGNmQhNRBTbm6ygx+LEMG5U3Z8DLWz7MySjZss2Jt3fXd7lb2Ykc/6P99fr9aO97/ipuPVwz9BoQp0ZNhI5KJ4Wcicnmd+rxLcx7W1RWfb3v5gJzWdPPBDT6YQ5Mq3KrJG+4U2n6lueqEouwXD5dfwut/6CaHxd0InCBN0iy/gYLfNZNQBsLWj5tDW9UNQqAmDoVuEcujKrV3PUCmRGeVgXIJmjZAyaMRSmc3VKxnQqQ1tieGPNcjQ1qFzNUligT/8xaH0akVN3e7aZUGeGzUT1zpR+s8/MlW4nZpaMFzs2Zkvta4OYScRkc1mFJlh6MtUjItITNcaMbMpbXxBZtzaJk/S3zMQvL1pSPo8pw3N80jS5PZ82tQTlCxAAQxeAgywbAatXM+lWn0tlznJ4LBOjFEeEETxOiuGMcjgpHjYT8nJqQwOpHABlpllCKBU2SBk7w252J3EL207qLFuJz7aVbUNLcrxC3pK+3tTAp71BX6ViMHQVtEYv22qvtiYLSZq0JhaSTcXURk+naH1RTYNt+Yz5SrIC4UtRSFG0UG7Njbp1d6vYtmy6z7a13NRidYm1mWJR33PhU989JO0DQwfhJl+MRK925wmfsfXZNnceSWqmJffkSk1SIqwYfBqEv8DQQbjJFyPRq915wmdsfbbNnUeGrRk+DcK/YOgg3OSLkejV7jzhM7Y+2+bOI8PWDJ8G4V8wdBBu8sVI9Gp3nvAZW59tc+eRYWuGT4PwLxg6CDf5YiR6tTtP+Iytz7a588iwNcOnQfgXDB2Em3wxEr3anSd8xtZn29x5ZNia4dMg/AuGDsJNvhiJXu3OEz5j67Nt7jwybM3waRD+BUMH4SZfjESvducJn7H12TZ3Hhm2Zvg0CP+CoYNwky9Gole784TP2HZoW/pcGXeQj1pzhz4dNc4NGw+GbgjguIqjV7vzt8/Ypm2jq8Gf/O05AoQE+BTY9Xq9/8i5aLbcd3irImJg6IqA1RVP+7SuJpRziAAY2iG4w1Pdd69uZfi2lYjTR3s975Oek76xLXpaLduIninRutsqHTVpu6iOOM/2TokiEKmDgOXTOipQxj0CYGj3GA+ohnSvdjaXykStYPguyLJUJSXj+wfN0xyTAlZpZ9E0ts6qqqzYso2jZoCUmgydVY3AdjqdxN+JjNPU1XckA3ydqzKzNCKtHgLsu3rFUaobBMDQ3eA8kFqsXu1yLpWJmDF82/kFWZZoQpKuQkheiJAQsAq7i1rYuquohmbLNnNazJR84NiFA8cucNSUMWo0by0zFi8EGdOXJAafA+ISFPMLlKENwfoIWD6trwglXSIAhnaJ7uB0W72ao2aAGl1ipOZRl8diGViI2+3FLVbzVYyfmkuZt+omL8bSsXi9WhXR69cqxVQiL6CU9WiKTqnqyomMYVcVVqjHso2i/Ller5mPTb+f2blzZufO2at3jZrY18bNYjJb3eqoBJS/5LOg3WioQrARApZPG+lCYWcIgKGdQTtExVav5nGZx+hotiw9l2IKVoMy3SdJyWKAppCeaclBm0sRvmZZzuJEnn7lKNHEvD2fZBXv0IkWth3WvLkqyzaOWoHMqPmQGBd9l2FoLG5vdk1tCXZWbQ0o2AECYOgOQB5OFVavpih/Mk9zgLI2zKUEMTMZM02KVDFCaxJdJ8Z3PddNlU1Pv3KUmMmiUMwIbE+njrOw7bTuTZVZtjHp/u7yrjlpjmbL83+8v16vH+19x0/FrYd7hnoTW/21Sd/UnXgYjHUUQwWCrSBg+bQVnVDSOgJg6NYhHbJCq1dz1ApkRnlYlwBZI3WKZdfiOt5chtZ0ynNfQ6HOVb4wqTjJAfEiamIt1VClFHTwl0HroK6qVbRnWxJb/V2Kv5kZAjoXq9xVPbZZvj2fbq4LErURAEPXhm6MBa1ezaRbfS6lCJgmxnoOraZNmmX1TEuO2HIo52FcJKXZXRThIV/6qVBJ7Ek2ibV36mIL207r3lSZz7Ztsh352QjAp9m4eJYKhvbMIX6b02avFqQp/02n5iq33Ioj0vWPkErSeMlLsKn4J3buxFwcS1Gx9PQrpSTNw/ytIKGqK4+0iW3bNvtsW9ttHYs++DQIT4Ohg3CTL0Y67tVp0vSl4R3Y4RjbRi3w2bZGDRtxYfg0COeDoYNwky9GOu7VYOilL55O2uHY78nKEOsEAfi0E5ibVgKGborgqMo77tVgaDD0qPpTn4113Jf7bNqQ6gZDD8mbztuCXu0OYp+x9dk2dx4Ztmb4NAj/gqGDcJMvRqJXu/OEz9j6bJs7jwxbM3wahH/B0EG4yRcj0avdecJnbMk2fA4PAXfPMzS3ggAYuhUYx6LEZxYJ3Qc+Yzs8ZkKLfH7eQu/LLdoPhm4RzOGrwrjmGoHhP0NoIRAAAqURAEOXhgqC8goj1xQ1cv14yoAAEAACjAAYmqFAAAi0jMAbn974Xy+9/sNfHf2Lfz7+V7/574s37rVcAdQBASAwaATA0IN2LxrXKwL/1+v/7xO//v0Tf/2L6Cc/+/5Pf/6j35wCSffqEFQOBAJDAAwdmMNgbkAI/PBXRwU9q3/f/+nPn33ns4Dsh6lAAAj0iwAYul/8UfuQEfjevyyiP39SEXT0gx/8gG8DG3Kz0TYgAARaQgAM3RKQUAMEUgj86F9PRj/5GTP03/z9wQPHLqSkkAAEgAAQyEYADJ2NC1KBQHMETq52BUnLafQTf/2LP/uPrRNf3GyuFhqAABAYCQJg6JE4Gs3sB4GTq92njp7nLWRHtq73YwdqBQJAIEAEwNABOg0mB4jAydVuNFvuO7y12n0QoPkwGQgAgR4QAEP3ADqqHCcCL32wHc2Wzx//fJzNR6uBABCoigAYuipikAcCNRHYuf2QVrzf+PRGTRUoBgSAwJgQAEOPydtoa98IvH3p22i23H/k3M7th33bgvqBABDwHQEwtO8egn0DQ+DF97+KZsvJicsDaxeaAwSAQOsIgKFbhxQKgUARAju3H+4/ci6aLd++9G2RHPKAABAYPQJg6NE/AgCgcwTe+PRGNFs+dfQ81ro7xx4VAoGQEABDh+Qt2DoYBCYnLkez5YvvfzWYFqEhQAAItI4AGLp1SKEQCGxGYOf2w32Ht6LZ8uRqd7M0JIAAEBglAmDoUbodjfYAgSNb12mt++b9xx6YAxOAABDwDgEwtHcugUHjQeD5459Hs+VLH2yPp8loKRAAAuURAEOXxwqSQKBlBFa7D2ite3HlVsuqoQ4IAIHwEQBDh+9DtCBkBF47ezWaLQ8cu3Dv0V7I7YDtQAAItI8AGLp9TKERCFRC4Nl3Potmy5c/vFKpFISBABAYPAJg6MG7GA30HYGLN+7RWveZnTu+2wr7gAAQ6BABMHSHYKMqIJCDwKund6LZ8uk3L2KtOwchJAOBMSIAhh6j19Fm3xC492jvmbcuRbPlKx9945ttsAcIAIG+EABD94U86gUCCQSW1+7SWvfy2t1EBiJAAAiMFQEw9Fg9j3b7h8ArH30TzZbPvHXJP9NgERAAAj0gAIbuAXRUCQQyEbj3aO+po+f/dDclXhnLxAeJQGBsCIChx+ZxtNdrBA6d+jqaLV89veO1lTAOCACBThAAQ3cCMyoBAuUQOLnaxUJ3OaggBQSGjwAYevg+RgsDQuDeoz16XwxXRwfkNZgKBBwhAIZ2BOww1UazJf47QoCfmBfe+zKaLd/49AanIAAEgMA4EQBDj9PvNVvtiJyg9k+/PbNL6FbKF9//ilMQAAJAYJwIgKHH6fearSYqXa+38b9FBBSqsVNWuw+i2XL/kXM4X6zmY4piQGAoCIChh+LJTtqhuAQM3SYCClXtwqffvBjNlriSUiOCEBAYJQJg6FG6vW6jFZe0yU8tTkYDVaVQ1V6ho0twAqhGBCEgMEoEwNCjdHvdRisuAUO3iYBCVXtlceUW9lxpOBACAmNFAAw9Vs/Xarfikjb5KdCJb4tmK1S1S+492tt/5Fw0W652H+hUhIAAEBgZAmDokTm8WXMVlyQYmvbvUlbe53q9/eXuqkVWG5IqhWrCN7Tn6sjW9UQqIkAACIwJATD0mLzduK2KSzRDl6HndKnu+HX1+iR6br7SBndRdcVKFT4J97zx6Y1otnzhvS8TqYgAASAwJgTA0GPyduO2Ki7RhEcpZT67oMZ4G9i70+5ZeZ1ZaWaiRo8wUagm3LNz+2E0W+47vIU9VwlcEAECY0JgA0OXGXkhsxGBwTxRiks0x0Sz5S9PX7f+pxPliRy6lGO2LsWLbduQWWlmoo2DQtV+TJ556xL2XNmgIA4ExoQAGLqLYywH80QpLtEckybjX56+Hs2Wf/eHqyZtZzC0WAqmfwcX61PzSTSZfyxYc3Ewmry+otlwQoYq/Xiuik0X2+vEzJXo8N1prDaKpu8mBLS2SJZVxecHqURsQPo8Fl3w4ELkyooSpTIrNRIP/dt8wpUm27jeVqjaj8mrp3ei2fLQqa/tDMSBABAYBwKlGLrt2YYe3wevOW/wDfTpUs3RHsxjaJOeibOTvjYml4uDkhrfnUYHF4L8iAUVEdJPyLGMoOckjxp6NFvnJSqOFIxLP05LEhVELllTV60bmOB4bSrRv1kqr1L1K/jioPzGIDQvpsoS+W1AoWo/FGd27kSz5YFjF+wMxIEAEBgHAmBocyxuP5w3+Ab6dKnmaKAopcxngqH1rFROXzVHGtSVlhEpzN9kwyZeZNpOllUcmVlct07YnDaDdfJ8WnyNyFRlJaopOC8SFDL0er3GnqtAewrMBgKtIACGTg7HcsRMcEmzFEVprTirfyWqORq0jOVruWxrYWiLJfkyFl6I1Wa1/kzUmOTjjFIWBfLMWM1cmTiTZSsydNIM1lmNobdX8+cm84/p08RHoZrh35c+EGvgs0+uZeQhCQgAgaEjAIbWZGMOmm2FCwbfEB8t1RwNmk29alJ4/V5i93NKTCwvp9ar06vclkx6lVukxKQuCD6foQWtKknN1pkEr1snH4NMU1PfADbTtvzOMTk4nXDZuCKFasYTQXuuJicuZ+QhCQgAgaEjAIa2huOWowWDb4iPlmqORilFvSIrnZhOSaweyxepiLBX8+ey3hRTv/tKoqUXuwxipqXyg7zJakFvi+W+KcYcWYahkwvdlk6DmDMrNRIFMiJKS/rG2oxCNeOJuHn/MfZcZeCCJCAwDgTqMHSZQypwhhTNwgsG3xAfMNUczdDEx5Re8NnWmkToetTqegaAec/D88c/j2bLE1/czBNAOhAAAkNFoDJDl6HnzHG8o7FVLGDyDCkxDtYywJxj1dGmoBjI86OaUweKWvh3X5F8u5sm6eLT+gW6mT2r1yfJd8QIE4Vq9kNCe65e/vBKdjZSgQAQGC4ClRmaRpMynx2OyE15NN/UAs0FWXocLx58g3uuVHN0A/Ohg4yJAG3jzv7uqFDNfhyW1+5iz1U2NEgFAkNHoA5DW1tdaberlZjxu6Pxw1vbw3opsqxVaYHmgiw9NBcPvsE9Xao5uoG1UEXxBAIK1dzH4amj56PZ8uKNe7kSyAACQGCICLTG0IM8Q2oyf91++UjsB6KTqtRKqHzxJ34hKM7V4+/GwTesh0o1RzcQDN0cAYVq7rNAe65eO3s1VwIZQAAIDBGB1hh60xzamHHqg5nSu2vUMmDPZ0jF23LEe8X2r9rcEA6YdGUnbhx8w3qoVHPMJiPcFAGFau6zcOKLm9Fs+fzxz3MlkAEEgMAQEajD0DSgbPxMzC3EC1zGP9pwknFCRVJG71vlQdCkQA5zwDjaKVlWvUObJWktvyde5zHkpbXSPvoaYWTFZ0aS8epLhtoZLBf8B/LsKC5hdyDQAgIK1dyH5Ob9x/sOb+07vHXz/uNcIWQAASAwOATqMHSCehUPWYn279BJvoyFMxg6+epsRimTFznMAWcMrS35eB6fOGFUmpEbD9wbB9+wnqiNX8sgUBuB4ieB9ly9fenbYjHkAgEgMCQEWmPogZ0hRadh6FVuvnBJkHFqDp2RO2SGHlIH8KEtZb7GvXb2ajRbvvTBtg8GwwYgAAS6QaA1ht4wh7ZuIPD8DCm1oG28KUa7ZaLvTf6BT200jovKyCVAygy+3Xi6lVoG1pxWMGmupAyqF2/ci2bLp46eb14dNAABIBAKApUZGmdIWd9FiqNlBt9QnpX1ej2w5niCfElUDxy7EM2Wy2t3PTEbZgABIOAagToMXcxJoeW6PENKnlA9xDfFXD+W49JfkqFf/vDKn56lV0/vjAsdtBYIjBgBMHQL7+IWfCkpOfiG8gQOrDmewF4SVdpz9ew7n3liNswAAkDANQJgaDB0hWesJJdU0AjR0r8d3Hu0R6fiY88VnhogMBIEwNBg6AqPOhi6AlilRcujOjlxOZot3/j0RmndEAQCQCBgBMDQYOgKj2+aS8wUuuOBUuiFJgpHs+Wf/cdW4vd4+R78ZL4y617Nxak204WZNoqwiWFxg2efXMOeq2KIkAsEhoQAGBoMXeF5triE2IKpN5otaQGWqJr1Ptr77ub9xywm0sHQjE7pVe71er3afRDNlvuPnDNKIwgEgMBgESjF0DwTQqAeAoN5fCyGXu0+oC1YVgMtPn60912Cni1pFcUcWiFR9Jf2XC2u3CoSQh4QAAKDQKAUQw+ipf00wqK0foxor9bM5qTZ908pvCkomi2f/O252SfXElYYc2giZj6QHavcCaBSkUOnvjbhTeUjAQgAgeEgAIZ268tMSnNbpUvtmc0xGZpmz4dOfW1ZEc2WiURmaBmgH5+NoFV64NFMVPPavLhyK5otn3nrUp4A0oEAEBgMAmBot66sNPi6NaUN7ZnNYYamn59PfHGTVmJJ2PzUJiiGNlkZq9wan/wQ77nauf0wXwo5QAAIDAEBMLRbL2ZSmtsqXWrPbA4zNJ9JyaxMtlhRkQiGNtyUiaqRbwdfeO9L7LmyQUEcCAwRATC0W69WHXzdWtNYu9Uc+k2UEs2tViyWDsQmKIamebPcdrUtN1tht9VmJx3Zuh7Nli+89+VmUUgAASAQMgJgaLfeY4pyW01X2ks2h8XSgdhSxdBqOs0vioGhN/uS91zde7S3Wfr/Z+99Qu04svvx9pBhREiIQIQx35UWszBhFg7MwpvBhizmErLwcrIJht98xWwSZ3EDhjB4EzIYhnRAgSf8vXnGxGAbLYTNMI4Xw9VgGwkt3DyeLAnb8p2HjZ+QLKOHLEuW9Nw/V52uU6er+97bfW9Xd3Xfz0M81d9zTn1OvfPpqv5TaAEEgEBvEQBD+3UdU5RfNW1JrzgcaiZ3vyt2bGscYelZAZzHX7kSxQneuQrLkbAGCDSNQG2GltFEbmwu+YZU03ZXkicWapXaq0a01+q+8rPyQ0wSrso2hNuw4nCoGTfmbLgD69QyBqq6Fc+9+3kUJ8+9+3n1LmgJBIBA7xCox9Crf0OqNWA0K2cEC4ZuGvaKXOJQspNt2qjey6uIqhwnvXP12MuXZSHSQAAIDAyBegzd7DekfECpSXmde5lYQy9yS0UuKX3b6vj2pUWiN7iuIqoSobsPDo9u7UZxQn+SsgppIAAEBoNAPYamYfP9RUbhu5Il35BS3xSmZ3X1M0H64d2sQC94ZbrYUikS3VVvsT6mmvGUyswzRyafHc9A1G2VZy/8RKOROq4hiqKsXY6hhU7VxN375vHPT6wQfOcL675mYMPpHlBtwWqo/vx3f4ziZGvnRiCjgBlAAAg0jsC6DF31G1LEnkRxzKjZTd/RZPaHseVIzaVOS+qSkagGoYyh+cHgjEq5DdGzLrXKqVDLtIXyPrToJZL1XLBa8K2no8XWAxtOi8gtUrUaqi99cBPvXC2CFXVAoP8IrMXQdb8hRYvV7LfkYLGGzS+EddvxtEjQpWvoeQyd41dmY1Eq5Ns1tKjPFvAZ8dfx+mrBt46GVtsObDitYjdf2Wqo7n91P4qTIyd38M7VfGhRAwT6jcBaDF39G1KCAvN4UYVg6NKWVJgjSM2ftKiWtZJWmcVzhdxalAqlYOi8g/I54hL89oFAHulKOXrn6q3ZQaXWaAQEgEDfEKjH0Kt/Q4o4kO/kTieTGb/aNJpM9S1qybdOS0GhGcKCX0Uyv9jVFUoqJ8ztbEX2opsQbxm6UMg21XDyasujGgrabTqw4bQL3lxtK6P6/Ll990iSuUpQAQSAQP8QqMfQ88bHIaaYsF0ykqZNbubN7AmtrNLd+rZ3p90nxbIbv/KyhgAAIABJREFUxnr1rR/2MitsIl79WJcg5oyPtXK6EljK0LxnThbjSTE6Crr4nKB1MVIrIcB/NXV7n9+/E8UJHpKvixvaA4G+INAkQ3PspojD2b5g4cPOlYOvD2PWlzmw4awPSCMS1kGV3rm6fPNuI5ZACBAAAkEh0DBDEyuDodnH6wRfFhJOYmDDCQTYdVB95u29KE7i968HMhaYAQSAQIMINMzQZBkYmj20TvBlIeEkBjacQIBdB1V65+qp0x8FMhaYAQSAQIMINMPQ+IbUPJesE3znyeywfGDD6RBJqXodVOmDBHjnSuKJNBAYDALNMPRg4Gh8IOsE38aNWV/gwIazPiCNSFgT1adOfxTFyZmPbzViDIQAASAQDgJgaL++WDP4+jWuvvQwhjMdm2+02hHQI/zqMf13SmptuwWp6bjkfboyXQtkrFS1Jqr0ztUzb++tpBydgAAQCBcBMLRf36wZfP0aV196cThHTu5EcXLs1C4JowbyMX562PjIyZ362ub1KLKm4mfxul32Pt28/nPK+8rQ9Gk/vHM1x60oBgI9RqASQ3PYRWI1BHo8QfKm0/C5jOiZMeEXprkZV3EJ910jUcrQzMrF2oqq+srQaZo++uJF/sBfxdGiGRAAAuEjUImhwx9GsBY2ykzdj9IZDmdlgqyU790V7RZkKAh1NhkVPlkjV8bj8Ugvlc+afWy9tT0eq2NX9I9m6bxAU0VyFuoVlebrOqPJxOgqDqKxEkZvZYn0ztWvL1xbWQI6AgEgECACYGi/Tlk/+Pq1r6Z0ZzhyN5sp+fj2JXq2n5fUJUqYDafj0WhE69/ZhBJiy1oxJVWqQrNMJg5WdZK/9Xdk6UNwtkvWgOUs0cs8nknWTG3UlgyjmSIH1RWEnvn4VhQneOdqBejQBQiEjAAY2q931g++fu2rKd0ZDmX5N1EyiWTCjuLk/P6d8/t3Llz72mqzbKy/yq5I0BRJ5tVfT9e0KVbG6nut6lhvwZxurWLrUjlGyXRc0KvEalWmjbZWSrbmN5tyUF1B+K17D+mOw617D1foji5AAAiEiQAY2q9f1g++fu2rKd0ZDmedRGlWLrhT9Vl1fS54xs3/pE4YJcotZVbNymKVrCk6WyDLdbNIl8uZr7fPDJ2mKb1z9eqVL2u6FM2BABAIFwEwtF/fMFf5VdOWdGc4TLpvXD2Qi+YoTi5+cS9N0weH31KXKE5u3z+UZipGFvvb4/E/mjWxs8vNO8+m3rC1WN6KpKmlw8syEhdsvVAv6+rZLneapr++cC2KE7xzJecY0kCg7wiAof160KE0v8r8S29yOIo1DenKdGqOCFUPeZkGlnfFKpnON1NN5DvQgq2VWPphOSTcZHN6zS43adD9+vKkWJqml2/ejeLk0Rcv+p8F0AAEgEBLCICh/QLdJKX5tbSS9IENp9KY/TdqClV6QO/8/h3/JkMDEAACbSDQC4YWqyLGRL9oo5dYcv3E1VUSJKK4yKrSt2qbpoJvVX2e2w1sOJ7Rqiq+KVR/+ftPv7vX8Py5/aqK0Q4IAIGwEajN0MP6hpTZ7VSbqParVAWXlV0iFBqVFjQVfEuFt184sOG0D2CpxqZQfWumngZ44rUPS7WgEAgAgd4hUI+hB/cNKWZo9+WcvCPB0BkeTXFJHt5NzzWF6t0Hh3jnatMnE8Y/LATqMTSHEpkgQOSjvEWI8g/hGF7s/htSxhJl8R5/AcNuf6tne22OHvC1+exB4eJwbQkDZYv6nBrYcAJxRYOojs5cjeLkpQ9uBjI0mAEEgMA6CNRmaFbGlNznb0iVM7QZIy+dOWFq1P+lhbKBSjcYfF3RXeQHNpwuICzR2SCq8fvXozj5+e/+WKIGRUAACPQNgdoMTdGEYwrxNH9Misr78w0ph6FN1i6TqSRPxm7tIp8zUIsa9aduYMMJBPgGUZ0dfBPFydGt7KixQAYIM4AAEFgNgVUYWi4NKbhwiJFZJm9t2fxvOal3Uu1+sdkPl6SoKFF95jHXyrApr2XL5czXyx0JOe7Oiey7V/nlckntIuQZmUWN+lM3sOEEAnyzqD728uUoTqaf3g5kdDADCACBlRGozdCkaSjfkJI0by4A+NpAkXFhDV1Suwj8ZoPvIk2t1A1sOK1gtlxJs6g+e/az7y6O8c7VctzRAggEj0A9hl5rOJbw8t916vIbUtnL0OLbVdkjY6piNB5nn4o2T4upRbx6oMypXQBLs8F3gaJ2qgY2nHZAW6qlWVSnn96O4uTxV64s1YsGQAAIBI5AiwwdOBJ+zKPg+9y7n/9/L/y/vxxv/8W/nv6r3/zv5Zt3/WjzLrXIJbIkuf41ZaM4Sa6rk6w4+2f/tZO/62GekR9NZvLSrTiCubW8m1HsM69khS7zRDVZLjFcXy6/czU7+GZ9aZAABIBAhwiAof2CT8H3T5554ZFf/faRv/5Z9KOffP/HP/3hb872lKQdLqGjGph6ozih0w+JqhnZB4ff3rr3kJvpcvVsgX2ugJvWSKxAtyt0qWHQyk0dVFeWwx2ffvMTvHPFaCABBPqLABjar+8o+P7pP7+o6Jl/fvSTY6d2+/gsj8MltErLU6/C0+FjOuEqD/T6ZLmChBW65K32k3NQXV/JSx/cjOLk6Tc/WV8UJAABINAhAmBov+BT8P3ev02jPz/GBK0ScRLFyfHtS8+9+3mP1tOlXFJk6O9K+EmlKE6OndqN378ugVbfWNU/+kk8Jk6dmGSV5ik+rjVPAGSLb10+NU8FmLOjU7UrTj9miW5K2jmoSg6zYroU1Yp9S5vxO1d3H+RO/CxtjEIgAASCRQAM7dc1FHx/+O9vRT/6SUYcUfS3/3Diz/5r5+jWLtXScz1bOzf2v7rv15q1pZdyiWRoWj0/e/YzR1UUJ/lC5l35Mpt+05yI1e6Cm5bmPTwjWTfmZ+2zLXPTWEs19J/VaaY2vG+khPB/KaprGvb4K1fwztWaGKI7EOgcATC0XxdQ8H1rdqBIWi+j/+bvnn7q9EdnPr6VpumrV778+e/+yDxNO5OvXvky2KVPKZcwQ9PtZxpaEVZupqsEldoX0xcWugRb1tgsl+0qejYxz+PLS4GidV2WlKK6pkHPvft54apoTZHoDgSAQNsIgKH9Is7B963ZwaMvXqTvPb165Uup9da9h1s7N5547UOm6qNbu8+8vRfgjWoejrSfqZcf4aZaeTfaeXYs/81U5lpOSDaVhdketl5my3KTVgxtNrfJiE1laHrn6rGXL0tPIQ0EgEC/EABD+/VXKaXNU/ndg1fPn9s/vn2JqTq0G9XOcOjjGFQoX7XiZs+8vcdjofevzNgNp6o8pzkxr1C1Npw7r3H2lRmhaBN3udM0pdsoeOfKzAT8DwT6hwAY2q/PmKtqqTm/f+eXv/80wBvVKwxndvDN1s6NwvDn8SvfJ+YGJqHvO+vta75TXWxMH8Mxd/y5oS7YnCfFCG26geI8o1dwBAqAABAIFwEwtF/frEBp0qDQblSvORw5NKQZAU+o0jtXozNXWRESQAAI9AuBThjarIr6BdVK1jYSfMO5Ud3IcFYCcsidPKG6/9X9KE6OnNwJ9sHDITsVYwMCTSBQm6GPnFSfbzx2KjvejoILPyvEd7+OnNyZb94Chl5QNV9ewDXNBt/Ob1Q3O5yA/daqaf5QpccP35odtDoeKAMCQKAhBOoxNNGzZGVOE0nLrKTtvLULaHhBVV5GT3Kegm9XN6o9DacnzvRlpj9Unz+3H8XJL3//qS/TIRcIAAGfCNRjaA4lMkHmSYYuN9i8qyof2Mk//WNz9PStzeffoCmXH2QpA+XJupZvVPsejieUAhfrD9Xz+3fo03WBIwDzgAAQKEWgNkOzFKbk49uX6AUhPsuI24iEYlviWffLE6oRL505IbraWlnYj7S/4CvH39qN6naGI4e2CWmvqNIbAT36suwmeBxjBAIVEajN0BRNOKbwVjYTdhQn5/fvnN+/c+GaOn8w+zEvseqsoGG7TKY3Z0QVEXf24gy/V2ME9uR/Bqode33fqG55OO2A1rkWr6jSK+l456pzL8MAILACAqswtFwrU3DhECOzTN7KrFKGtl+A2jPfZhQMXVK7wgA77sLItGyHpxvVXQ2nZfRaVucV1VevfBnFyVOnP2p5UFAHBIDA+gjUZmhS+cbVA7lojuLk4hf30jSlcwYp4ty+L8/VKdvlZjpWZFxYQ5fUrj/etiV4Db5VBtPsjerOh1NlyL1r4xVV+vbqkZM7dHR378CBwUBgkxGox9BrIWU2tMWTYuY8wdF4bM43yFqpW9YltWsZ0EVnr8G3+oCaulEdyHCqD7wXLX2j+tTpj6I4mXeiSS8ggpFAYDMRaJGhNxJg38G3Lqhr3qgOaTi8x1IXg+Da+0aV3rl65u294EYOg4AAEFiIABh6ITxrV/oOvisbuNqN6uJwmviCzWqDAENXxY0ONTm+falqB7QDAkAgDATA0H79UKQ0v/rqS691o9oZTkNfsKlvtOoBhq6BG70PmT9erEZ3NAUCQKATBMDQfmF3KM2vsjWkV7xR7QyHszJBVsgHCcvs0vw6nYzMYVX6LXmVse/VcZF5k17JMYXiaQZbKBuWKQ20jNHzZx+9c/X8uX1/KiAZCACBxhEAQzcOaU5gC8E3p2/tzOIb1c5w5At1TMnVv2Bjn99nYraP/NuUZmV+1L/43RuxmJ6OLcGvDUVrAhxUfeg98/EtvHPlA1jIBAJeEQBDe4U3bSH4ehpA8Ub1WzP1ip3DylTC5VzLhF3+BZvcHrWgWC5Xa2X7rdfpWGfmvlWffddG/Wc7eQKmebGMXvOijcRb9x7SLQm8c2Ugwf9AoAcIgKH9OqmF4Ot3AGlKN6qPbu3efXDoDIezTqI0y+StDS5jZVVhyusxdA9pWbiN4RJlzSfpnatXr3zZvGhIBAJAwA8ClRiaIgh+r4yAH991INXhEibdlb5gwxvShpXVgDjt7HITB9tCfT/abn2zrA5AWVulg+ra8soFxO9fj+IE71yVo4NSIBAkAmBotW3r+1+Qrl/FqOa4hJlYsnI+bR4K45vUymLF0epnzpNi2OWe69bLN+9GcXJ0KzvZfW47VAABIBAMAksYOhg7YUgQCDTH0EEMJxAjWkOV3rk6v38nkIHDDCAABBYjAIZejA9qcwi0xiU5rUPPtIbqL3//6Xc3JvDO1dAnFMY3HATA0MPxZQsjaY1LWhhLOCpaQ5Wexn/itQ/DGTssAQJAYAECYOgF4KDKRaA1LnEVDzrfGqp3HxzSO1f7X90fNKIYHBAYCAJg6IE4sp1htMYl7QwnEC1tojo6czWKk5c+uBnI2GEGEAACCxAAQy8AB1UuAm1yiat7uPk2UaV3rn7+uz8OF06MDAgMBwEw9HB82cJI2uSSFoYTiIo2UZ0dfEPvXN19cBjI8GEGEAAC8xAAQ89DBuUlCLTJJSXqB1rUMqqPvXw5ipPpp7cHCieGBQSGgwAYeji+bGEkLXNJCyMKQUXLqD579rMoTp579/MQxg4bgAAQWIAAGHoBOKhyEWiZS1z1A823jOr009tRnDz+ypWBwolhAYHhIACGHo4vWxhJy1xSdUTmU6C546X5E6GjSVU5HbVrGVV+5+q7k0Y7GjHUAgEgUAkBMHQlmNCIEChyCb1fe+xU9rVnasAnaqRpenRrN4qTIyd36mAov9q9rJ+iZz44Y28y4ow9ZmOZiI7ri6j6NujpNz+J4mRr54ZvRZAPBIDAOgiAoddBb+P6OlxC9CxZmdNE0jIraXsZcNUZWlFy7uxJe2xldSHLzPFc76DqWZsS/9IHN6M4efrNT1rQBRVAAAisjAAYemXoNrGjwyWclQnCRTJ0GVKKPsfjUXYWlT3GajxNz2bHV0VUyS1HI0nGxL+Wj1nJ3mQ0msz+wEJ4fc0tQksweq0ZRu9cHTm5g3euWsMcioDACgiAoVcAbXO7OFwil8VMyce3L9EZSmmaOu0FcHJvWix2p2NNqKJEnzeZsex0zOvlLDnTdCzkpimvqqWQXIvQMvNR8mjp469cwTtXHvGFaCDQBAJg6CZQ3BgZDpdQln8TJRMYTNhRnJzfv3N+/86Fa18LnAR92gW0PvlZ7VmLWjdNW9oZk6dz19D5o6aF4gCTDqrtWPjcu59HcfLs2c/aUQctQAAIrIAAGHoF0Da3i8MlnHUSpVm54M5xcAnLzmNoxcijyUysnHnFbJxipUkhpjbI/xmuNq2jd66Ob19qUyl0AQEgUAsBMHQtuDa9scMlTLpvXD2Qi+YoTi5+cS9N0weH31KXKE5u35efmZT0KXe8CWGnVtxKVuQ8HiuaNr7IPbItRUkhpnGQ/zuotmYjPWaPd65aAxyKgEBdBMDQdRHb6PbNcUmePuVGt97GVkwrnhSzfKxX33w3OnNG1tr0sKWCyAP2W3Oo1hvkz3/3xyhO4vev1+uG1kAACLSFABi6LaQHoacrLpHgicfFZHGP012hSu9cjc5c7TF2MB0IDBoBMPSg3dv04LriEjsOcQvaFvY81RWqt+49pI/J4J2rns8gmD9YBMDQg3Wtj4F1xSV6LOqhMPH5MB/j60Zmh6g+8dqHUZyc+fhWNyOHViAABBYiAIZeCA8q8wh0yCV5QwaV6xDV58/tR3Hyy99/OihAMRggMBQEwNBD8WQr4+iQS1oZXzdKOkT1/P6dKE7wzlU3jodWILAMATD0MoRQLxDokEuEFUNLdovqoy9ejOLk8s27Q4MV4wEC/UcADN1/H7Y4gm65pMWBtqqqW1SfeXsvipNfX7jW6pihDAgAgQoIgKErgIQmBoFuucRYMbT/u0X11StfRnHy1OmPhgYrxgME+o8AGLr/PmxxBN1ySYsDbVVVt6jyO1e37j1sddhQBgSAwDIEwNDLEEK9QKBbLhGGDCrZOapPnf4I71wNakphMENBAAw9FE+2Mo7OuaRklPaTn3TsVUkTP0WlHzfLf820muLOUf31hWtRnDzz9l41e9EKCACBlhBYwtAUO/A7NARamh0FNUUuOXJyJ4qTY6d2qS0DxV3peIYjJ3e4pEKiMs/Zk6zSdDaZTCvIbqzJcBg6uf51FCePvnixMWwgCAgAgSYQAEMnTCo9SjTh+lVkOAxN9My40fnQ87J8EFYFxZUZunLDCkrrNhkOQ6dpenz7UhQnyXV5hnddQNAeCACBhhGoxNBpuod/gSDgcGTD02GZOEc7Z2WCZMjDKMukKmodj0cRHVNlz7YaT9OzdK6VOamKW45GI3GoVcbN74zdD4FK0pZp+miokapsKpTkzCg2cNoLhjYdR5PJOKp9oBajVwZUS2X0ztXz5/Zb0gc1QAAIVEAADN2zi49uo7mjXS6LmZKPb1+iBRkvqcvm4ZyDnKdjzW+SWUVLwYkimRGnuQvt9CW+VG3yzFksER3JDKFDDcHJ2ryykLRrps7rKRu8U+ag6tS2kz3z8a0oTp547cN21EELEAACVRAAQ4Ohq8yTrI3DJZTl30TJ1JQJO4qT8/t3zu/fuXBN7qAKOjQLULW8LTkTWrSUpOjwoBZijpbmOtNX1RoGJ/vKSzITMjO0TJaVOlk2JnfcltFYA9TUQbVO18ba3n1wSPcs8M5VY5hCEBBYGwEwNBi6xiRyuISzTqI0KxfcekFquK9Ilor8TG0urVhyNJnlONGYb8SU9TV1pq16rGw5Z+vWqqFZIqfUL8uaNXXOGqndalucYrgWN/NdS+9cvfTBTd+KIB8IAIGKCIChwdAVp4pq5nAJk+4bVw/kojmKk4tf3EvT9MHht9QlipPb9w+FJslkYh87a+HUMltrhlT3r03JdDKZUR/etVaJbL1sBXMtm1Assa25ESVyFEwmKK2GoVWi97vcaZrG71/HO1eO65EFAt0isApDO0/wcgiWiTTd++RgFsjTVUMyw+HIlmdPc9olB5uVKe0xm63qsh1vNVzLhyaX7U3zNrZqoX/G4/xa3BRnL2VxO8PotF7O+k61Js6QYpG1DG2r+vukWJqml2/ejeLk6Fb24lzLUwvqgAAQKCJQm6Gr0LOJ410sT2cvjKInJ7MuVFd64v318XrmGWyLrmyjpFvtNEJeurYx4FZ0hIAqDZQe8Zt+eruVcUMJEAACSxCozdAUTar8bnHlui7trW1qdQMWtFxQZS84uo3m3WpXc9nZcV4yvftR3T2qBqdnz3723d0KvHNl8MD/QKBjBFZh6F+cu+H8i+KkWLI27VlaWiaqErctE1JdXbFldQMWtFxQZTV2G8071a7uHLsvP3f859OM+k5RzQ3hrZl6nuDxV67kSpEBAkCgIwQaY+i/f+eaJGn93JDlFcWOav+Zfk5M07P6/dT3VPn0RDR6YUZbxLk21P09HZdVx/F0L00ljVH6dXPXMYrGr+caWGnU13SfnCA7RhNtgLs7rcVOM2vH073Z5Em3vZV8YqpMMj/KgD1xe1Nl5dhHkxd4lzvfrIIQLarbaN6t9o7+RryrDQdVfudq/6v73ocNBUAACCxDoDGGlvT8i3M3CgwtmHV6QlPj6+OI6O3ENOPIYhtFz3keFW0sW88rNMSsCJVuTmsi1DyqrgyUAfnLCJXVbeiiQbUxBtj2Qp0dS/HmNzdTAvXlBZG901I2c6rMJYW4rd5JND/z8a1nz35WfJZ72exCfSUEOvHpPMtGZ65GcYJ3rubhg3Ig0CYCqzA0BZSlv7PlI1GgXXTq5ablSEOiuUW2aaN6OSTKfCbZq6ww31c/XiS7OGnJ02XSMubWDFoyFtlF7wpki2rTnjcJ7FVFoZmsoq0FKcRcSXQSzZ9+8xP68Egn2tv8e+hEV1Cobu2oy+un3/ykEyigFAgAAYnAKgydo17NHIUV855bkufLTIJeodLi0mwF5/m4pJfkQk5zQvBuvm/TDJ23U5Kr1fveZDSfoYvNFgtpkaHvPjicHXwjZ8lbs4NfX7h2697DoLhEWtjrdFCozg6+oXeu7j6Q76/3GmAYDwT6ikBjDH3jbu7tZ5ehFf2Y7eKMbEp3uZ02xV1uVZKRuiJ42hYuY2itMWtp6bC0pVxAC45Xdpa2Lx0LWSJuqyulbF5hl5vvvueaLRCSGek1mp/fv/PM23tHt3bnLaG8au/r39DadoeG6mMvX47iBO9cre1YCAAC6yLQGEM7C+sCQ8snxaLo2f/gG8zqOSzeBFZ0ZX5oJ1wTLRUJYtYF4xPuU1eqi+BUK80wn6zNpSVJCwm5NqLcSqbH08zTYcqA7NG2743+75jW0GLLWjwpVtIse3ZsnhCzXaGxXdfxTv/9r+5TXCa2GJ25WrqECo1LnFH0NBsaqvTO1XPvft5TPGE2EBgMArUZOk3VDvbSfw5hI9sUAv6i+fHtS4++ePG5dz93trjlXPenXWrZtHRoqE4/vR3FyWMvX940R2C8QCA0BFZh6KbIJgw5+slts26f83S3XGF3nG4kms8Ovnnu3c8v37wrp+MCYuZmjWhnaZ4T+Q+Lup8L9ay8jvjQUL374PDo1m4UJ1WmRJ2Boi0QAAL1EABDd8y4dS9T1onmdx8cvvTBzSde+5CE0AtUteZLUTt9BfbYqexjztRA7sNTrD9ycmehIpdN5zdetaX6GJk4ckMpqC5qvjlN1BRRbULqWjLo6f2tnRtrSUFnIAAE1kMADL1BDE2HF0VxcuTkzjNv753fv1N38jhc4nyknV+Y5mZM2FwyR2N1slyxJX0tNP/N0Oqi5ljdUPEycBpSU0fMSx/cxDtXdQBDWyDgBQEw9JAZ2nnaa/+r+0+d/mhr58atew9Xm00Ol3BWJkgyLaO5vKCOPuGp7i6Mp/branTIlM3bUyTV+tfei+ATm+1pVOZkK1OSP2ZqT58rLT/rbZWYk60KNrZVMB+ltiwo6KF3ro6c3HGmUKEhCoAAEPCIABh6mAz96pUvn37zk8YjrMMlcjebKfn49iU6IomX1CXz1z2gqnQ5y4WKTflE6PyBkrZYp1RL4mrN1KbWrp0NVSubWH6JgW0WOai2qXqBrsdfuRLFyVuzgwVtUAUEgIBXBMDQfWXo//zv//nL8fZf/Ovpv/rN/8pnvp579/NHX7xIQb/xt1odLmEtXM6czYRNHyM7v3/nwrWv7VTO8WeBLO36lihWUqlIm+VytrYeT/MnX9mWlqDpKGqxNJ/MrFFdpRi9rgwo1fv8uf0oTlZ4WKFUGgqBABBYAYFKDO0EYmQ7R+A///t/HvnVbx/5659FP/rJ93/80x/+5iyT9C9//ym9KrO1c6Px8w8cLuGskyjNMnnzNCWG1XRp2VSxbLYM5vWuqJULX9vSiJRUbFtawjf75ETRUqyR0MX/DFcXyufqpHeujm9fmtsCFUAACHhGoBJDe7YB4msgQNH8T//5RUXP5uf7P/7pE699SFIu37y7wiNgFS1wuIRJ942r6tRC3taO4uTiF/fSNH1w+C11ieLk9v2Sr0gaShVkyUlFwAvX0IqDefebRlC2y80Cs0GqW+DuZUHF8ftp5qDqR8kqUvHO1SqooQ8QaA4BMHRzWLYiiaL59/5tGv35MUPQ0Q9+8AMmS69WNMYldllrd5zVcFTOPERmX47KcWzWlfrRMpyAoBIjmZ8Uy3XW6PDaOyfKK3ALhTeG6kItK1T+/Hd/jOIkfv/6Cn3RBQgAgfURAEOvj2GrEiiaP/Kr30Y/+gkz9N/+w4l2diOD5ZJWfdC0smBRpXeunjr9UdMjhjwgAAQqIQCGrgRTOI0omj/28mVF0noZ/Td/9/RTpz868/GtFowMlktaGLs/FcGiSqeZNf5GgD8kIRkIDAwBMHTPHMrR/K3ZAT2zfXRr99UrX7YzDNbejroN0RIyqvQFunau/zbE3RgmEKiOABi6OlZBtOw2mnerPQgHeDAiZFTpnatn3t7zMG6IBAJAYAkCYOglAIVW3W0071Z7aL5oyp6QUT2/fyeKk3aecmgKT8gBAoNBoDZDy2iSXP+aslGcJNfV9yg4+2f/tZNoZsuVAAAgAElEQVR7ulg/NWu+8JShR8/hZs/yDgZRzwOR+HtWVSK+W+0lBg2iKHBU6WYK/YEPAm8MAgj0BoF6DB3FyTNvq/OhaXxRnNAXnomqedAPDr+lZ0y4RL+56ry6qj9NYb7RaFsitRCBbqN5t9oXAtPjysBRpT/5X1+41mOIYToQ6CcC9RiazotlhuYhO3xM36ng2nkJrKHnIbOgvNto3q32BbD0uipwVF+98mUUJ3jnqtdzDMb3FIF6DE2DLDL0dyXPn9vn2mOndt2vHIhdbvmRCT6jqKfwtW92t9G8W+3to92OxsBRpetv3jBrBxNoAQJAQN04XoxCaeyQDE1/vcXP67vf3GeGps846ZvPIrnYCtRaBEo9Yqs9p7rV7nlwnYkPH9WnTn8UxUlrL/V15gkoBgKBIbAWQ9Pt5zMf36LTBinQyN92sIahJStjl9viUznVbTTvVntlkBY0dL8BqiZk1w8rho/qry9co2dQFiCLKiAABBpHYC2GLj7CTfYxSVtzwdAWi7VS3UbzovYjJ9VD+8dO7c5zPZ2+cOTkzsJhu8S5sPE6lXlF6uCO8XgkXzLIN1hHVeW+RVQrd22pIV2LP/rixZb0QQ0QAAIagXoM/ezZz5h95atWHGKKiQxnw9C0btYRMTsgoesFTM8mAiPcid2OdqJnKqR7H5wuZuXNkYLxrfFiThGdrGXO1yKjcg0KdnopcFD1omNtobRP5u/YtLUNhAAgMEAE6jH0PAA4xBQTWRfD0GlKL17xoQ+dbzHOG1Og5YxwJ/Y52jkrE2SYZOgyU80BVmqPWU8OeT6VeJjQXMBp4pxORrqZWfOWFqbZa3yqpeltBPKBV9okc/60peiCJWWmN17G6DUuuUGB9M4VPxDaoGSIAgJAYB4CTTI0L5Io4nB2nm6Ur4BAt9Hc0S5dzJR8fPsSrbf4CzYlw5yOmT11rVy5KprMqFUxK9GxuMRbXmgZXKesQM3UptYSs6FqZYq0pMRwH0UOqj5UrC/zzMe3ojjhY8jXFwgJQAAILEWgYYbmMN2LoLMUnQAbdAuso52y/JsomUCTM+H8/p3z+3cuXFNfnct+clSZ50VVZda+mjB1Jkecht/LCrXk3BaNZeKcIlksdOZkGnP9/u+g6lfZqtLvPjikmxr0kaJVxaAfEAACNRBomKFJswzZNWxB0woIdBvNHe2cdRKlWbngpoESmboELNiSGNVtkKod8rmF+e5KkaRiu0QWG9oZn2uRtkEFZzTUhOFqSJ4vMfTO1Usf3PSlAHKBABDII9AMQ5e+bYWv7eehbibXbTR3tDPpvnH1QC6aozi5+MW9NE3p63LU6/b9wyIEhj3lytVuSus7ykyc5quxloNVy2zPurQw02cFqlbUQypUzUpZv2ivlxIHVS86mhAav389ipOf/+6PTQiDDCAABJYj0AxDL9eDFg0h0G00b0y7XcESAZvnBymniTT3TJhe2o7H9KAYb4Irmi0UyifFzA1to46fFHMJmjpp7VnbzK6G3LZQTGOoLtSyfuXs4JsoTo5uZW/WrS8QEoAAEFiMABh6MT7B1XYbzbvTXqTU3E3l4PxUx6DuUK1jpW5Lu2XTT2/X7okOQAAI1EcADF0fs057dBvNu9MOhu502hnl9EUEvHNl8MD/QMAvApUYmuIyfoeDgN9JMV86GHo+NqvXdIdqbZvfmqkHDh5/5UrtnugABIBAfQQqMXR9sejhC4Fuo3m32n1h2rXcHqHK71zRQbRdIwf9QGDgCIChe+bgbqN5t9p75qrK5vYL1aff/CSKE7xzVdm9aAgEVkcADL06dp307Daad6u9E8BbUNovVLd2bkRx8vSbn7SADFQAgQ1HAAzdswnQbTTvVnvPXFXZ3H6hyu9c3X1Q8oJ75UGjIRAAAssRAEMvxyioFt1G8261B+WIBo3pHaqPvXw5ihO8c9XgHIAoIFCKABi6FJZwC7uN5t1qD9cr61nWO1Sfe/fzKE6ePfvZeuNGbyAABJYgAIZeAlBo1d1G8261h+aLpuzpHarTT29HcfLYy5ebQgBygAAQKEWgNkPLaJJc/5qyUZwk19XJRZz9s//a4Y82lyr2Vag+GGmOF6yqwxyVlGtf+omMXItOMhL/9g3oRnuZT813PO0pVvr7n+R69h0n2oeqhsZuUK1hoNv07oPDo1u7UZzgnSsXGuSBQKMI1GPoKE7oIHeyIYoTOoqOqJoNe3D47a17D1tk6DUDMRiaXbckUeQSOpHw2KnsW83UQLqeQvmRkztLRFeqLjq6WCK/BlpaW0lTm42KqLapfTVd9M5V/P711bqjFxAAAlUQqMfQdMks4y/pcPiYTjSqor6hNmsGYjB0VT84XEL0LFmZ0zRJZLY4bapqte2Kji6WgKEtXv5SL31wM4qT0Zmr/lRAMhAAAvUYmvAqhtrvSvhTvVGcHDu1W3JxbQ8sGk/1sYLZZrSMsbk2pE0dC0g/5uQh3sSmnn8Y806naiHEWWm505Amk6yHESQY2nThQ5BCmyIOR7ZsnqOdszIhJwmXO3YKxPP+Mj6WLjc+dRxNIkV363ou5ISjP6zsPJTCsjJvzf5X96M4OXJyB+9c5YFBDgg0icC6DE2r5+JTnYVHPUWsnI41NVKUPjtm9rQRVsVk3UbRs+FRGraQY9vPKzSiFe+SGH37kg4WVElOcSIr0kyd19wk7KvL6jaaO9rltRqlozg5vn2JTkDi5xJKRssUPR2PRiMC2pwVzc3ZrcVEsU3p0pk7cvsQEw6qIZpYZtPjr1yJ4uSt2UFZJcqAABBoAIG1GJpuP5/5+FapITJ86zUzL3UFM5qkkmDWr3b9pEqIO1mDjLmc5oQI0/m+hhHKWiqm11pyFCFbsvbuE91Gc0c7Zfk3UTJhxIT93V7o+f075/fvXLimniXMfgzU6kpsOtEUbYrIh9kk4OsqJ2Hk2Ks04XpbGKgT2XpKOKg6tcFmnz+3H8XJL3//abAWwjAg0HcE1mJofoSbUJB3o51nxzT7OlyrNy9dhs63ybOs1iJjLqc5IcJ0vq8h4bKWYOjKs9jhEs46idJs7oot3dO0/Ae9VTKbjP5pygRtHUdthE8t9bLF8xw6j9G5Y0AJhisgmyqYQu9cHd++VKEtmgABILAKAvUYmk6HpYAiX7XiEENPenMDYZHaU6aoaQqJNJ1dbqdNcZdblWQ0bkXOC9OmpQ3681qSSLvxrXo4thi7u/2foe7EDEc7k+4bV9WhhLytHcXJxS/upWlKzwxSr9v3cx+JVIws9rfH43/Mpge7SPnAIVqu49HLEk4XE9w+xISDaogmzrGJHtS/fPPunHoUAwEgsBYC9Ri6iqrZwTdbOzdKWmrSo83LP/3nFzn62jjsbHQLHqZebsF4PDYkqqg1ovU4R2e5bc7XBqLWLsjMAlvsr+JJsRIPmvfdS6tqF0rHy7RaXmtvqhecHYZWPjOOJoXzHOp2rG1eix36y9B0RV7yWGiL6EEVEBgwAs0z9IDBCmFo3UbzbrWHgL8PG/qLKr1z9dTpj3zAAplAAAiAoXs2B7qN5t1q75mrKpvbX1Tp0ZMjJ3foy0WVR4yGQAAIVEIADF0JpnAadRvNu9UejheataTXqD7x2odRnMx7oaNZoCANCGwaAmDonnm822jerfaeuaqyub1Gld65eubtvcrDRUMgAASqIgCGropUIO26jebdag/EBY2b0WtU6Z0OvHPV+KyAQCCg3o5ZjEKvY8fiofW0tluPdKu9py5banbfUX30xYvOpxGWDhkNgAAQqIIAGLoKSgG16Taad6s9IDc0agqhevnm3Z5+45reueIv8zeKDYQBgY1GAAzdM/d3y5Hdau+ZqyqbS6j+yTMv/Ok/v/gX/3r6r37zv/36BsirV76M4gTvXFV2OBoCgaoIgKGrIhVIu245slvtgbigcTOiOPmTZ1545Fe/feSvfxb96Cff//FPf/ibsz0i6Vv3HtI5pHjnqvG5AYEbjgAYumcToFuO7FZ7z1xV2VyF6rP/oejZ/Hz/xz994rUPKwvovuFTpz+K4uTVK192bwosAAIDQqA1hpZfZxwQfq0PpVuO7FZ762C3pDCKk+/92zT682OGoKMf/OAH/M3zloxYT82vL1yL4gTvXK2HInoDAReB2gxN21nHTu2SJArZMprQx/SPnNzJqwJD5/FYNdctRxa1rzofnPEvnh6Lax1R/ctGcfLIr34b/egnzNB/+w8n+vX+Er1zdXQrCwv98wEsBgJBIlCPoSkcS1bmtHO0USGUDzzItubcArCtaVaKHO1rzAfH7MXTY3GtI6p/WUL1h//+Fi2j/+bvnn7q9Ee9+0rX8e1LdBZ4/xwAi4FAqAjUY2gO0DJBQ5MMXTZYDrL6dCI6psqedjWeOidI6+Zlcja9jJHvBAhHO2dlggxbNh/MAVbqQLLswCq1gtQTw+ZV1uZ0LU8keW60lNYJMGspJfTemh3Qi8VHt3b7eEP3l7//9Dun452rtaYCOgOBPAK1GZq7cwg+vn2JLp+LayxurOPsaDJTnJwdImkPf1SV6rDA/CGQppmQgWRhFdsyJMzEpJfmgExHcVJpPghf6+6Sd3lMXMgJycoi7UpjCf1IOKiy0f16NPrMx7eiOOnXA24MNRJAIEwEajM0RROOKRyjmbBpp+v8/p0L174WY1ZBdjQy5zk7R0Hbo52Jl4mxRW8kDQKMvClo9X9Hu5wMPAHIIM6Wzwe9fcKndpsLODMWu2wuHvNcxtauNCOnJ/87qJLV8fvXj27t9uidq7sPDumux/5X93sCPMwEAqEjsApDy7WyjNFczoVi9CroKormpbFcTpt2s8mIFtoidps6/K8RKI3mrWHjaOeskyjN8sUcW6uJlTe2jc/txNjT00GslVXPMobWEoU01tCPBMMlzaUPdT3+ypUefWiM3rl66YObciBIAwEgsDICtRmaNL1x9UAukqI4ufjFvTRNHxx+S+EmipPb9w+FWVlgFfFVc/ZkJtqk6mb0aDxWNJ0rRoYRKI3mXOs74Whn0q0/HzJL6Zosx7s8RRTlFtfQ6pZzdplXmEFGmm8YGpbvoErS7z44fOzly1GcPPfu5w3r8yYufv96FCc//90fvWmAYCCwWQjUY+g1sOG4qx/qocBLqx56xcSsrVXUNek11A22a2k0b220jWlXbs45PitQrjePfYlrNVGr2TzrOh4ThRektQZII4rmoXp+/w7tG08/vd2IIt9CZgffRHGCd6584wz5m4NAawxdFdKeP/RTdZgrt5sXzVcWWKtjt9prmdqjxgtQff7c/nPvft6jje4zH9/q1wNuPZonMHUDEQiMoXu6TdnixFkQzVuwolvtLQywExXho0oW4neDCHQy06C0dwiEw9C0t4k70EumULfRvFvtS6DpbXX4qDbITBAVvrt7+5c0QMPDYegBgutjSN3+eXer3QeeIcgMH1Vj4V6a4t+6CBgwQ5h6sCF0BMDQoXvIsa/bP+9utTtQDCZbEdWXPrj59JufdDJqY+G65ASCT9M9A2YnnoTSniEAhu6bw+KE33Fq33QEFx+YV0F1/6v79E3Q+P3rPmxYLNNYCIZuAAED5mLIUQsEFAJg6J7Ng27/vLvV3jNXVTa3Iqr0Wc0jJ3fa/9CYsbABfsIy2oBZeX6g4QYjAIbumfO7/fPuVnvPXFXZ3Oqo0ofGHnv5csvvXxkLwdANIGDArDw/0HCDEQBD98z53f55d6u9Z66qbG51VG/de/joixd/+ftPQ2Bo5+xRGoXzO033PjmYYd0sEaju7sozCA0HiwAYumeu7fbPu1vtPXNVZXNrodrJ90CMhXYFWYWei70kUdVPvz6OnpzMrA1KwvSE+r7c6IVZWlbbzpPnsxdGRcPmqzawVJ4faLjBCATF0Pxl0A12yLKhd/vn7Uf7Ar8vqFqGlK13haiPhIb0ZVk/qNrxr58yFlp2pJIqv+szsdWS71vk4Ne1J6l9sXaenEbKS9WVFrrqDJjruwUSho9AbYama+djp3YJG/4TZaiObu1GcXLk5A6XVE64kbRyxw1q2O2fd1F7E/Nhgd9Xq3LmQ15Iyeks+QZOb//ZIqr+ddbTYCy0ZBPFyS/O3XD+FQv1ewe2V55x65YX+U+WyHRdySu0L1VXWugKN2DWcwFabyYC9Rja2dpyjpt0svVfCuo4UPZiBnT75+1ob2g+LPD7alWOJ3NC6MOy+c/L5ho4nVvIOqhW1xi/f/2t2UH19iu3NBZasimS8S/O3Yji5O/fuSZp22Fo/dV9EiLIbPbCz/7lNUXears4+xlPbbPx+MkoOjG1+9hq6RyNT/DpK6PJe6mtLZGzRK+zI23NODFVVdrUid5OjyKjiw193ajWVlHxs/+hT2AzcE1P6H34LGvAXNkb6LhBCNRjaJ5bMkFoER9zuQOhPTFQnPBbOJGIAyUnROtUn03Jf7+Ogo3JzkO4HQAc7ZyVCbJk8XxQbczJZqPJJDuiShSabWgxE0x7XXWWo3O2X52r1SaYkpx8dXCW/rKspWg7Dbva+mb0ajmRXr569MWL+1/dr9VxhcbGQkM5+rMbkokpXaRth6HVbePx64qMpydGoyc12+3NJpQQW9b2zq4qpGaGCP8gyE/QvGXoMjmL9NpB6SW+kDk9YfnYmK2vFQxtZzfFuQsn9A1y6pLuiesDpcuAuYIf0GXjEKjN0IwQh+Dj25eOb1/iLCW4WZYQR1aJJFVyFC4mJENzrTp/cGO/393tn7ejXfqaJ0Cl+ZDae8GaScmfRRdzCSfY+6JESTMzIpsbpfLpAHI6fNxQtZqDors7cdvIO6hWV/nU6Y+iOGnhQ2PGQktmVFLld25ne/bCSD3VtTcdPzmZUvqdyUg//6VYmdasSothNcF5moNH6szw94xMt1Y9R1YqZ4HeuQtovRpQLFumpVKhWYLrIRubwdDVJzha1vxiifMHSdvahCIH6ChOzu/fOb9/58K1rwXAzMuCXe3qxQnQMmKatFkSbfgq2sRKAW2LSUf76vPBLmEFQZa4eIH3TVVu5U1RdaoW6IayJQHLYqUte15MiGoRTFbloMrlSxP7X92nxz62dm4sbbxOA2NhjqGZcjihg4BtQ+tFrtWJ9zQfvz5WpPXOZPRPU8Od5czqEmE0Gj2ZrcJ5/9lZyJYydDpfbwlD2wsFbfNqDJ3tDZgdAguLAXMdh6DvpiBQew0tmdi58exkqSUDScHRhkgbIHk1w4GSE074DukBXB5Yu4lu/7wd7Zx1EqXZ3Hyw82Cxi81MsLOF4TZVGUPn50apfL1wz67wchd6QhSLbzHBcK2g89UrX0Zx8ty7n6/Qt3oXY2GOZvLUq6qiOLlxN/f2c5GzFWOJ/e3x+B/NmtjZnTYLUPsiU8aU2lu0jJ7HnVF2G1uw9Xy9dlCGj+UyvcKGtr2MkPbo1fzoxJh2CMR1gAGzOvxoubkI1GZoguqNqweSqqM4ufjFvTRNHxx+S/MvipPb9w9zuKqgOR6PTCTlqKiCr7OGVidR2uWNreWtzJzgjcp0++ftaGfSrT8fSnehVaFd+iq/8ixZUEXNih3lHWotlYVlM4anmVvR8oxyUK2rPbkuN6vq9q7U3lhoyaxIvWUrZsXZLpEr1jSvNct07kkx08CSn2TK9yaj4jvQgh2VWPphObT7bbKOXkGfylrbPdLrdSFZ2JPtAOa3wUWhwkplzd1oxsGAWQl5NNpwBOox9Hpg6ROgDUGn6pkd/VekaNthaB2Z6U9sPLa3GBWXmx8rZz2j+ta72z/vJrVnwSzKPcnlulhwp1tlVsQ0Ewq1ptrKF7Iyr6tOursJrNNOpkOTqPoZgLHQMjQ/8URV834zLW1mwtxNL8HNj6MgdWgItMnQQ8Ouk/GYWNmJ8rRb7d2M2b/W8FE1FuaYZhCkq7bWxY9zB3q98fIt9vwa3YDpf2JBQ/8RAEP3zIfd/nl3q71nrqpsboOovnrlSx+f7DYWrsdYeaIaBMHPA0Tvw/Nmfn7gBszK8wMNNxgBMHTPnN/tn3e32nvmqsrmNoXqc+9+HsXJL3//aWXNVRsaC+cREsprIGDArAo+2m0yAmDonnm/2z/vbrX3zFWVzW0K1cs379JX3hr/0JixsAYPDXqJvBYOBszK8wMNNxgBMHTPnN/tn3e32nvmqsrmNojq1o769GbjHxozFq7FTOBsQsCAWXl+oOEGIwCG7pnzu/3z7lZ7z1xV2dxmUR2duRrFSbPfMDEWgqEbQMCAWXl+oOEGIwCG7pnzu/3z7lZ7z1xV2dxmUd3/6r6nXW6yE78bQaDy7EDDjUagEkM3MiMhpEEEupqzDQ4BohwEuvJpFb1kapWWaLMUAYC5FCI0YATA0IkTKHuRZf+1nOgFOD01smVX1lJHkNbqgsbzEACY85BBeRGBJQxd7IASIAAEeoRAI98EBak06HGA2SCYgxcFhh68izHAzUXg6Tc/obPm1oQApLImgLI7wJRoIL0YATD0YnxQCwR6jMDz5/ajODm+fWnND42BVBqcBACzQTAHLwoMPXgXY4Cbi8DdB4ePv3IlipNn3t5bBwWQyjroOX0BpgMIsgsQAEMvAAdVQKD3CPCHxta5IQ1SaXAeAMwGwRy8KDD04F2MAW46Als7N9Z8Q7oxUtHHfOaPAE/p4NDNOU62MTA3fV5vxPjB0BvhZgwSCKyDQJFU6APgx07tklhqEMUJazm6tRvFyZGTO1yiEmDoFEe45mYEMosRAEMvxge1QAAIuKRC9CxZmdNE0jIrabsUSqyhS2FBIRBI0xQMjWkABDYLgVv3HtYdMDEu9+KsTFCtZGhubxNiDU3EHJkf7HJblJACAgYBMLRBAv8DgaEjcOvew9GZq0+d/qjuQJmJqaNcFjMlH9++dHz7EmdlG6uOGVonIk3LImkbDjjlgDngkWJo6yMAhl4fQ0gAAv1AYP+r+4++eDGKk19fuFbLYodUKMu/1V6cvgNNDM3llPg/L160ugxDS1bGLrfFBykgkEcADJ3HAzkgMGgEpp/epge4ar18RVzLwHDWSVCWV89OVnUHQ+NJMZ5GSFRAAAxdASQ0AQIDQuDZs59FcfLYy5erf2iMmZhgYA5+4+oBpZmMZZbW1txY9TUMTetm/drV3mSk7kXjPvSAphiG0hgCYOjGoIQgINALBO4+OHzq9Ee13pB2GHreMLlZMZF1MQxtyNo8JwaGnocpyjcbATD0ZvsfowcCFRBgxl3clprxotnJLu67ObUVwdwcQDDSBQiAoReAgyogAAQUAhVJhSlZ7nUzYQNKQqAimIALCOB9aMwBIAAEliNQkVSYoUmik12uZjNaVARzM8DAKJcggDX0EoBQDQQGjAC9If3SBzcXj7EiqZS+bXV8+9Ji4ZtWWxHMTYMF4y1FAAxdCgsKgcBGIPDSBzfp5avZwTcLBgxSWQBO3SqAWRexTW4Pht5k72PsQCD9+e/+GMXJE699uAALkMoCcOpWAcy6iG1yezD0JnsfYwcC6a17D2l3+vlz+/PgAKnMQ2aFcoC5Amgb2wUMvbGux8CBQIbA9NPbR7d2F7whTaSC3w0igMkHBKogAIaughLaAIGBI7D4+2JY9jXofoDZIJiDFwWGHryLMUAgsC4CIJV1ERT9AaYAA8klCIChlwCEaiAABEAqDc4BgNkgmIMXBYYevIsxQCBQA4Fb9x4+e/azW/ceyj4gFYnGmmmAuSaAG9UdDL1R7sZggcASBJ5+85MoTn7+uz/KdiAVicaaaYC5JoAb1R0MvVHuxmCBwBIELt+8e+TkThQnr175kpuCVBiK9RMAc30MN0cCGHpzfI2RAoFKCGzt3Iji5OjW7v5X96kDSKUScNUaAcxqOKGVQgAMjXkABICAi8DozNWjW7vn9+9QBUjFBWiNPMBcA7yN6wqG3jiXrzNgCi747RWBdRzUVN/9r+7zArr09EnaCT92apc0MiBswNGtXfriN5cgIbECGkCgCgJg6CoooU2GAAdiJPwhEOBso8GyYUTPjABTODfjKi7hvkgAE8yB6giAoatjhZapCS57aYp/zSNg4A1upjmGcVYmyOgoTpiwy4YxHUejyWQc6Z/RZEZtpllBFI2nukQ3m05Gutl4ms6yZMRdbJHpU6YuxDIGLUTjYFNgCIChA3NI2OaY4NI8OYHy03TPwBvcJHAMIxomK5mSj29fohM4ljG0oWFFyxkhmwFrYlasrSmb2FgkdTF14ZaqraVtIyjk/x0wQzYVtnWOABi6cxf0yQATXMDQXhAw8AY3JRzDKMu/iZLJaCbsKE7O7985v3/nwrWvxXgEsyq+NdxqF9FMy6ZKNuM0r6lpMe4QvdAXYNIBM0ALYVI4CIChw/FFDywxwcULP2EZbeANbiY4hnHWSZRm5YJbL44L1Kvoljh2bzKqztC9omXhUkZJlCEJBMoRAEOX44LSUgRMcAFDe0HAwFuKfZeFjmFMum9cPZCL5ihOLn5xL03TB4ffUpcoTm7fPxSmi3UzL4i5TFF1NYZWfXkBLsT3IemA2QeTYWNnCIChO4O+j4pNcMnxk/NkL4dmmUjTvU8OZlglL0bAwBvc1GjOMGZjutlMfLyXPQc2Go8rrqHTVDwpVridHRx+OYOaAzMnFplBIgCGHqRbfQ3KBBfL0FXoudhrMVEtq319HD05mVkbVPvpCXVHcvTCLC2rXeXJ8zI5sxdGRdWrCM8bbyQYoHy5b2W5wRq28og67AgwOwS/d6rB0L1zWZcGm+BiCYZKqvxexrtW5rKWRe58XT8WTBKKtdUly5a15NRqLLXk0gbeLl1cqjtYw0qtDbwQYAbuoKDMA0MH5Y7QjTHBxfJKFCe/OHfD+Vcs1Hcrba9lHLy4ZZEOZYlML5azuLaWnFqN5+o18AY3DYI1LDikKhgEMCuAhCYZAmBoTIUaCJjgYjmmSMa/OKfOXfj7d65J2nYYejqOxlMSIrht9sLP/uU1Rd5qMzn7kc3G4yej6M9A0XgAACAASURBVMTU7mOrpXM0PsGfuxhN3kttbYmcJXrNbrO+gNCGTTNLtOQ9Ifw98wmNaDzVZmSv/by+zP4nR+rBZQPg9ITemc+yBt4aHmmnabCGtTP8ZrUAzGbxHLY0MPSw/dvw6ExwMQSjP7IhmZjSRdp2GFrdNh5rMpueGI2eJP6bTSghtqztfV9VmKfJP+h3dAo0bxm6TM4ivXZQhqHpxjbd5D4xVfxtridYTkbqpjxrYzi41H7RV1wxKO0G3oa9tr64YA1bf2jtSwCY7WPeX41g6P76rgPLTXCxZEYlVX5r2jMdZy+M1FNde9Pxk5Mppd+ZjPTzX4rViA5VY8NhDgWqlaghbEGckkRL5SzQm3GtsZDJWMrkQiV8jgGlerljJs3wvQaBkTHwduDZxSqDNWyx2WHWAsww/RKmVWDoMP0SqFUmuDCNqWUfEwwnioWFkvc0H78+VhT1zmT0T1PDnXqLeylDR6PRk9kqPMeggq3LmXK+3loMrRvPJk+qXXa1ZS0uIMr1igbpHu0WmD2DHJgaqOC8b/wenGF9NAhg9tFrXdkMhu4K+V7qNcElRypMzJyI4uTG3dzbzwWG1iwl9rfH4380a2Jnd9osN+1rThnb6Vdr39NKJf9xulTOAr12UAtl5l70MizLSomt5S530X59g3x0Ykx7BuLKwMAb3NwI1rDgkKpgEMCsABKaZAiAoTEVaiBggoslsyL10v1UZmtKlDRTa03DdjKde1LMNJCLVJvWj2u570ALslRi6Yfl0ONjJuvoFWSZWxZbjUY4vX6tZGfL/ezD0nRzvUSv6WhUqPbU2JTgPnSNidjnpuaPqM9jgO1tIQCGbgvpQegxwcUyNPMKVc377RA2sub+egmSAc4U4/cATeufSQCzfz7rzmIwdHfY91CzCS45XhkE3aotcfFjb4R7GR3fdBcLaL7WCXBeGL9b02RJcv1rykZxklxXJ1lx9s/+a2etO+v2S91Wdd9TErq+jwX2+0YADO0b4UHJN8FleAzd2ojoRWqzzd5Pho7i5Jm36SFBNb2jOLl172GapkTVPOMfHH57697D+gwtv93NwoaTMH9EwxkRRuIPATC0P2wHKNkEl9b4bLMUGXiDmzmOYbODb+SZ0Gyuw8d0whXXVk6AoStDhYZDRwAMPXQPNzo+E6k3izi9bHTnV8+kwsDbqM+aEFZqWHFx/F3J8+f2SWEUJ8dO7cbvX3f0Z4/U6dfUTJU520q9umbr9ZnRxNb2BGnVhRlcFdNPn86KLgXTQIH/gUAOATB0Dg5kFiNgggsY2gsCBt7FTuigttQwydC0en727GeOcVGcFAt1G6ZZRc90CKXpy1WCjfWTddTAJEWz6TgvwUgK8v9SMIO0FEZ1jwAYunsf9MgCE1y88FNrS9VgFRl4g5sRpYYxQ9Pt5zMf3yq1m5tltXaRrFk1vzzWbQT12vWy4eXUsLFdQOtldH9W0aVglkKHQiAAhsYcqIEABRf89opADX+01bSUVJh6+RFuMkfejXaeHUstH+9NRrUYWnUdTWb0WymyotpCoSE9pWA2JBtihoYAGHpoHvU6HgSXzYTX8fuzZz+jEuJmTnMzetKbsvT+VYYbL48Vv9LOdLVdbqLk0Xg84sWyWoz3aHObZw6jxCVIAIF5CICh5yGD8hIEEFxKQGmuKFh4VzBsdvDN1s6NAjbmoTDFtUyvduOb6DfLqwxTepqmui8TdLaMNi+xy/KC1qAKVgAzKPthTJsIgKHbRLv3uhBcvLowWHiDNcyrOzwJB5iegB2kWDD0IN3qa1AILr6Q1XKDhTdYw7y6w5NwgOkJ2EGKBUMP0q2+BoXg4gtZLTdYeIM1zKs7PAkHmJ6AHaRYMPQg3eprUAguvpDVcoOFN1jDvLrDk3CA6QnYQYoFQw/Srb4GheDiC1ktN1h4gzXMqzs8CQeYnoAdpFgw9CDd6mtQwQUX/dQvPxNcbdj0OLH77C99AMMtrSaxqVbBwWsGFqxhxsA+/Q8w++Strm0FQ3ftgV7pLwaXIyfV8YLHTu3SOKgBf8siTdOjW7tRnBw5ueNloGBoL7C6Qot+d1sgXxkBgFkZKjRMwdCYBDUQcIIL0bNkZU4TScuspO0aKptvijV0bUwdv9fujw4CAYApwEByCQJg6CUAoVoi4AQXzsoEtZcMLSVQWp9JZDanaX+ZcpSmr1AUS9RpR2fH5hsVKifX0Nl3LlR1JppKRqPsBKSsNMfQUmHuvKWi0f5LGEb/quppCNawesMIozXADMMP/bACDN0PPwVipRNc5LKYKfn49qXj25c4K9vYUQhmFTeAdSndCubSjEIl52ZpJY3lEBnrvtyVaomubSF9mkofbZg10L2EAGtmyykH3pa1L1AXrGELbA62CmAG65oADQNDB+iUcE1yggtl+XeapsTHxNBcTon/8+JFMTCmVkGdRJK8RKYlLdUbUqacs0oeTWY5fmWRolSIsWtoUa8PYlDnEwsbW08SUK2rXa6wa8Pktz+XWxt4i67BDBwemJdDAAydgwOZxQg4wYWzToKyvHp2sqRCs+NoMtUb3mLta7jYGCKoNSsiXiWWzqSAoQ1cfv5n/7L4dp8QBEMz8EhsFgJg6M3y95qjdSI1c/AbVw8ozWQss7S25saZDZp69T1iQ8pExryOnU4mMzpkkG8ss/k5Zlb9TQGfp6BIn7jcpX+7hhbsT4WsmxW1mnDgbVX3QmWOYa0/IQiGXugeVA4XATD0cH3rYWROpJ6ngZsVE6JLRormsS5dk5G0eFRMsKi57yxqBTFnfKwrM85fxtB5gaondrmFg2yS/UhFnJUJriq/IMuEaa6dZE/7mUszcx2mfWddYCbDaDIZ8ywxhcZXZhaZvDU61BSDFqqBsCsgBMDQATkjfFMqBhdqxotmJxv+MLuysCK87ZvnGMae5ScPojip9IQgXUYRCavrJzelHwcg4rbVmpS50ND6dKxS03HHV1X1neGAWV8AemwQAmDoDXL2+kOtGFyoGTfm7PoGDFsCIxbaMB3D2KFczpxNCSo/v3/n/P6dC9e+FsOR+9UmrRjYrpwzzp1N7PnRioc1MdsFtFluC/YWWoJOMmhBWwnjwkAADB2GH3piRcXgQs1k1K7YsScw+DIzWJQcwzjrJEqzPA00aoZrVcak6zG05XJ2AxF3SQW3CCnBKIVkFGwJFAEwdKCOCdOsisGl9G2r49uXwhxUOFZVhLd9gx3DmHSLTwhe/OJemqYPDr+lLlGc3L5/KAw2rKyKOG03tPUut7v1LdbJqqXZ5hZS9Y3s0vJcozAyDphhGAUrAkUADB2oY8I0C8HFq1+Chbc5w5iVJUPLJ8UEzyo6Vj9znhTTd7FNG3NL26t/mhHeHJjN2AMpISMAhg7ZO8HZhuDi1SXBwhusYV7d4Uk4wPQE7CDFgqEH6VZfg0Jw8YWslhssvMEa5tUdnoQDTE/ADlIsGHqQbvU1KAou+O0VAV/OW0MuSGUN8NyuANNFBPn5CICh52ODmgICCC4FSJosCBbeYA1rEv22ZAHMtpAegh4w9BC82NoYEFy8Qh0svMEa5tUdnoQDTE/ADlIsGHqQbvU1KAQXX8hqucHCG6xhXt3hSTjA9ATsIMWCoQfpVl+DQnDxhayWGyy8wRrm1R2ehANMT8AOUiwYepBu9TUoBBdfyGq5wcIbrGFe3eFJOMD0BOwgxYKhB+lWX4NCcPGFrJYbLLzBGubVHZ6EA0xPwA5SLBh6kG71NSgEF1/IarnBwhusYV7d4Uk4wPQE7CDFgqEH6VZfgwojuMgvR5qR0tcf1Scj37FnCZvKav+XHmRYpquauBVahQFvieHBGlZi6+Ii9Y1v8WHRxY391A4HTD/4QKpEAAwt0UB6CQLF4HLk5E4UJ8dO7VJPasAnK6RpenRrN4qTIyd3loiuUV1kTcXP5mijYm1F0WDouUCF4fe55i2rWHlKLBO8Un0RzJXEoNNGIACG3gg3NzVIJ7gQPUtW5jSRtMxK2l7PnmLAlSUyXUsPGHouXGH4fa55yypWnhLLBK9U74C5kgx02hQEwNCb4ulGxukEF87KBCmSDF1ULchQRM/ZZEQLYTrvV59rJFfG4/FIL5XPmn1svbU9HmdHIGXnEuYF0ulIZoW9UK+oNAbkTlUqDqPpEoaxacHrynMM46xMkI7Fftdt9iajzCuZcw3akXFTdjDlhM+2mumO2rNuoTwXy0yWVKqwp1/pbZZF02OOXiltXSTTNGXQGpAFEUNHAAw9dA83Oj4nuMhlMYfm49uX6HzoRcGI2XA6Ho1GdGNwNqGE2LK2dw1Vobl/SEFW1ZmQLMLu3FOHde8lekmeNUBzh1HbKJKlwhx4S9t0UugYtrrfNXfmAbVo68OhqVIVZt619fMKjbzpWKcUoZoiQqvy9FCTp6CX50xD0DtgNiQVYoaJABh6mH71NConuFCWfxMlk2om7ChOzu/fOb9/58K1r61Vlo1HkykxsymSzKsXNZo23SA7ykVht3Yyo6WVYXCWY5SoYO7oVdFZtzdttLVSsjXfU8qB15OWFcQ6hrHHuZw5e7nf+bKK7KjmbuVQe+0l0voaymyUaHLNC9RKpBNNOt/M+N7Uqm4mrVXkKX8FCG0XBs0WIQUE5iAAhp4DDIrLEHCCC2edRGmWg7gWvKdp+Q961TObjP5pyrxYKXRGo5FdQdtgqkTLwFpgaLWGG01mZXrB0GUepzJ2qJPlckqUZnN+zztXScuXLGJK9qzqVu7lokBtsGk8v+NCvUaqWV1rmav/YpRWF4GeG4MAGHpjXN3EQJ3gwsH3jasHcvEUxcnFL+6lafrg8FuO3bfvH0oTFCOL/e3x+B/NMsVua4rwXRJkRZFIcuxWCbNeEzSwUC8xuu2o+jk7pnIMTacdeJsWv7o8x7A1/F66BV100zyHmjmS9zKX6hGWquAmLNl6efE0Y9T4GpJLVks4YK4mBL02BAEw9IY4uplhNhlcFPuZuCnT2bqKdi5NAxuRxfqJHghSTeQ70ByC5TNELIcKTTan16yjSIPWjyfFaN406Xd95UTezbY49HVQhjc9E1bubuFZ2cB25ysyxb5SRZZX+oQQ29HMB1nLaVfYun9KjYK5rjHoHzgCYOjAHRSWeQguXv0RLLzBGubVHZ6EA0xPwA5SLBh6kG71NSgEF1/IarnBwhusYV7d4Uk4wPQE7CDFgqEH6VZfg0Jw8YWslhssvMEa5tUdnoQDTE/ADlIsGHqQbvU1KAQXX8hqucHCG6xhXt3hSTjA9ATsIMWCoQfpVl+DQnDxhayWGyy8wRrm1R2ehANMT8AOUiwYepBu9TUoBBdfyGq5wcIbrGFe3eFJOMD0BOwgxYKhB+lWX4NCcPGFrJYbLLzBGubVHZ6EA0xPwA5SLBh6kG71NSgEF1/IarnBwhusYV7d4Uk4wPQE7CDFgqEH6VZfg0Jw8YWslhssvMEa5tUdnoQDTE/ADlIsGHqQbvU1KAQXX8hqucHCG6xhXt3hSTjA9ATsIMWCoQfpVl+D6jS4iO81+hpfx3I7hXfR2IM1bJHR/NlO00h8idsUdfF/P8HsAinoTFMwNGZBDQSKweXIyZ0oTo6d2iUp1IBPVkjT9OjWbhQnR07u1FBjm0pWlmnbYkipIryBjK5omGe/Lxh39WmQb6kOvhiPs7PISX6+wQKdjVYVwWxUPIQNCgEw9KDc6XswTnChME2FztlWxayk7cp2yhgq05UF9KqhA284tjuG+ff7gqFXnwa5lnQyVf58qlyDBSqbrXLAbFY4pA0MATD0wBzqdzhOcOGsTJAFkqFLbSqcGCTDJaX/wCcU6eMJdeFUnQcZySMh7QlF5hBDvb05Ho/0UUe22h4WXWpQAIUMYwC25ExwDOOsTFCHpX5P6UQy7UTtEeVW4yx5HFnmrvw8sbnM2UX3mpL8uWR0LriWnx1kVRCVG7HHDIPmUQdEDwUBMPRQPNnKOJzgIpfFHJqPb186vn2Js7JNmY1MzJyQ50s6hYaZVXSlCG5T+pRfir6q0Mbh8JnZ4OLAa4q7/98xTPqUHV3N76WHNxtnyTvH0zEfCanHzzOBE3KeqFMldXs7HzRTGxl27WyoWgmVotoD2QGzPcXQ1EMEwNA9dFp3JjvBhbL8O01Tjt0cuKM4Ob9/5/z+nQvXvs4ZrmIp/VAYleGS05xw4qkpV2HYMrA54dnUmqOmTZzO6Q8w48AbjoWOYexxLq/q97y/9ABdZ5lZIa/B5swTs1zOuoyn6irNOttKlsXCBNugTagZtDaVQldPEQBD99Rx3ZjtBBfOOonSLAdxZboNk7ymkeGS05xYlaE1ThTJLZN3A95yrYzbf/73//zlePsv/vX0X/3mfy/fvLu8p+cWbBjp4ayTKM3O8TtbLFxsZ4WptSVl88TWivYlDG0vBg398waMbW1EeP+fUfKuCQr6jwAYuv8+bHEETnDh4PvG1QNKU4MoTi5+cS9N0weH33LJ7fuH1lIOyyrIUpRU+58Zidpdam43h6HVRqXpZeO17JXplKsoa0ZgKcLqP//7fx751W8f+eufRT/6yfd//NMf/uZs5yTdmN/1Teg8K0pnWcdnnuFKO0+4iKYE75BTDzsfVA+qlD1UK55pbkU708EBsx2l0NJTBMDQPXVcN2Y3F1xUlFQ/8gUYFV31z3g8NoE3K1PULeOpSOtIrLtx5Be1LNPweDfAVdNK8EbP/oeiZ/Pz/R//9InXPmQBWZs4KfWFp9pSXWxSzYTjEuEsc1ciG7pyesk8EVNCPllmrtSMeH5SLK9AGcvXcjlRNYexcvNGwVzZCnTsBwJg6H74KRArEVy8OoLg/d6/TaM/P2YIOvrBD37AexV0p5+alfpCVsleZPbKtaW6vEIxYOEAc8DObXxoYOjGIR2yQAQXr94leH/4729FP/oJM/Tf/sOJ49uXvOpdKhx+XwpR9QYAszpWaAmGxhyogQCCSw2w6jcleN+aHSiS1svov/m7p586/dGZj2/VF9ZkD/i9QTQBZoNgDl4UGHrwLm5ygAguTaJZkMXwvjU7ePTFi1GcHN3affXKl4WGbRewYW0rHqI+gDlEr/oaExjaF7KDlIvg4tWtwcIbrGFe3eFJOMD0BOwgxYKhB+lWX4NCcPGFrJYbLLzBGubVHZ6EA0xPwA5SLBh6kG71NSgEF1/IarnBwhusYV7d4Uk4wPQE7CDFgqEH6VZfg0Jw8YWslhssvMEa5tUdnoQDTE/ADlIsGHqQbvU1KAQXX8hqucHCG6xhXt3hSTjA9ATsIMWCoQfpVl+DQnDxhayWGyy8wRrm1R2ehANMT8AOUiwYepBu9TWofgYX97OP6luP2RfAfQG1mtxg4e3aMNeDK8HrCulqGnQN5krgoVNHCIChOwK+n2qLweXIyZ0oTo6d2qUBUQP5vcmjW7tRnBw5udP0iN2AO19+vqU6Q2M8FocU5r/4PV+M/5oivP51VtJQNKxdv+c9mDN5QVWunevl7qZBEUzHUGSBACMAhmYokFiOgBNcKExToXO2VTEraXu5puUtVgzNdMhV/qir6qKWm7VOCwfedUQ129cxrHW/L3DQgioHg1zLDqeBA6ZjJbJAQCIAhpZoIL0EASe4cFYmSIRk6DlCzbFF2ZazCqDj8SjL2ROrxImU9K3q7Jwr8+Fqqi+01wcYqTZ8xpE2wxwzbCnanIUUdb/1zTDOQayzYscwzsoEGbfM75ImOa0TU3Pa2WSWjdP4VHrQequ304BB68ydUNwfBMDQ/fFVAJY6wUUuizk0H9++dHz7EmdlGzECRc98WqQuV7HXlHDsVnuTppB6cxUn8kdHZ+3tTUYd540MS8yGqpVUKUrY2HrSgbd1/XMVOoZJn7Kjq/ldQs1pTbvkIuUtSs3xYGaj7GucK/0Y8DRwwJwLOiqAQJqCoTELaiDgBBfK8m86G5HEceCO4uT8/p3z+3cuXPvaalKBOFscm0KOuflDf3lpq8O4XjhzBDeh2Sy2smX1eKoW0KZSErAsFiYI1caaTv534O3EhlKljmHscS5nzl7id0miNp3DfzrWM0O6yrbUzszc3NdpwKCVQo1CICARAENLNJBegoATXDjrJEqzHMSVDkGPRqUI08VaW8Jr32XtSxjaknwW5LOrBCHKWNPJ/4xbJ9oXKHUM46yTKM3m/C651qYl/mpzRV27lTL0IKYBo7QAcFQBAUIADI2ZUAMBJ7hw8H3j6oFcPEVxcvGLe2maPjj8lrpEcXL7/qHQVLrLzaSqqJQzqhfHcBWjC4snVZ1vr0vEHWrdhYVkdhgysNKFgV0kHXi7MKFcp2PYmn7PNk+s02xKXLqpwrke7PM0cMAsRxylQEAjAIbGRKiBQKPBRYVg+tGBOM+fKgSbH1Wt2FT9iBelsv4iimcdqMSI5+eM8grUqHlJlhNVA4+GmzYKb5O2NWmY8Us0Ho/FxZZ+SFA5kLynrDct2YPDmAZNgtmkkyErRATA0CF6JVibEFy8uiZYeD0bVrx28gpzx8I9g9nx6KC+WQTA0M3iOXBpCC5eHRwsvJ4NA0N7nVYQ3mMEwNA9dl77pnuO1O0PKCyNwcLr2TAwdFjzENaEgwAYOhxf9MASz5G6Bwh4NTFYeIM1zKs7PAkHmJ6AHaRYMPQg3eprUAguvpDVcoOFN1jDvLrDk3CA6QnYQYoFQw/Srb4GheDiC1ktN1h4gzXMqzs8CQeYnoAdpFgw9CDd6mtQCC6+kNVyg4U3WMO8usOTcIDpCdhBigVDD9KtvgaF4OILWS03WHiDNcyrOzwJB5iegB2kWDD0IN3qa1AILr6Q1XKDhTdYw7y6w5NwgOkJ2EGKBUMP0q2+BoXg4gtZLTdYeIM1zKs7PAkHmJ6AHaRYMPQg3eprUF0Hl0ZenHWFqI9L2k9N+oKuityu4Z1rY/eG2Q9xzzWyLxXdg9kXpGAnTp/EHKiFQDG4HDm5E8XJsVO7JIca8MkKaZoe3dqN4uTIyZ1aiuY0dslVNFtQJVqpZL6lOkNpPBZnVboNnN4+s0V4fWqrIbtomDe/S+/IdA1rA29aBDNwg2FehwhgDd0h+P1T7QQXCtNU6JxtVcxK2l515AtC9oIqR1uuJR1ymDvq0KFwp7fPrAOvT1X1ZDuG+fS79I5M1zM45NYOmCGbCts6RwAM3bkL+mSAE1w4KxM0HsnQZSOUwZfTOjE1p1hNZllHc86VOOOIzz2iDWpzChIfjWS62P1rUyKF6LOS9MGUlqILosqs91TGMHqSv7JYxzDOygQJX+Z3c0YZO8b4RRec5ePO9MlX2Vll+h5EfpJMsob2iFIjR/i3oGvl8TfakUFrVCqEDRMBMPQw/eppVE5wkctiDs3Hty8d377EWdlGWMUBV247a3akoKsCLqXsbWIdhG1M1tJYDiekQLVjrTvMEWKJeW9iN7qlKGGy/6QDr3+FVTU4hkmfsqMr+X06zt/yF1BbT7GLRa3d2NCTxB4w6qbsJHF1VR2s73YOmL7VQX6vEQBD99p9bRvvBBfK8u80TTl2c+CO4uT8/p3z+3cuXPtamDsv+HJ0ViFZRV9Loi71mhUWdRECzXLKHhc9R4gsVp2y58WEKGFxC0kH3hY0VlThGMYe5/Kqfrf8qTUXPWWZOO9uWy69Y9LSkdzS0VVxqP6bMWj+VUFD7xEAQ/fehW0OwAkunHUSpVkO4tpgE1tVhtOcSPX+83yGtnTKa1/R19YabEojuNLr/PCCzF4oGBFt/M+4taGsjg7HMM46idJs3u9KK/FydvllLouMOcKPdmLMmySmcbl/87qMgs7/Z5Q6twQGhI8AGDp8HwVkoRNcOPi+cfWA0tQgipOLX9xL0/TB4bdccvv+oRiJukdol6xiQzvjRsuyZRvUJjLrYF9YQ2vqzXPsQiGZWWwSSxf2tpJ04G1FZyUljmFr+D1TZyhV+aXgKS6QjuA0JxzazqaTpn+WoNQZXZVG2kIjB8wWNEJFfxEAQ/fXdx1Y3mRw4RXseDy2DK3efKKFbcbfFId1UclDQOJFqUwedaNlmhRk1LEQGekJSr4qyIlqEeYm4W3U7MYMM17gB8WyBbXwlARfpNldnJAMrTdinElS1NUoJisLawzMlS1Ax/4gAIbuj68CsNRzcJHBN4DRtm6CZ3hXH0+whpUMia+zSuqCKOoTmEEAttFGgKE32v11B+85uIChE95Arusar+09+71J29XKObfJ3aTwRmT1CMxGxgsh6yAAhl4HvY3r6zm4gKHB0Kv9TdlXn+3++WqS/Pfy/EfkfwDQ0CICYOgWwe6/KgQXrz4MFt5gDfPqDk/CAaYnYAcpFgw9SLf6GhSCiy9ktdxg4Q3WMK/u8CQcYHoCdpBiwdCDdKuvQSG4+EJWyw0W3mAN8+oOT8IBpidgBykWDD1It/oaFIKLL2S13GDhDdYwr+7wJBxgegJ2kGLB0IN0q69BIbj4QlbLDRbeYA3z6g5PwgGmJ2AHKRYMPUi3+hoUgosvZLXcYOEN1jCv7vAkHGB6AnaQYsHQg3Srr0EhuPhCVssNFt5gDfPqDk/CAaYnYAcpFgw9SLf6GlTXwWXgL0x3De/cadO9YepLYfM+RGI/7xmF/rUShXD3YM71MyqCQwAMHZxLQjaoGFyOnNyJ4uTYqV0ymxrID2Md3dqN4uTIyZ0mxgWGbgLF+jK8+X2xQxfX8jBkM83W9pPu3IYSsqVT1V62CGZ7uqGpbwiAofvmsU7tdYIL0bNkZU47R105HVcdRBARdlXjl/drCKXliuq2cAxrzu+LHbq4lgeRb7bou9z5liyg3YQDZrvKoa1nCIChe+awbs11ggtnZYIslAxdZrOOlZPsgGa7fanCa/ZjF0KmkI+lUgJNofnKo/3uo+1YpjjkMoYxNCMdwzgrE2TzMr9LN4ndae0zm1dZm9PnSkpylULyJ1wpI1QtzQErokSgUECt2wKdQWtLIfT0GAEwdI+d177pTnCRu9kc6ZB8wQAAIABJREFUmo9vXzq+fYmzso0wWAdPG0fdVP7g5+LRvyJeT8eK4KfjrJHQ0bukA2849juGSZ+yoyv53XWT8KMdLRdyQtKwImB7Sad6yWY5hjYiuQEnTE1Jd1nlJe2A6UUHhA4FATD0UDzZyjic4EJZ/k1PwZAhHLijODm/f+f8/p0L174WNspYadL5/cksmM8mIxuPZUuz1o70KlovqW1DoalHSQfecCx3DGOPczlz9hK/u24yDqWh2jUveVLWmnR+kuh+pirDa8/OmEUC5Sq91YnDoIXjX1gSLAJg6GBdE6JhTnDhrJMozXIQ1wOTUdWk88F3GUOXbE3q+N/jtTTjFprvHcM46yRKs3m/q5EJNxnXZ6XkU6ZYUcsL5fwkKcwlkq7l2JZlAktqW0KdUWpJH9T0GQEwdJ+917rtTnDh4PvG1QO5eIri5OIX99I0fXD4LXWJ4uT2/UNhb1nw1XcGM+K1AVStg6hQlWUbnKqwdOGTW3ILfb1IOvCGY7Nj2Bp+z8Zk3CSmASeVm+evofVt5rzruSfteJtLNC4uFVhS2xLeDpgtaYWafiIAhu6n3zqyurngwgEyfx9Rk7DevxZB2OxVznlSTBO4aWPYvCOA1lPbHLzr2VHo3ZhhBTdlBeoSzDz/NRqPzY0NUetMGPk4oRWav2xbLLCktjBuLwWNgenFOggNCwEwdFj+CNwaBBevDgoW3mAN8+oOT8IBpidgBykWDD1It/oaFIKLL2S13GDhDdYwr+7wJBxgegJ2kGLB0IN0q69BIbj4QlbLDRbeYA3z6g5PwgGmJ2AHKRYMPUi3+hoUgosvZLXcAOE98/EtfEq6WacH6OVmBwhpDSIAhm4QzOGLQnDx6uPO4X38lStkg/z96IsXOzfMK+wtCweYLQPea3Vg6F67r23jEVy8It45vPwalRwmWVVaJZshXRGBzr1c0U40CwEBMHQIXuiNDQguXl3VObylNAyGbtbpnXu52eFAmlcEwNBe4R2acAQXrx7tHF4wtFf/kvDOvdzCGKGiKQTA0E0huRFyEFy8urlzeMHQXv1Lwjv3cgtjhIqmEABDN4XkRshBcPHq5s7hBUN79S8J79zLLYwRKppCAAzdFJIbIWc4wcV+qzkgx3UL71uz7OPqDiJkVSl5Oy1XzC7xhfyoZ/nH2FfU21G3br3c0aChdkUEwNArAreZ3YrB5cjJnShOjp3aJUCK0fzo1m4UJ0dO7gSAmPy2cwDmFEwowlto4qvgrdkBuZI9yAnyoMPQLfpdek2zdXa4ShEK2bJYG0pJh14OBQLYURkBMHRlqNAwTZ3g4sR0/rQFN+MozyWdohh6BO8KpeT61+TKZ89+Vuogx7B2/Z73mlpwz6PofMvSkQRQ6IAZgEUwIVwEwNDh+iZAy5zgwlmZILNpycXlZWMxhwvxcVT2YCuOwTrmTsZ0kpE57qq00Bw7rJpyBJcqxGapqhfRvKpeKa1sQGuXLYRrbelzBCTXv6ZV8jNv781p4l6ZsZ0yQX2X+V3DPlXHiEb2ICr2RalnuZY0KC+Qg61HM4fSNMn8n6+dN7IOyhm0DnRDZd8QAEP3zWOd2usEF7nzyaH5+Pal49uXOCvbCNtVnDWMS8UqombUam9M6jBr47FNiSDNhUbedKxTpSpMG8vQlfVOx8Y+MY5Gkw68jcouFzY7+Ibo+ee/+2N5C13qGCZ9yo6u5nftUHJCzstUNM/d7LWUDqnM5klmMVM4J+RQSgtlg7bTDphtq4e+XiEAhu6Vu7o21gkulOXftMtNNnLgjuLk/P6d8/t3Llz72pqvonM+zOZLDBvK8MppToizpVV38TOepnmBWvW8jtaSRXq1CskVdjgNpRx4G5I6V8zs4Bu6lhqduXr3weHcdoW7G+xxNpg5e4nf7YWR0lZAu8xB+S6aoY0TNKFrrzPBmyqSns0IUbhgkG1VMWhtKYSeHiMAhu6x89o33QkunHUSpVkO4srsIn3mSwqxW5BxLmSbmJ7vXq6iQseFeo1UXus37QDGrWnBJfL2v7pfkZ758QKWwnY6idJszu85F/B+tXFirra0UMwc6/G9yajA0CW1bH7HCUapYzugvg8IgKH74KVgbHSCCwffN65mL+pQgyhOLn5xL03TB4ffcsnt+3KVVroFbZbVNrxymF7G0Cq4O9vmpSp4OcWSVcdsEb1Eb+aGmSGExt3iwNu4fBZ4695DOiTj8Veu3Lr3kMvnJRzD1vC7cFMJ2uyUBe42zuK2Sk6BoUtq5w2u7XIHzLbVQ1+vEABD98pdXRvbaHCxe5SCIGlfssijC0K2aawitfnJJLoqsryq5RAuHzEzomQtp11hzTujUXjnmleXnotr6Lmil1co2MfjzFGZlxhhm3DcbdyauwZTV2DqR8nLHCf8W1K73LpWWrTj5VaGAiXeEQBDe4d4SAoQXLx6swV47z44HJ25GsXJ8e1L+1/drzic5gwTF0YVdQ+uWXNgDg4aDKiAABi6AAkK5iOA4DIfmwZqfMMr6Xl28E11i5szDAztvrpW3QtouYEIgKE30OmrD7m5SL26DQPu6RveZ97ei+Lk6NZuLXpufJd7MhuwD5cPzbeXl1uAFv1BAAzdH18FYCmCi1cneIWX6Tm5Ll57qzYer4ZVM2E4rQDmcHzpfyRgaP8YD0gDgotXZ/qD97l3P6evo5/fv7PCEPwZtoIxfe8CMPvuwTbtB0O3iXbvdSG4eHWhJ3ifP7dP9PzW7GA1+z0Ztpoxfe8FMPvuwTbtB0O3iXbvdSG4eHWhD3jj96+T2JXpudH70F7x64dwH17ux8hhZX0EwND1MdvgHhRc8NsrAg3Or5c+uEmmvvTBzXXEkpB1JKAvIwAwGQokliIAhl4KERpYBLwyE4Q3G7tfvfIlCVyTnrGGtn8ATaSa9XITFkFGuAiAocP1DSwDAisj8NbsgE5xfv7c/spCuCNIhaFYPwEw18dwcySAoTfH1xjppiDQLD0HtIa2n+Cu7kpzGEquR5cfTgFD51yBzEIEwNAL4UElEOgbAsn1r+nI51/+/tOmbC+SCi3Qj53aJRXUgE/USNOUbDhycqcpG1aVA4ZeFTn0CwABMHQAToAJQKAhBJien3l7ryGRSozD0ETPkpU5TSQts5K2GzSpsigwdGWo0DA8BMDQ4fkEFgGBlRCYHXzz6IsXozh5+s1PVhIwt5PD0JyVCeosGboobjIyZ0fKw6vsoWR02BWffzWe6oPE6WQrXSd2p20vlqlrJ2Nqb84pEwxtuowmk3HumKyipR5LGDSPOiB6KAiAoYfiSYxjsxGYHXxzfPtSFCejM1fvPpBHcTeAi0MqclnMlHx8+xIZUFxzWwsEXZqkIN3pWNOqOkPSHidpjqjUQrixapPV2JvT+vBJZvms3uhRR1tmRZqpDYNb41pKOWC2pBVq+okAGLqffoPVQEAgcOvew8devhzFyVOnP2qcnouMSxzDv6kBmcOE/d21wvn9O+f371y4Jj8DLviSKNKsa2nhqymUaTg7ultwqalSvSx1G6GmVpnCaVM5m5hTpGWtALGtJBi6LaSHoAcMPQQvYgybjMCtew8ff+VKFCePv3Ll1r2HPqBwSIWzTqI0Kxfcqebc0WRm6TLPtdp4JtdsKETimpBNVb6XIWFTq/px2lRalbLWB1pLZDJKS9qhGgikKRgaswAI9BiBuw8On3jtwyhOHnv5sid6Ll1DE2RvXD2Qi+YoTi5+cS9N0weH3xIPRXFy+35+y10x5Xg84hWw2NPO/MDkav1i6JWr7Ja1vlXNW9u83pYtuRa73BZSpHqBABi6F26CkUCgBIG7Dw5HZ65GcXJ8+1LdI59LxM0vanTZtzcZmRvCpJHWyPZ5MCZXvRIW299iZZxtgOvKIivLVbJZQ1NZ1gFPis13NmpCQgAMHZI3YAsQqINAO/RcXEPXsRFtXQQavdxxhSM/MATA0ANzKIazKQg88/ZeFCdHt3aT6/JRLC/DB6k0CCvAbBDMwYsCQw/exRjgABFok56xhm52AoGhm8Vz2NLA0MP2L0Y3QASeP7cfxcmRkzvTT2+3MzyQSoM4A8wGwRy8KDD04F2MAQ4KAabnt2YHrQ0MpNIg1ACzQTAHLwoMPXgXY4DDQWBr5wbF9zMf32pzVCCVBtEGmA2COXhRYOjBuxgDHAgCL31wk4L7Sx/cbHlIIJUGAQeYDYI5eFFg6MG7GAMcAgJnPr5FkX1r50b74wGpNIg5wGwQzMGLAkMP3sUYYO8ReGt2QAc+Pn9uv5PBgFQahB1gNgjm4EWBoQfvYgyw3wic37/TLT3jbatmJxAYulk8hy0NDD1s/2J0/UYguf710a3dKE6eeXuvw5EUSUWWJNe/pmwUJ/T5FM7+2X/tOCdnlI9CffiTP95Z3mSlUv2FUfpuqA/xK9kkoVtJADptEAJg6A1yNobaLwQu37wbAj0X19B0xcDUG8UJHdpBVM0gPzj89ta9h9xMl4tvbnM7Twn9uW8+oCOdTSbT9TU1YD8Yen03bI4EMPTm+Boj7RMCs4Nvjm9f+u6U5dGZqz6OfK6FhUMqdEpHnnqVPIeP6YSrvKIGGC4vcF5OrZ4tPc9rVbu8AfsdMGubgA6bhAAYepO8jbEGj8B//vf//OV4+y/+9fQjv/ptIPRcXEMTikWG/q6En2WL4uTYqd34/esS8nF2UBWdbaXYbjymg67OjnmX2xx1NZqIE6gWFpqjsoRA1X4OQRtRkemWOzIrd7C0NsGen6WOvMx+5siWg52XBkPPQwblRQTA0EVMUAIEukHgP//7fx751W8f+eufRT/6yfd//NPv/du0hVMxqgy1lFQkQ9Pq+dmznznSojjJF8o1qDwZmsvtwc+aSenu8bxCc295OtYpIdAcKO3YQ+dZZvSqFLB8IyrH0IbDrX62syC4ckEpmJV7o+FmIQCG3ix/Y7QhI/Cn//yiomfz8/0f//SJ1z4MweBSUmGGptvP8z5zxs30QCTDlaVzzGoazCs0QKn/Feua9imdHl22zs2vrc3Z0aKjFbK0cEXPlIK5oix0GzoCYOihexjj6w8C3/u3afTnx5h3fvCDH+TprbORlJIK28aPcJN98m608+xYjkQtF6a2fB4Z8xKXe+W5VquWnDrnPnS+Fxi6sykFxdUQAENXwwmtgIBnBO4+OFT3nn/0E2bov/2HE8e3L3lWW0m8w9DPnv2MSoibOc3N6HBMyuY36iWJlqbthrIiU7sLnd1VdgotcatxSIE6Z3apVWX2LLeVn1q2FnRud8qlNE5zohJupY0YpdJaFAIBiQAYWqKBNBDoDAH67LYiab2M/pu/e/qp0x/N2zpu2coVSGV28E3pB0oVAxY3pSW5Zi2i3JNipYWarrMLGmeXmwCSDZjMbSEXZXSuDRubZ9YkGdu0sH9FJ6wA5oqa0K3/CICh++9DjGAoCPz6wrWtnRuPvngxipOjW7uvXvkykJF1Qyp2jStgKC0U9eEnuwEzfFxgYRkCYOgyVFA2BwEKLvjdFQJz3OK9uBNSUatVscqlQZYWeh9/owo6AbPREUBYewiAodvDegCaumIm6O02rLeoXXyn077QXFrY17+nFsHsK0SwmxEAQzMUSCxHwASXvTTFv1YRMMgv95GPFt1q9zGiDmUCzA7B751qMHTvXNalwSa4tEpOuBpI0z2DfDfe71Z7N2P2phVgeoN2gILB0AN0qr8hmeAChm4bAYO8P98uktyt9kWW9bAOYPbQaZ2ZDIbuDPo+KjbBpW1+wjLaIN/NrOlWezdj9qYVYHqDdoCCwdADdKq/IZngAoZuGwGDvD/fLpLcrfZFlvWwDmD20GmdmQyG7gz6Pio2wSXHT0dO7lD5gt9puvfJwQxL4ZURMMh3M2u61d7NmL1pBZjeoB2gYDD0AJ3qb0gmuFiGrkLPxV4rE5Xu+Po4enIyszaowukJ9UGo0QuztKy2zSfPZy+MiuY5BlRpk+9iMPTn20WSu9W+yLIe1gHMHjqtM5PB0J1B30fFJrhYdqSSKr/XY2WrMS3h4NfH6gvM1MYTQy8Wu7i2AcMM8t3Mmm61dzNmb1oBpjdoBygYDD1Ap/obkgkuli+jOPnFuRvOv2KhPgfJ9lqPrYt0KEtkuimNe2WXBVJ4FaVV2kiZubRB3p9vF0kuaqe9k2OndqkbNeDTrtI0Pbq1G8XJkZM7i+RWqrPfxK7UPPhGRTCDNxkGdoYAGLoz6Puo2AQXSx5FMv7FuRtRnPz9O9ckbTsMrU/9IyGCt2Yv/OxfXlPkrTaB+UAE22w8fjKKTkztGlotnaPxCTqLQW1yT97LUWlBzhK9uY3l99TRSvpnPNWKsszrabpnznGIovHrWmPW0mRpE36BBDHqVDbbS91sBrVBvptZ42h3bm2kaUoNuJnMStpeyXow9EqwodMgEABDD8KNbQ3ChODlDC3pmTg7t26entBkpu4fj0ZPambdm00oIbas7f1aVUjNDAf/YTIq3dlm8iuTs0ivHZQylVtmtM1iZTMu5IRYbS+SwO0VPZtxaclur0ydQb4tT+f1ONo5KxPUg/iYy/NizAGR0+ziZzzVJ0Dqyxv7BW579tR4mp7lyy/6Bqi4NpoWhPejYD44/bAfVraJABi6TbR7r8sEF8tSVFLld46hZy+M1FNde9Pxk5Mppd+ZjPTSU7HyialZzppVL1NaRoGjHLG5teo5slI5C/QajZmdev0tuFOqMA+mKWqh5bKsNelFEmQbO1il2u0VKEPzVGZKPr596fj2Jc7OWTprhiU2Fkl1+GT2FW6xYp6OdUNRwlrlaZW2sB8p80fUD2thZbcIgKG7xb9n2k1wyTF0jno1z+nobNvQRyvzzd7TfPz6WPH0O5PRP00Nd5Yzq93ZJoaORqMns1W40mgIT6ZLGVrtIT85mZXpdRhaZ2eTJ/VZxnkVVjJJy9fmjFEbAyUSuI0VlYNL9AqUoeU1Ge1y01SWDH1+/875/TsXrn0tZrmk27K0XUDrlXXx1Ge7iLarbiG/B0nzR9QDU2Fi5wiAoTt3QZ8MMMHF0kmRjImPb9zNvf1cbKb2tMX+9nj8j2bB6uxO0xKzhIN1gH9PE39JLd0ezh7wFkQ4X68dlLyYEHvv5hWv6Qn9Whetd+evoQ3ll0hghtZ3nc3AcwaYXuEyNN9+5oSZHrnb0sTZZpaXsbKqM+Ulxz+bqjTVe+KKtNN0bzICQxtQ8f9wEQBDD9e3HkZmQrDlkiL1lq2Y1cEPkvZUWrGm4TyZNju9eg1lGlhKkwtW/YyV+w60YGslln5YzkK9hlOVefSCteqd7UJnizf1aFj2bNf3Rv93TDvz/OxY9uCYVrdIgjBSDS37UdcThV6Em0Heg1MriHS0M+m+cfWA0tQgipOLX9xL0/TB4bdccvv+odAg6JZZWVVzuYI5z71cJVopIs+3EjoCTzpgBm4tzOsWATB0t/j3TLsJLpah+dgljsilCZeeJRciXQEBg3w3E6Y57YJuLStLhqaFsr1moTqVV4tnc1D0aDzGGrqbuQCtrSIAhm4V7r4rM5E6x9CDYF+7kNXkkH96qwKD+gbBIN/NDOpWezdj9qYVYHqDdoCCwdADdKq/IZngMjyGDn1EBnl/vl0kuVvtiyzrYR3A7KHTOjMZDN0Z9H1UbIJL6Hzme0XbvnyDfDezplvt3YzZm1aA6Q3aAQoGQw/Qqf6GZIILGLptBAzy/ny7SHK32hdZ1sM6gNlDp3VmMhi6M+j7qNgEl7b5qf01a2gaDfLdzJputXczZm9aAaY3aAcoGAw9QKf6G5IJLmDothEwyPvz7SLJ3WpfZFkP6wBmD53Wmclg6M6g76NiCi743RUCXc0ZkEqDyAPMBsEcvCgw9OBd3OQAEVyaRLOOrK6Q3//qvvPJMLIEv9dEoI7z0XZzEQBDb67vVxh5VzyxgqkD69IJ8rODb6I4efrNT9ZkI3QvIjCw+YnheEIADO0J2GGK7YQnhgllzVF1gvxz734exckvf/9pTWPRHAgAgWYQAEM3g+OGSOmEJzYE28XDbB/5uw8OH33xYhQnyXV5ONViM///9t4nZJLjzPNPG4ZpfnhZgVjG+NQHH8wyBy/44Msgwx6mWPbgo+ey6OBpfBn371ALA8ugy7CDYJkaaEMLUdODGYMtdBAyg7U6mGqjEWp0UNF0T0vYksovEvOKbst0I/cfqdWdq4gn44knI6OqIqsiMyMyv01Tb2RkxBNPfJ7I+FZkZmViLwiAQEwCUOiYNEdvq3+dGD3SwA72T/6ld28Xi/U3f/JOoIcoBgIgEJ0AFDo60jEb7F8nxkyzTd/6Jz976b1isf6nf/u4jZsoCwIgEJMAFDomzdHb6l8nRo80sIM9k3/74/vFYv3ExWv3H8p3RwY6i2IgAAJxCECh43CciJWedWIiVEO62TP585c/LBbr85c/DPENZUAABDoiAIXuCOw4zTZ14syFq8Vi/eRz16jDVKBYrLn/T1y8VizWZy5c5RwkDiDQJH+AkcAquEcsEBSKgUDXBKDQXRMelX1HJ0iepSpzmkRabkrZHhWUXjrjkO+0zZ++8/tisf72z37daSswDgIgsJcAFHovIhSwBByd4E2ZoNJSoW19Tq3mRVEUs9lM/SmK2XJTluVmWW06OVysmM3npsh8VRlr1uJWRpRgwj306Tsv/gb3iPXAGU2AwF4CUOi9iFDAEnB0Qi6LWZLPXrpx9tIN3pRlrKFKoZUwk8Ky4Koyeq9Sbdqn9bsSYlXuRCs5qbouSpU9hmyDuacc8t11Z33zXrFYf/X567hHrDvIsAwCgQSg0IGgUEwRcHSCNvmTCpRlSQrN+ZT42vPXLURSaK2sQoWNXPO6WoiuLMYKTlpO6/Dqsyb1tsHcU8Swh17gHrEeIKMJEAgkAIUOBIViioCjE7zpJGiTV8/OpjLkU2jKU0tjVuB9Ci1le9wRYsKddvP+w0d0Z9/bH9/vtCEYBwEQCCEAhQ6hhDIVAUcnWINffu+OPK3NxZqJypBHoVd87trq7j6FNpeuzcJ5tdQXtEcYLybZad/+6d8+Lhbr77z4m05bgXEQAIFAAlDoQFAopggE6gQXayYqjh6FrpbOfAOZvQ7dOBnOa2xljVS8OsdNF6dHGCwm2Wnfvv2zXxeL9U/f+X2nrcA4CIBAIAEodCAoFFMEAnWCivEK29kEygMIBJI/wDJXwT1ijAIJEEiEABQ6kUDk4UagTrAkO6e+8+hkkl4Gkj/Gd7pH7K//9d+PMYK6IAACEQlAoSPCHL+pQJ1ghSYizub4MXXQw0DyB7d8/+Ejev7M5s6nBxtBRRAAgbgEoNBxeY7cWqBOeH9tdfbSjZHT6bJ7geQPduHi1VvFYj176b2DLaAiCIBAdAJQ6OhIx2ywa50YM7vj+tY1+W/+5J1isX7p3dvHuYnaIAACMQlAoWPSHL2trnVi9AAP7mCn5HGP2MFxQUUQ6JQAFLpTvGMz3qlOjA1W1P50Sv4Hv/ygWKxxj1jUiMEYCEQgAIWOAHE6JjrVielgPKCn3ZG//eBzukfs9A+fHeAYqoAACHRHAArdHdsRWu5OJ0YIK2qXuiO/eOtmsVh/9+fvR/UXxkAABCIQgEJHgDgdE93pxHQYHtbT7sjjHrHDIoJaINADASh0D5DH00R3OtGakX14t1uVniiq3jldezqoW2zfNr3j0jzx25QWTwo3Wb387Yj8ldO79K7JXjqBRkAABNoRgEK34zXx0k2doEuYTz53jchQAX7eZ1mW9K6kMxeuRka3RaFr2VDofdCffvXki2A988bpvoLYDwIgMAABKPQA0PNt0lFokmepypx2nvfpVIxAoCbF1l5tjQuFtmA8qdM/fIZ7xDxckAUCyRCAQicTihwccYSWN2WC+iEVutkzIZ10MrnQZ5NFtk7SC6uq91WR9lbvsJqvhEJXZWdLeoElF7HvmeY3Uut9ZFA05vWhpvW1xgvyttmtDnOYcMQ2cI9YRJgwBQJdEIBCd0F1tDYdnZBns1mSz166QU/93PEuLCuvRvr4XZMqQZIrXjqpklXJSq+rTXOxmTWTSlVXj1mEfQb3+FCK69Ciukj2GmWHfJS2v/Hjt4vF+pXNnSjWYAQEQCA6ASh0dKRjNujoBG3yJ0lyWZbe53J/7fnrFg0L6WpezObzWWFu7HIE2gjzfGUlmaxUAjubqRdKLzfGNBtWGUaha7LKJTjh86EUCi2rcyXTYE9/HfLHt7r64JNiscbD0o8nCQsg0B0BKHR3bEdo2dEJ3nQStMkrbGdTc9Er1NlyOVenjLXszefzSmulIlbCvE2hi5kj0TUF3a3QpMFbfBi9Qn/vF78tFuu/e/OjEQ5TdAkExkIACj2WSPbSD1Ziao01+OX37vBZbqnHXJ4T7KaWUqWv6ow0aTIvho2ylmIJvWUNvdyQJpvT3F6F5sV0zWBlfIsPYg1NNvVCXV6x5q70kWgCPKZVukfszIWreI7YMRhRFwS6JgCF7prwqOwH6gQXayYsjkqV6ZJxbUOVMZptz2ELnVQFxCYl6f4tSrvXob0GbabXB3EduuaOutmssm8703mKSUZp6e/e/AjPEYtCEkZAoFMCUOhO8Y7NeKBOUDFeYTubY4PSS38CyQf6QjcKrD74JLA8ioEACAxCAAo9CPZcGw3UCZZk59R3rt1OwO9A8iGevrJRlyS+8eO3QwqjDAiAwIAEoNADws+v6UCdYIWmHjqb+XU7AY8DyYd4+t2fv18s1ou3boYURhkQAIEBCUChB4SfX9OBOuH9tRV+2HNMvAPJ720C94jtRYQCIJAOASh0OrHIwJNYOpFBVxNzMRZ5ukfse7/4bWL9gzsgAAIeAlBoDxRkbSMQSye22Uf+NgKxyH/1+evFYo17xLZxRj4IJEUACp1UOFJ3JpZOpN7P9PyLQv6ld28Xi/U3f/JOev2DRyAAAh4CUGgPFGRtI0A6gc+hCGyLS2A+7hELBIViIJDdrolrAAAgAElEQVQIASh0IoHIw40oK7k8upqYl8eTP/3DZ8VifebC1dsPPk+sc3AHBEDATwAK7eeCXC+B43XCaxaZewkcT/6ZN06LxfrpV0/2toUCIAACiRCAQicSiDzcOF4n8uhnel4eSf7+w0d0j9iV07vpdQ4egQAI+AlAof1ckOslcKROeG0iM4TAkeRxj1gIZJQBgdQIQKFTi0jS/hypE0n3LW3njiQ/e+k9PEcs7QjDOxDwEIBCe6AgaxuBI3Vim1nk7yVwDPnNnU/pHrH7Dx/tbQgFQAAE0iEAhU4nFhl4coxOZNC9hF08hvxf/+u/F4v1D375QcL9g2sgAAIeAlBoDxRkbSPQ1AmZs755jzaLxXp9815Zlrz5lR9d5ZdRbjOO/B0EJOcdxZq7+B4xikizAHJAAASSJQCFTjY0KTrm6AT9eoelt1is6be2JNXcgYePHt9+8DkX4/yoidW8mC03UU2mZMwhH+7aT9/5PZ4jFo4LJUEgKQJQ6KTCkbozjk5s7nxKC2XHb0ePHz563LE8l2UJhXaCUG1+58XfFIv1xau3/LuRCwIgkDABKHTCwUnPNUehycGm+n6R88wbp7z3yeeu+d5GfLKcFfRvvtJlN5xRVDk13WUN1onlnOrqhfOq2igKrpkevKM88pLfa/Htj+/jHrG9lFAABJIlAIVONjQpOubVCanQtHo+f/lDx/tisa5nKnmun5VWKiukmnayKstVstZjKmoryZJO42PY9JLf27Hzlz9skN9bCQVAAARSIQCFTiUSWfjh1QlWaLr8/NK7t7194WJqr1oum3Uyla7nrOa0W+oupznhyHZd8b1OZJvpJb+7N7hHbDcf7AWB9AlAodOPUUIeenWCpZdv4SaP5dVo594xKHTboHrJ7zbyT//2cbFYf/tnv95dDHtBAASSJQCFTjY0KTrm6ASdRKVM+VMrLvb0qyeUdsS7LPee5aYVtipWrbXVCe3dp76xhq6NmW//7NfFYv1P//ZxLRcbIAAC+RCAQucTqwQ8ZekN92Vz59MtNxLry8n6dq9Kg+2dYkJrudR8bn5P5T3LrW4qU//q587D/Uy8ZFvy9IXpiYvX8ByxxCML90BgBwEo9A442OUSaKsTbn1sH0qgLXncI3YoadQDgYQIQKETCkb6rrTVifR7lIuHrcjff/joiYvXisX67Y/v59JB+AkCINAkAIVuMkHOVgKtdGKrFexoT6AVebpH7Dsv/qZ9O6gBAiCQEAEodELBSN+VVjqRfncy8rAV+W/+5J1isf7pO7/PqINwFQRAoEkACt1kgpytBFrpxFYr2NGeQDh5ukfsq89fxz1i7TGjBgikRQAKnVY8EvcmXCcS70h27oWT/8EvP8BzxLKLLxwGAS8BKLQXCzL9BMJ1wl8fuYcSCCR//+GjMxfUiz5xj9ihpFEPBBIiAIVOKBjpuxKoE+l3JDsPA8lfvHqrWKxnL72XXQfhMAiAQJMAFLrJBDlbCQTqxNb62HEogUDydI/YtkejH9o46oEACAxDAAo9DPdMWw3UiUx7l7LbIeSvnN4tFmvcI5ZyHOEbCLQiAIVuhWvqhUN0IoyRfHJnWI39pfgBoSN8+mcIeXoK+l//67/vR4USIAACORCAQucQpWR8bOoE3Zf05HPXyEcqwG+7KsuSHm515sLVeid2KPSOXXUbaksWlulmyVY5EU21andr4SZ5p+jtB59TLDZ3PnV2YRMEQCBTAlDoTAM3jNuOTpAkSFXmNIm03JSyXVdWpy+t1FEWlmnHZtvNiKbaNu0v75BvFlq8dRP3iDWxIAcEsiYAhc46fH077+gEb8oE+SQV2uellUB7blq9lspuVW+psi+8ordWqfdR0r/5yilsbeoWxZsr5WLbNahrLenFWPR6S8esz/3e85jwtpZxj9g2MsgHgXwJQKHzjd0Anjs6IZfFLMlnL904e+kGb8oywmNHTaWEyl0ivZqrd1Ku5vX3S4oCUt2pkChskqI8GaRapP5Kmjkl3oAp/B4q6ZB33Fh98AndI+bkYxMEQCBrAlDorMPXt/OOTtAmf5ZlyXosFfrK6d0rp3ff/OiecLemlNWimFawSjKNOtr1ri4yX5U6x+yWuu6kqSmjy2WlxlTdNEdyLJqzTctM4fVwSYe848j3fvHbL4A/88apk49NEACBrAlAobMOX9/OOzrBm07Cu8nirZ02EqgUl09fk/KaXWWpBZX21npKwq13iMJWX23hzXI2W27oU+Xa5riM14LM5JJDJhhp04nTP3xGNwSc/uGz5l7kgAAI5EsACp1v7Abw3NEJFt2X37sjF83FYn39dw/Ksnz46DFVKRbrTz57JDw2Emj+au1sKLQ+BS1WzNaAEV2u711Da0mezeczlnl1Irtu0GtBZtpGB0w55KUndI/Yd3/+vsxEGgRAYAQEoNAjCGJ/XdihEy2dYAk0d34pHa2ks7pTi1SV1svm3jAt2byh2hSFqyTtNjKs7bNAV8toc55b5bMnNY0XZlv2rJviO8h/48dvF4s1niPWDXhYBYEhCUChh6SfXds7dCK7vuTl8Dbyr2zU2YuvPn89r+7AWxAAgRACUOgQSihTEdimEwDUNYFt5L/78/eLxfrv3vyoawdgHwRAoH8CUOj+mWfc4jadyLhLmbjuJU/3iJ25cBX3iGUSRrgJAu0IQKHb8Zp4aa9OTJxJP933kv+7Nz8qFmvcI9ZPCNAKCPRPAArdP/OMW/TqRMb9ycd1L3l6Mswrmzv59AOeggAItCAAhW4BC0W9OgEsPRBokqd7xM5eutFD62gCBEBgEAJQ6EGw59poUydy7UlufjfJ0z1ii7du5tYV+AsCIBBKAAodSgrl6KGeJBX4HIQAD8LTP3xWLNa4R4yBIAECoyQAhR5lWLvq1CCyhEaZAMf1mTdOi8X6e7/4LecgAQIgMD4CUOjxxRQ9Gj+Brz5/vVisVx98Mv6uoocgMGECUOgJBx9dz5PAS+/eLhbrb/z47Tzdh9cgAAKhBKDQoaRQDgRSIHD/4aPvvPibYrHGPWIphAM+gECnBKDQneKFcRCISeD0D5998yfvFIv1Exev4TliMcnCFggkSQAKnWRY4BQINAisb96jy89nL91Y37zX2I8MEACBsRGAQo8toujPKAn89J3fn7lwtVisv/2zX99+8Pko+4hOgQAIOASg0A4QbIJAcgTo+dvFYv30qyf3Hz5Kzj84BAIg0A0BKHQ3XGEVBGIQuP/w0fd+8Vv6PTReMRmDKGyAQE4EoNA5RQu+TorA6R8++/bPfk3PDnvp3duT6js6CwIgoB7jCAogAAIJEljfvEevrvrq89dxX1iCAYJLINADASh0D5DRBAi0I/DSu7efuHitWKy/+ZN38KuqduxQGgRGRAAKPaJgoiujILB46yZdeP7eL36byH1h/GBwJIrFehSjDJ3IgwAUOo84wcspELj/8NHTr56QCv71v/57Ol2GMEsC6cQFnoyeABR69CFGB/MgcPvB5/Q4zzMXrv70nd8n5TTpU1meTPy/4ZBUcODMmAlAocccXfQtFwJvf3yf7gt74uK1K6d3U3PbKBMUeo2z3KkNznH7A4Ued3zRuwwIvLK5w/eFbe58mqDHUGg6eWA4JBgiuDROAlDoccYVvcqFwMWrt2je/+7P30/2cZ5GmbCGxho6lwNrJH5CoUcSSHQjRwI/+OUHJH7nL3+Ysv9QaKyhUx6fI/YNCj3i4KJr6RKQ94VdvHorXUe1Z3sVmt7qQcW2fZblyft3Nlnfa2Y4JB4uuDceAlDo8cQSPcmFwObOp9/48dv0mufVB5+k77ZRJv9Z7hB53m2hP9nePDsrnlpu/B3Z64bpRfoRg4cjIQCFHkkg0Y1cCKw++ITuC/vGj99O876wJkmjTH5ho70hn3UJfGF+hFjWTfkdM2W8DXkzd9upfqre5IMcEOiIABS6I7AwCwIeAhev3qIV53de/E2y94U1/d6r0N9/45bzv1ismzlGMkkID9HIuoU9gmoKexvyZu4xaDg0CSEHBDohAIXuBCuMgkCTwPnLH9IU/4NfftDcm3KOUSa/gDXF+PtvqBvU/+K1j6RI618SWwvzwvybv1CWJyve1ptKXNUZafVvtnx262rblCmKcyv1QBWtu8tzZHq2fF3nyIZImF/g1orzf7+cFfOVcWx1rpg9u9nybBbDIeVYwbdREYBCjyqc6EyaBG4/+Py7P3+f5vfFWzfTdHKHV0aZjIzVBWybQkt5Js02i1qy413FcqYSURLOzfKpwn8+nAuflKtzVo9J41fnarJdXXvmKpxQdQvztWA1F2pd72ZZ4iz3jjGCXZ0QgEJ3ghVGQaAsy3/4x3/+T/NL//F/vfilv/kXui/slc2dHMnsVWgqsPdzl0IrQaV/+k6uzbMzu5YVaipV0y6gdUWlsrIkpzlhFtlKrZ1MswS3jXq+jhgOOcYQPmdJAAqdZdjgdPoE/uEf//lLf/MvX/ovf158/Vt/9Kd/9uW/XWUqz+o18gt6UodHtGhlWZdeVcw5p+3LERqptJY08vXlrJVCUy12TNi0Grw382SzfGq2fJ0+m33hHMMh/dEHD0dCAAo9kkCiG6kR+P/+/+eVPJt/f/Snf/btn/06NScD/THKxEJYSzTFmPT41v3ar58bxYRw8tVfJdX0a6jAs9yFPrnN/gibbRRaXfOenZvTlwO5TK+nDYdAbCgGAscSgEIfSxD1QcBL4Mt/uyr+w5NGoIs//uM/1hLlLZt6plEmFsJaoiG9am8zs5lT3R2mzk6/vtR3hX159pdWJs1577A7xQp9Ldmr0OY2tPppcNG6clhtmqvRvGh2EoZD6vGCf6MhAIUeTSjRkYQI/PSd36trz1//Fiv0f/sf585eupGQi21cMcpUE2apXlRg96cs3y5tz4FvdaCdwfrKmOruvkeMyhgObdihLAgcQQAKfQQ8VAWB7QS++/P3/+R/v0LL6P/637/7nRd/89K7t7cXT3qPUaYOBXKHxKrVrbqBS/xESn3xca5AH+db7ca0raYMh6SDBefGRAAKPaZodt6X3Ysk7A0n0HmoojZglGmrdO3Q10N3Vee99UmIqGLsLqCpoaBHgRoOUeHCGAhsJwCF3s4GexoEwhUIJXcTaKBNOsMoU58KnWJbhkPSwYJzYyIAhR5TNDvvi5mhUpw9D12r9d0Xw7DzYEVswPjcN6vUYmo4REQLUyCwiwAUehcd7HMImBlq6jP1McphGDpok940Pk897oZD0sGCc2MiAIUeUzQ774uZoaY+U0OhjyGQb10z/js/0NAACBABKDRGQgsCZoaCQh9OwDBsgX3wouQzPnOM3eCDBw4cQwAKfQy9ydU1M9Th+pTv+imW54ZhToMnR5+74AsOXVCFzR0EoNA74GCXS8DMUDWFphce065tn2V58v6d2jMgYwlednYMQ5dtyts5+twFT3Dogips7iAAhd4BB7tcAmaGsgodIs/NWsfJqnyyo/GEnhBZPdci6Letx/lg2nV/XLs/39Bw2aa8naPPXfAEhy6owuYOAlDoHXCwyyVgZiirQ5QT8hlPEZsKbd+yUH+roPXz6NabjR5o3DB02aa8naPPXfAEhy6owuYOAlDoHXCwyyVgZigrTsVi/f03bjn/m5nNtyYcIZlNsZQ5Mm39PKI5MhLNrGHosk15O0efu+AJDl1Qhc0dBKDQO+Bgl0vAzFBW+Zpi/P03bhWL9V+89pGUbUehxVsKhPJtnv3z//kzJaXqTQnVv/nKCuR8/pR+GjNX0Q9qnp+bm8L6RYS812NnZ7v2MZOmUe6meCK0fv1R9VqkQrwNyfgsXsTkN2gYumxT3s7R5y54gkMXVGFzBwEo9A442OUSMDMUS5d6yaBUYko3Mx2FLlfnqjf9rc7NZk/RK343S0qIU9b1twWbNwGTBv9qOSuMlApVrr0V2BRgOzva5V3+S8uyCe4+Z1qfN8unCnrD8RaDhqHLNuXtHH3ugic4dEEVNncQgELvgINdLgEzQ7FEKYUO/F87z2xeJbSaP7VcPTtTd3i9tpzpO7yUmto3JZhVL2vhCV1pns0KI9hVznJDXpmSXjt72pU2bR+158Ys6bd5dXElxsZsraRywGPQMHTZprwdzWd98mG23MjObvSroecrmZdoOhqHRPsHt5IjAIVOLiQpO2RmKKte7uJYC1gzs5HzutbjF+aVNv9wxSLnVVa7MiY9Lmazp6pVuGpRyqdJ++1sb1d7rlfAZuVNYlx9GrPVSXj6DkHW9Ol01ZH6V4QtBg3DlOPs+tb0me7hf/K5a1SUCugoV3WfuHitWKzPXLhaswWFruHABgjsIQCF3gMIuyUBM1PvV+hb92u/fm4o9Ik6py3Ob8/nf2XWxPaMsb4gTVooBNLo8WrOK1TPXi3bRmuFWm9vt+qUOdlu+1hbGZcn6hQ96bEyS7/ssj7bs9xG4B2DhqHkmnra8dn5iV1ZlqzQJNJyU8q2t59YQ3uxIBME1JEFCiAQTsDM1Fa9mtJblurUd+2cti9Hq6/54bKVOm1ZbdI/U8Cocl0s9a1YSiy9Ci3vFGM7lGk2Zbv2xLU9xy57Ud0dpu4Uq24B+/LsL+d0Zp5kW7ts7xTbYtAwDKc+fEnHZ96UCfJSKrTHb7GGJmE2N/kVOMvtwYWsyROAQk9+CLQBYGZkq9Ckx5S/41NK3cjTSvX9Gk8dNwzbcB+6rOOzXBazJJ+9dOPspRu8KctY91mh6fuOlmWRtAXTTDkc0nQSXo2JABR6TNHsvC9mhqop9BgVV521Fv92Ka7TfaU39pq0B5Rh2HmwIjbg+Eyb/ElnucuyJIXmfEp87fnr1hOj0FKVcZbb8kEKBOoEoNB1HtjaSYDmXEeTsMnnvbWo75Fzw3An6MR2Oj7zppOgTV49O5uqT1DoxCILdxInAIVOPEBpuWdmZM/SEDodSMAwTCuyu71xfGYNfvm9O/K0NhdrJir7RqFp3ax/dnWif2yF69C7I4C9EyUAhZ5o4A/rtpl5odCHEzAMD4vAMLUCfeZizUTlt1Fos5y2VxJwp9gwoUWraROAQqcdn8S8MzPv4foUuNAccTHDMLHQ7nQn0GcqxitsZ3NnC3nsDOSQR2fgZQ4EoNA5RCkZH80MBYU+nIBhmExQAxwJ9JmKcWHeDGghjyLctTzchZf5E4BC5x/DHnvAcy4SRxLoMWgRmgpUJmZCTTqbEfwY2kQgh6HdRPvjIQCFHk8se+gJZqjjIefIMNBn76+tzl66cTy0RCwEckjEW7gxAgJQ6BEEsb8uYIY6nnWODHP0+fhINS2AQ5MJcjolAIXuFO/YjGOGOj6iOTLM0efjI9W0AA5NJsjplAAUulO8YzOOGer4iObIMEefj49U0wI4NJkgp1MCUOhO8Y7NOGao4yOaI0PyGZ85xu74EQsLAxKAQg8IP7+mMUMdH7McGebo8/GRaloAhyYT5HRKAArdKd6xGccMdXxEc2SYo8/HR6ppARyaTJDTKQEodKd4x2Y8oRlKPNnZoUzvTSpmy414xqRTJmCTnhftPozy+BcxJcQwgAIVydHn4M61KAgOLWChaAwCUOgYFCdjozlDnblwtVisn3zuGjGgAvzcx7Isn7h4rVisz1y4GhnSFoWuZUOhI0Fvxj2S4czMgENmAcvfXSh0/jHssQfODEXyLFWZ081XHknZjuByTYqtvdoaN22F/od//Of/NL/0H//Xi//5//zftz++b/uQXsqJe3oO9uQROPQEGs0YAlBoQwJ/Awg4MxRvygSZkQrdNCykU758UGTrJL35SL+jsCxJe6uXIc1XQqGrsrPlil5kSGXmK34bsXKgYVA05vWhpvW1xoujXpVIrP7hH//5S3/zL1/6L39efP1bf/Snf/Yn/+dyyiLN8W2GclI54DCpcKfQWSh0ClHIxgdnhpLLYpbks5du0NMfy7J0ynM/rbwa6VMyrNMqQWqqLwHTfpWsSlZ6XW2ai82smba8UeVtBqkkt1sU6sq19aEU16GFPyLJvWmXICbF+b9X8sz/vv6tKn+xTi2xI47tep5/6W3jOf+eoQeJEoBCJxqYNN1yZihHS2gqL8vS+3zmrz1/3XaKhXQ1L2bz+UzLo1I/R0+NMM9XVpLJSiWws1klrZVtNqy2tZy6Is4lOOHzoRQKLVWZK9m+tEwRtC//7ar4D0+yQKtEetrM4eZEy76OrTg4jC2iyfcHCp18iFJy0JmheNNJ0CavsJ1N3SG9Qp0tl3N1yljL3nxeCbRcQu9T6GLmSHRNQXcrNGnwFh+6Vug/+d+vFF//Fiv0f/sf51J+wwTHlwfjYHcIsgdDJJochvACbU6IABR6QsE+vqvODMUa/PJ7d/gst9RjLs8J9kFLqdJXdQabVqm0ghZr31II9JY19HJDmmxOc3sVmhfTNYOV8S0+iDU02VSr+yrTNMadaZMgFK9s7iiR1svo//rfv/udF3/z0ru325jptawTviHvEOy1325jDgd3N7ZBIDYBKHRsoqO2FzhDcbFmwuKpVJl+cFzbUGWMZttz2EInVQGxSUm6f4vSZFQKs8egbcXrg7gOXXNHrXsr+7YzLVLM5JXNna8+f71YrJ+4eO2n7/y+hYnei7LP1DJvygTv2nndWl1R0GdOFEb9pUfVs9G2kbM3/vElDlmlGgDHRqMdSu5vu2ooDQKHEoBCH0pukvUCZygqxitsZ3OS5GynAxnaCgmkHJ85snznQbFYh9whWGmx/UbkfNXR+r0xkk0CrtW70nKV5spG31dzk+qclMOh8/bQwOQJQKEnPwTaAAicoagYF+bNNk2NtixjyaiHjs8cUM5nzZYXO66c3r1yevfNj+6JnrIGkwwbbbWLaMrZUkwttnUBc9qkupDvCL1oL26S+xvXLKyBwDYCUOhtZJDvIRA4Q/EMTiacTY/dKWUFMkwKieMzbzoJ7yaLt+6RkVi1YdJKbkljT5azcIXuS5ZFJLiDIg9JEOiQABS6Q7jjMx04Q3l/bZXyvcp9RiqQYZ8u7W3L8ZlFt3mH4PXfPSjL8uGjx1SlWKw/+eyRsG9UWWWZtPmrLy2HKbS+ck1FhfHOkw6HzttDA5MnAIWe/BBoAwAzVBta/rI5MoznM6uxUGhzh7z+ZXygQptbBek0d1/L6Xgc/GMDuSDgEIBCO0CwuYsAZqhddML25cgwR5/DotGuFDi044XSRxOAQh+NcEoGMEMdH+0cGebo8/GRaloAhyYT5HRKAArdKd6xGccMdXxEc2SYo8/HR6ppARyaTJDTKQEodKd4x2YcM9TxEc2RYY4+Hx+ppgVwaDJBTqcEoNCd4h2bccxQx0c0R4Y5+nx8pJoWwKHJBDmdEoBCd4p3bMabM5TMWd+8R5vFYr2+qZ5TwZtf+dFV/onOEVBqT+JkO7UnfXJuqglJLFUfXb9y9NntQ4xtcIhBETZaEIBCt4CFos4MVSzWT796wtJbLNa3H3xeliVJNeN6+Ojx7Qefc7EqXz9GquXPZKDQDLXXhBP3XttOqTFwSCkak/AFCj2JMMfqpDNDbe58yk9mlk04ekzPr5AF6Mew7V9BAYV2KPa06cS9p1bTawYc0ovJyD2CQo88wHG7552h3MWxPrn9zBun1HSxWD/53LXFWzelJ/YxzKTS8jHL5klRMs9oeU2hfQVkI4mmvQwT9dW4laPPxveYf8EhJk3YCiAAhQ6AhCKGgHeGkgpNq+fzlz80Naq/xWLtZJJIu2e5da7SaE6YVxPqkkKhRX2RdJpNcdPLMEVHhU85+izcj5YEh2goYSiMABQ6jBNKaQLeGYoVmi4/v/Tube9zubkYsXRlVayIZ8uN3Et7HIXeUiCDOHkZJu53jj7b534buGrMuF8Jzb6wv3lyCOsbSiVJAAqdZFhSdco7Q7H0Nm/hpn5QLS5GmVJiKS2XznIvFHrw4dCM+5kL6ub8J5+7ti3ET1y8VizWZy5cje28fLL3btv1kpvlbDafV+/Ooor1AruN6b1NDgGVUAQEDicAhT6c3QRrOjPU+csfsvrKn1pxsWaCoTV0Vwk0Zc6WG06U5rUKzhp6SwE2n26CmaTrYsMzx2eSZ8qkL16cbm4638watttmhMtqraQSaD2uzH0O8tUdoT44HEKroRwIHEoACn0ouUnWC5yhuFgzIbDROlmfeDTJ2WxWFAXNoSavoExHoflucHq5kbmVTJhPNclMUnXQ45fjM2/KBFWTCu0xpLLoZgIVNx1TpaPz+azaom9evNPchWAyeFCY89WN8tW3PDWKlvNqKFGjeliRUCs3Gqa2uCuzub8yE2kQ6I4AFLo7tiO0HDhDUTFePDmbbbnQJHzcBcS2bXZYPpBhhx60N+34zJHl39oVi/XZSzfo/gN+Uo2vHSXPYhVbKaXJEave1dxkkhnexYn6Irgqr3SXhooeNsaGFeYTvZZ2bPo89eU5HHxFkAcCMQlAoWPSHL2twBmKinFh3jyIj17rmJn2IAtpVWIsabm10xvHZw4o57NmyzX0ldO7V07vvvmRerpc9U/JpvNdSyiuXRDrMyNU0K51aRDsLG+VuKbfMlu4IEwZB3f/5f7uLoa9IBCLABQ6FslJ2AmcoXgGJyjOZhgpOzE7a66w6umWCmSYVAccn3nTSXg3WbxVj4Q8mg4KmWzutTm89t1X3n6Z45JiLGnpN8tsLmB82feXO7ivIPaDQBwCUOg4HCdiJXCG8v7a6uylGxOhtLubgQx3G+l5r+Mzi+7L792Ri+Zisb7+uwdlWdJT5KjWJ589Et56z3KzqCop5Q1VizVUSXVjDa2vJdfK6xz3LDcbqfxQPugy7g7hpz/pcPAXQi4IxCMAhY7HcgKWMEMdH+QcGUb12a5oPTKplNj8U7vNbWXih1JVfaHD7sJYb/OdYk0d5pV5zVRAaKNyCGgPRSZPAAo9+SHQBgBmqDa0/GVzZJijz376x+WCw3H8ULs1ASh0a2RTroAZ6vjo5x8GgesAACAASURBVMgwR5+Pj1TTAjg0mSCnUwJQ6E7xjs04zVD4PJ5AXiMDykTxAoe8xu0IvIVCjyCI/XUBM9TxrHNkmKPPx0eqaQEcmkyQ0ykBKHSneMdmHDPU8RHNkWGOPh8fqaYFcGgyQU6nBKDQneIdm3HMUMdHNEeGOfp8fKSaFsChyQQ5nRKAQneKd2zGMUMdH9EcGebo8/GRaloAhyYT5HRKAArdKd6xGacZCp/HE8hrZECZKF7gkNe4HYG3UOgRBLG/LhyvTLCQ4yyfo89dHBXg0AVV2NxBAAq9Aw52gQAIKAJQJhoH4IDjoWcCUOiegaM5EMiPwNDK1Hxw5wEMXSPqkZ/06NBgY0NzCHYUBcdCAAo9lkiiHyDQGYGmMp25cLVYrJ987hq1SQX4jRplWT5x8VqxWJ+5cDWGU664Cps7dolSKlkvqV5IOZ/P5Hs36gWc2nqzycFXCnkgEI0AFDoaShgCgbEScJSJ5FmqMqedV105FQ/ls0M7d+xyWquVpDdGy/dGuxLu1NabkbrjM408EPARgEL7qCAPBEBAEHCUiTdlgopLhRYGOCllktM6sareamVXteY9V/yWKloIizdZ2ddkVeerTRV7/trkSCP6lVm6HSvRDVPsskhwf0UekiDQIQEodIdwYRoExkHAUSZ5Npsl+eylG/Re8J13lrEqy9POWh1JmZWgUspeJtYia4VbI2U7nJAG1XpYV9hixArzydKe6Jam/HFzOPgLIRcE4hGAQsdjCUsgMFICjjLRJn+SJFPXWbCLxfrK6d0rp3ff/OieoCJVkNOcUAVXc70etiLqSq95fTQLuRFvs1y2i+wtRmS2qlTdL1ZzQ/hskw4HuwMpEOiGABS6G66wCgIjIuAoE286Ce+mXHDXr/WyInKi1Oeftyu0lVNe+4q6dq9BL6XY3ikmTmhbMa9/DzAGnL/cQScfmyDQEQEodEdgYRYExkPAUSYW3ZffuyMXzcViff13D8qyfPjoMVUpFutPPnskQJzUlqzihHa1ELYq6ztBzXKsijXW0EqDq1zT4k4jVSF2ia2b2o2/DofGfmSAQGQCUOjIQGEOBMZHIKYy8Qp2Pp8LlZ3PZ7SgtT9RNiXFTV5KTdU/8UOpqhRVU8pt/lFOw0hTh/lbQc2UL4oxOfjsIw8EHAJQaAcINkEABFwCHStTUzRdBxLZ7phDIr2EGwkRgEInFAy4AgJpEuhYmaDQaYYdXg1PAAo9fAzgAQgkTgAKTQHqmEPiowDuDUAACj0AdDQJAnkRgDJRvMAhr3E7Am+h0CMIIroAAt0SgDIRX3DodpzBeoMAFLqBBBkgAAJ1AlAm4gEO9XGBrc4JQKE7R4wGQCB3AlAmiiA45D6Ss/MfCp1dyOAwCPRNgJQJn1Dovkfe5NuDQk9+CAAACOwjAG2WBPbRwn4QiEYACh0NJQyBAAiAAAiAQEQCUOiIMGEKBEAABEAABKIRgEJHQwlDIAACIAACIBCRABQ6IkyYAgEQAAEQAIFoBKDQ0VDCEAiAAAiAAAhEJACFjggTpkAABEAABEAgGgEodDSUMAQCIAACIAACEQlAoSPChCkQAAEQAAEQiEYACh0NJQyBAAiAAAiAQEQCUOiIMGEKBEAABEAABKIRgEJHQwlDIAACIAACIBCRABQ6IkyYAgEQAAEQAIFoBKDQ0VDCEAiAAAiAAAhEJACFjggTpkAABEAABEAgGgEodDSUMAQCIAACIAACEQlAoSPChCkQAAEQAAEQiEYACh0NJQyBAAiAAAiAQEQCUOiIMGEKBEAABEAABKIRgEJHQwlDIAACIAACIBCRABQ6IkyYAgEQAAEQAIFoBKDQ0VDCEAiAAAiAAAhEJACFjggTpkAABEAABEAgGgEodDSUMAQCIAACIAACEQlAoSPChCkQAAEQAAEQiEYACh0NJQyBAAiAAAiAQEQCUOiIMGEKBEAABEAABKIRgEJHQwlDIAACIAACIBCRABQ6IkyYAgEQAAEQAIFoBKDQ0VDCEAiAAAiAAAhEJACFjggTpkAABEAABEAgGgEodDSUMAQCYyVQLNb4P3ECYx3bifcLCp14gOAeCAxPYOLihO4Xi/Xwo3CSHkChJxl2dBoE2hAgiSrLE/yfIAET/TYjBmUjEYBCRwIJMyAwXgJmjoZCT5GAif54x3fCPYNCJxwcuAYCaRAwc/QU9WmCi2anyyb6aYzFiXkBhZ5YwNFdEGhPwMzRUOgpEjDRbz9uUONoAlDooxHCAAiMnYCZo6eoT86CcoKbJvpjH+VJ9g8KnWRY4BQIpETAzNE1hT5z4Srl7/gsy5P372wmqGpj6rKJfkojcjK+QKEnE2p0FAQOJWDmaKvQIfLcrHWQbr0wL55abmzTBxkJq755duZpq0cH9t8t73PG73ZYl/e3eGLieOjoQb0jCEChj4CHqiAwDQJmjraTPuWEfB4kqFKHZNo6cJDZw6oP7oB0u5UzrQrLVmppE/1pjPXEegmFTiwgcAcE0iNg5mg7cReL9fffuOX8b2bqJ13YWsGyKqVFpg8wdXyVwR2QXWjlTKvCspVa2kQ/vXE5AY+g0BMIMroIAscRMHO0nbibYvz9N24Vi/VfvPaRlO2mQq/mRfVv/oIWbKkilH6BixSqjM5cPTvT1WbL130y7y2jMufzp4ri3Ko8KdWpYNPy6qQsX1/OirlK6P+rc8Xs2Q21RWfUTfnZ8ll7mt1kVjZ1edtE7Yyxsk//5qvtbS3PURnRL1nRuGctb+2pvhAg6zoYmwROiK32/6mZh0bVuon+cWMItQ8iAIU+CBsqgcCUCJg52grGNoWW8kya7RPUShu0qGjJqS4zc5oTVLLQ8nlSrs4ZabSeGJk3ZexFWSVRRvlUutJjLrA6p78BKFOrOe3ldm35zfKporo4zXuVJ9qybKLukjCuPBSboq2icsD2S0ms8blusBJp1WKDhnFMtGKw8CV82yP9ZYXyhf+irvGwcsBEf0ojPpm+QqGTCQUcAYFUCZg52moG5YR8ugqt1Ij+sUhIFdmRKXXdetKQoqbc0vJRr6S1zhkFemFOy+vyhblaQAv7m2dnVU4907iu/vL63nsXm15tC63d3pbTbuWS00HeNGIsa/HS39OoYat2eQmYAsoIFWAaVaMm+qmOzlH7BYUedXjRORCIQcDM0awT6v5eV3pLT6ZbzOrE68vZDjH26pAQSy20wgFZnk8pi0zbruqCUeiTzfKp2fJ1+qwp/VaFtiJXK+/6U4HS6+9q7b61Lam1dT9FB5m86BQLs02oYqJRUbhu2RAQBXTFOo2qURP9GCMJNloSgEK3BIbiIDA9AmaOZp3wiHGpFfrW/dqvn12Fri730qKWFJoFlU5i75Dt3QptTg5bKZLy45zjNUKrlPjcfGY2rdTZ8vWz3KaVSpJlExaOVFYr/1Vbcs3aTIec5W7Wct0wjcp82yN9ltssl+Wvy1wPodDDH+pQ6OFjAA9AIHEC4QotxYk0u56jFKgoii/P/nJeraFJmPXp4/k5vieruqHMPZMsJUcqosrXdzzp08/V/V/1wkq56R8rXHW/GF+Nru5Ko7PW5mz8ljvF9p3lNtXlhXPVqer+OOfbhnRVSSn9szey2TW6U5L6YjIbjQqM8k4xJmAqGvt1D6HQwx+XUOjhYwAPQCBxAk2FJvWl/B2fdXmWmho37SpNX+2264U5t9yuVp998Xpoop/4IB2ne1DoccYVvQKBiATMHJ2ItNhVpl5rnlvZs9NDedh0qeFJ7dp2Y69Zxdb1OMCsv2Kg/XqxLR6a6EccUDAVSgAKHUoK5UBgsgTMHF2f0CNqw7GmEl9D07l9PrecIMZdHproT3b4D9lxKPSQ9NE2CGRBwMzRCUoLXOqcgIl+FkN1bE5CoccWUfQHBKITMHN052JQP8eL5pIgYKIffVjB4H4CUOj9jFACBCZOwMzRSQgGVLxnAib6Ez8Ihuk+FHoY7mgVBDIiYOZoKPQUCZjoZzRgx+MqFHo8sURPQKAjAjRH43PKBDoaWjC7mwAUejcf7AUBECixipryIED0B4w+FHpA+GgaBPIggDk6jzh14yWi3w3XIKtQ6CBMKAQCUyaAORrRnzKBAfsOhR4QPpoGgTwIQKHziFM3XiL63XANsgqFDsKEQiAwZQKYoxH9KRMYsO9Q6AHho2kQyIMAFDqPOHXjJaLfDdcgq1DoIEwoBAJTJoA5GtGfMoEB+w6FHhA+mgaBPAg0FVrmrG/eo81isV7fvFeW1a+zisX6Kz+6WizWtpP6fcWz5cbmlOVGvzJ6vpJ5SCdEQMY6Ibem4QoUehpxRi9B4AgCzhxdLNZPv3rC0lss1rcffF6WJUk1t/Pw0ePbDz7nYiofCs108kk40c/H8TF4CoUeQxTRBxDolIAzR2/ufEoLZadRR48fPnpck2entNnEGtqQSPSvE/1EvRypW1DokQYW3QKBeAS8c3RTfb/IeeaNU2q2WKyffO7a4q2bNS/EGpqEuTD/cJa7BiqlDW/0U3JwzL5AocccXfQNBKIQ8M7RUqFp9Xz+8odOc8ViXctkhdaJQsuySDq1sZkEAW/0k/BsAk5AoScQZHQRBI4j4J2jWaHp8vNL794+e+kGlXQ+beNGoaUq4yy35ZNkyhv9JD0doVNQ6BEGFV0CgbgEvHM0K3TzFm5qnXXaOgOFtiyySXmjn433mTsKhc48gHAfBLon4MzR5y9/yOorf2rFxZqJykej0LRu1j+7OtE/tqIT3t33BC20J8DRbF8VNY4lAIU+liDqg8DoCQTO0VysmagQGYU2P7wy94kVUOh0BxFHM10Xx+sZFHq8sUXPQCASgcA5morJs9+BFSO5CTOdEEAQO8EaZhQKHcYJpUBgwgQC52hWaBJp3pwwuTF0PTD6Y+hqen2AQqcXE3gEAokRCJyjHUl2NhPrE9wJJRAY/VBzKNeGABS6DS2UBYFJEgico72/tjp76cYkmY2n04HRH0+HU+oJFDqlaMAXEEiSAOboJMPSk1OIfk+gfc1AoX1UkAcCICAIYI4WMCaXRPQHDDkUekD4+TVNxyo+IxLIYhBgjs4iTB05ieh3BDbELBQ6hBLKVAQiKhNMZTTxIVgggElwEAJQ6EGw59qoEZWTssT/YwkYmBkMhoxczYBmbi4i+gNGDAo9IPz8mjbH6rHiBIEvyxMDM4NhkJGrGdDMzUVEf8CIQaEHhJ9f0+ZYhUJHIGBgZjAMMnI1A5q5uYjoDxgxKPSA8PNr2hyrEfQJy2gDM4NhkJGrGdDMzUVEf8CIQaEHhJ9f0+ZYhUJHIGBgZjAMMnI1A5q5uYjoDxgxKPSA8PNr2hyrNX06c+Eq5e/4LMuT9+9ssG6WBAzMDIZBRq5mQDM3FxH9ASMGhR4Qfn5Nm2PVKnSIPDdrSaEKSL8wL55abmyjuoo30ymzY/PI6j7Lm2dnHj99JfWd8AZLBsMgI1czoJmbi4j+gBGDQg8IP7+mzbFqVYdyQj4DlNiarRf2qqk3c5uFZv6R1dmg1443k6tUCQMzg2GQnKub5ayYLTcOutXck+mUKfUrqu17qYsioI5rY1rbyUV/Svj3KHTIzDudMlMaGP6+mmPVik2xWH//jVvO/2amfh2hrVUX4L35XsHzZu41xQWOrL7bTpBxA9OPOqncpqt07uTJ566RnzwJsNtPXLxWLNZnLlzlnO4TQQpt3GhV2FSa5N9m9CeJYZhOQ6HXPLnsTQwTopRaNccq65P6Ua8jz99/41axWP/Fax/JfEehV/NiviIjQsw2z/75//yZEm91upj+nVupE8K6zKrKnC1f1wLvzZR1uQlvJrf7wrwoivkLni8NXjeW58gz7YauS9vKAtkUmef/fjkTbqzOFbNnN+ZhLwZmSgHe4ovjqnNpoyxLeew4m/Su6C2G42a3Et1WheP6mZk1J/qZeZ+5u0EK7Zm8zCwzkV0YozTODYf9Ci3lmTS7NlRW5ypRXJ2bzZ4i0d0sKcHaeVKuzlkhJG2z13q1EFLm6lxRsJYbRayXrL4Q1DKfWm5+VVPQ2qje4gZpea1FvkbOVTihusDyL76XKIAGZgZTiOMqb8oEjxBWaF/HtC6ulvQNzJynVpnz+awo5quyLNUZ7Oqf3j7RMTLGKmF9zZ7QNuVny2Uzs7Kpzm2LJpQxMqQq61a0fWncdVI6ZmsYt8b8l6M85k6m2jcotBWbmoTUJuucJtNOR5o5Vi00ygn5rOHdPDvT4rqaP7VcUfq15UxLnV256mnark2rRo3OCRWsFq+0ViapVoWrkspgI1NXmamLmbQitz2q/NzjBrfOCbPWV3e0OZnm24NYQOeu0DzMaIlcLNZnL92g90PvU2hz4ddeS1aXhoVaG8nkAjqQ1KJJVlqqhbYqr5WazPBetV9nySbYktljBFcYNw6xD5Wi67qVTWYw8oQ56kfezTS7B4VuTM11bab5GmOUhq/hYKE5p68ZV02P9XqxnvO61uMX5kq0XlvOfrgymq1PcVtB1bWk4L1uVr0y06S9YuzNVCJazGZP8QK37p4r9g03TIuuGNN6mvcqUHRuwJwhqKHr8QzwUfOPiXtlhDb5kySZRwgr9JXTu1dO77750T3RttBOra5aHEWmUkQjmLUClMnaaKpsljOj7bq43tBabdbhtIo25a0rnGN02Yi5taMLV7s9Nq2tcaec6I+7s6n1DgptZ0x3jhZSjTFKA9dwsNC2KfSt+7VfPzeLKcUS57fn878yy1mtnbWlrcixcitVkNOqpDihbRav/kylpnqe9i6jRaPVSOBW5Cp5b6YW+9m5OZ0hyHNQmbhX0xdvOgnvZv1bCOtiWZZ8+lpk+hVanfmeLTdCjk0VkWWVtW5EO23K2wnY5mw1rgobJz02ra1xpzis4+5mmr2DQluxgULvHaPmWLXQmtJL528dmJ5iSmvNFVyZrt0pRvdwKRWcz5+iVZHnFjO5kFWm6J8xXjPImaysalEub+CynltT1g3zs2yurjRe/aufjReZipXapAvYY1FoGiovv3eHBJgGRrFYX//dg7IsHz56zDmffPZIjCtxttlqnhVLrbJmEW0L6GvA6joyL6+5ikarLl/T9WtaUItWqra5PPsicpREz+d2MS6qWx9EJtuYRsIc9dPobWK97FuhnbtA+TCWiQSfP4UxSuPWcLAKzddTZQSbaSt7QqKmk6nPlNagMbfEJgS/Oybu/r1tcpUu6pvC9Lcarax27UuGlCjSP3v+mtayRrr5Pi9dQUmn+rflTrG9Z7mVEWWD1d/eVqbM2mzrmMxt0/s8y8aLfp79H9TrXhU6RJ7NaHCns52zuV3Q7CzWymatsPFq0Fgl0LjhUIPTEfN+zapz2uKfcyH8uP7yJfb6txMDM4G47nMhnqti5bqv0T7387Vo3WiiTvYJRLYVL/rSKtJBBHpVaIp0yGfL2RkKHRTs4wuZY/U4xaoLVctY59W0PoXOJ/PrHTcwjw9L5xbiuZqk+NUuZtcX6J2jzaCBeNHPoLOpudi3Qjs/k6VfyjqZnmuW9amtMadDoXsaV+ZYzUsmE/XWwOwpdsc0E8/V1BRa3QhmflnFhFJzkh0bJhEv+sP4n3WrSSj07udP0a9L9Y1C+tyjuH/Hc9OQ3RvzRCXGKI1ywyFRzWt8dUvaTwMzgwkkI1czoJmbi4j+gBFLQqH3raHl716cn9PQrbm8huYEP44qzhyNMUpj1HCIQzUvQY3urYE54OEf2nRGroZ2CeWCCSD6wajiF+xboSnYez/rs6HQXbVEtotjc4usKWAX0Pqmn8bvW+pmW8gMxigNPcOhBbqDmY++ooEZ/6iObjEjV6P3HQYR/QHHQN8K3Zx2m1edGzlGgKsftu5WaLu32dbBORijNEaJAz4jEhjw4A9vGuM/nNX4SiL6A8Y0CYXe9/wpodD6YY2+h0bx6e7tT1rec7vZrnUhxiiNUXCIeKxmBDMjVyMGCKZw1A8+BpJQaGdpu2sNvef5ULX3DDaf4uQ0FL6JGQrHavRjNaNBlZGr0cMEg4j+gGOgV4Xm5yhRyLd9hgtnbyUxRmmMgkPEYzUjmBm5GjFAMIWjfvAx0LdC96apcRvCDIVjNfqxmtGgGtpV/WBP+/jNKhT6KZzyyaA7QoSfOO+As2fX0NHf4964d0Ohd11+ZpnHGKXDABwiTgcZwWy6Sk/wffK5a3Jg6OtTFaEnLl4rFuszF67GIKb0dWbfbEEm6XncUOgYgHfaaEZ/Z3HsjEkACg2FbjGecKy2gLWvaEYwHVedB+zzC6G5GCX4cx+JvfuVQsuXT6kK6qeW83kBhd5L79gCHNZjDaF+ewJQaCh0i1GDY7UFrH1FM4LpuMqbMkHdpWU05zcYVFqrXw51Wegrn4XWiSW/rmqjLdDeX83ti6ZO9Aujf2UtiBdP2dPhJnPLa69swYafyLAEtkfTlkGqIwJQaCh0i6E15LGqT2q6Kyaagg+eaam6Y9RM69Wrrpy922i192RImNt6sSXfcVWezWZJPnvpxtlLN3hTlhFWVRQNUVZl+bIKcclZJSm0VUn7BqrqXRevGYW2RfVroqkFm6mDw5m2fZMSDiLZIOBEv7EfGR0SgEJDoVsMr+ax2t/1SD11u1Nqe12s9ZaqO0Zlpm7UrtxqlemtwmZne0+aMB3z6Ww6rtImf9JZbvJWKvSV07tXTu+++dE90RGvKjsKzfHgwiZhXkJlpFrkmzhU579XpZJqtqRf+bzc6EzxklFRSfiIZJ2AE/36Tmx1SyBIoflQnHii21DkYN05Vnu9HjmIQu/U3Zp87yzpja0D01smkUzHVd50Et7N+mLaaKrqmDe9O1Of3F6x9JrCCr49kVLp91aFtiUTwZu4GxzWxP0cpXtBCj3KnrfqFMYo4XI48KZMcEm+gaiJWqgtvf6P5leRTYJHyx1aCdHO+Vy9LZBfGEjFZrNaJk3+VMyeU62WvLK2PiNalSC5VWdgK5tqxaVEhPY3/KnKk7n5yphqeNLsvMlhaCYj3b+Oqyy6L793Ry6ai8X6+u8elGX58NFjqlIs1p989kh0zGiqylKhr9RS0eQw88qXC3NCRERZ4HxVvzKlIkVJm6mjx/b5NLvwC8ntBJzoby+IPfEJQKGDmGKMEiaHA8/UfJ6zWKxDrkdaETTKp6ZPO49q+aNplgrMVySWNLm61fXcywWrkrr6nkw2pBusJnbKNAJvJn4zTnRJO9nXhKFSGduoqeT968D0lkkkM56rrKm6Z4S9KMRd2bIApzlBuv7DVcVF5NuoUXBq9rfcKcbBSwRzom7Ei36iHUzZLSh0UHQwRgmTw4E2+ZN1mu4Y4nxKfO3565Y1i5iaY/W6eLbcqPlaT688cUuZFNJYLVh55WqXTKo+1aY8LunNrC18eWIn33iTnbYaUC3C/Dblypvr+hKExbcnubyMXE2OXf4OIfoDxhAKHQQfY5QwORx400nQJq+wnU1tSp/c1kubYr7S2qd+3OoukWVwulNo9TQMPm9ubiaqKzSJscoTbkChZXyQHisBPrrH2sGU+wWFDooOxihhcjiwBjevR8rLk94L0lqVlTSqxS5pnbkUWS1t+fzyaqmuCVuR5IWxUdP6GlqKKK17uQmSXZtJKb72TC1yph0adLFc1ZY7rZ1yiyfWgiflwPSUSCYrI1eTYTYeRxD9AWMJhQ6CjzFKmAI5cLFmwuKuVFmoq7wsSOpXneXWwmpUvMqjelIkdQHSYJZ8sTQ2Gq/rV8WE3poGqxV9dSKb3TWt15fbJnfL+Xau7U0wHO/epDIzcjUpbuNwBtEfMI5Q6CD4GKOEKZADFeMVtrMZRHwChQJhpkAiI1dTwDUyHxD9AQPaWqFltNY379FmsVivb6rnEvDmV350lSdo1T25vjHdlesfk5foX9nrRF3sxa1ADjwM5Lnu2njoxdvEGwmEmUIvMnI1BVwj8wHRHzCg7RS6WKyffvWEp9pisb794POyLEmquRsPHz2+/eBzLqbyodBMJ+dE4LFKxXgAOJs5A4jpeyDMmE0eaisjVw/tIuptJYDob0XT/Y52Cr258yn/okb65ugxPa9AFvCmsYb2Ykk5M/BY9f7a6uylGyl3rX/fAmH271izxYxcbTqPnCMJIPpHAjymejuFppZ4bcQNf5HzzBunvPfJ564t3rrJe1VCrKHNLTm1O35qhdPbwBilmIBDxLGZEcyMXI0YIJjCUT/4GDhWoWn1fP7yh05PisW6lskKrRP0qxaRdGont4kZikICDhGHZkYwM3I1YoBgCkf94GPgKIWmy88vvXvbe1azttQ2Ci1VGWe5Bw9/WwcwU7cltqN8RjAzcnUHcOw6jACifxi3KLWOUujmLdzkE0UUCh0lQkkZwbEaMRwZwWy6Gumto+LB2h6yu/d6KiCrCwLN6HfRCmx6CbRT6POXP6RokTZzmkPYTFStmjU0rZv18yLkS428viWUyf1KyKchXAGHiNQzgum4Gu+to7s1ePfeiKGAqV0EnOjvKop9sQm0U+htrXMIm4mqilFoc9NYdZuYequNeU/NNuMp5HO/UnBmQB/AISL8jGA6rvKmTBAZOnPG+Q1c1fdyfeDTJS89FehZwG6rTbul5wip1pyW1hpNISMSge3RjNQAzGwnEFOh+bQ2RZQ3t7eezR6MUQpVWhwOupHhoEqdDNS0YO7souOqPLRZkkPeOqpkt/aVnLVWNs+ZnKAv9tWjWrV467RrTRpBOhoBJ/rR7MJQAIHICs2H68iCOrLuBAwMf5Emh0jXI/3NeXL1yqqa5A8S24MqeRw5PqsJ83ibHVlwXKVN/pTPSJAzwJXTu1dO7775kXraYPVP02eltVpLu+2ymYrsU2jXmmkFf6MScKIf1TaM7SEQWaGpNXno7mk/k90YozKyHLR41yPZ5J4EzeFQ6D2YYu92xj9vOgnvplxwk1/iS5LQYJVLgT1ZzsIUWpsT1mJ3G/Y0AQ4rePRPII5Ce39tNaZnSGGM23XdIQAAIABJREFU0tB0OPCmTHBJfk67Z1jTtEovilIXImfzuXpFs/rHZ0GpDGWak5q0VRVzjPDSzC7F7BuqpDHZiMe3vrIYWl8NHt6O4yqLbvOto9d/96AsS3qqINX65LNHzYY3lQgLheakClVTodUl52poqPhysJVtY63ZDnIiEHCiH8EiTAQTiKPQwc3lWhBjlCLncOCZms9zFot10PXISlzVe58r7VSzL934w7OzUWsqoadnzxpaF7dFRAlvptg/8Gh0YA7szc7mo7lK9MUXsSrDRp++rVUCLPaKW8fm8zkpdMPazk5g54EEokX/wPYnXQ0KHRR+jFHC5HCgTf5knfaeU/na89ctayuelUILWdZJO/maZfM2hdb5/FhZqkd5len5SmaKlq07g6QcmIP4ENhoRq4G9gjFwgkg+uGsopeEQgchxRglTA4H3nQStMkrbGdTmRI6SUlHoWWmjJDUWmkECi0pRU9zfKNbhsH0CSD6A8YoSKF5hp14YsA4JdK0c6yyBjevR9IuLs+JqiP7FLpSX3PlsVwt1QnxmrLXN7R0K5nnhNgv9L76BW21yB4Uq8tkUGd2N56Rq7s7gr0HEED0D4AWq0qQQsdqLF87GKMUu0AOXKyZqMbAXoVmNa5OctMaWzzwZr7yrqGVfVpo64qNapU5KHSrg5Hj2KoWCo+DAKI/YByh0EHwMUYJUyAHKsYrbGcziPgECgXCTIFERq6mgGtkPiD6AwYUCh0EH2OUMAVyoGJcmDeDWE+mEPNJv8cZuZo+zOw8RPQHDBkUOgg+xihhCuRAxbCG3j22AmHuNtLP3oxc7QfIpFpB9AcMNxQ6CD7GKGEK5OD9tdWYnmATNGj2FQqEuc9MH/szcrUPHBNrA9EfMOBQ6CD4GKOECRyChktYoYxgZuRqGHuUakEA0W8BK3ZRKHQQUYxRwgQOQcMlrFBGMDNyNYw9SrUggOi3gBW7KBQ6iCjGKGECh6DhElYoI5gZueq+L4t+fJfCr+vCRkWCpbKKfoL8jnKptUL3/bbBo3oXrTLGKKEkDviMSCDaGO3SUHP8R5oH+HUZe70/tKR6q8Z8Xr0si1oJN7XXq0kUaEZ/Et1Oo5PtFLr/tw2mQanEGKVAgEPEAZkRTMfVePNAuFgeWJJee1V/+VW4qYjRztiUE/2Me5Kh6+0UmkMlE9Rr5ymPDRT6qFjO6ZFOnic9VaehdLHVkt5EyI+NUq8npKc+1h411d+pK+5vo1/TygCHiPHOCKbjKm/KBJHZNw9UT13VLwAVz37Th7LdFrOBfS0pzR20i55Jp3LMJGByZstl9eYr5ZB51bSVaNsIV40Y01Ga4iiPsneJd6q1QnN/+FAMetsgPYmRjiZ1jJjjqjLH32r18UNqLJK6Nlc2Yr2amxQ71VUCY5TIgkPEEZYRTMdV/qU7v80s9K2jq3n90OcDX3LlTDUFmGOcM+mxrjZbp+ycopXa7LXCbKRatSNNyXaR9hNwou8vhNxuCLRWaIoWx4yPVRbsYrG+cnr3yundNz+6J3yWR4VIaxnWX47poBK7ageSyTfflOn7dP1oF63FTnJ/YxvOzB44RAxYRjAdV2mTP1mnOUG7PPNATT8bYhk4GzQnAavENZsyW1Wq1gVmMokYy1GbcqI/6r4m17lDFJqOQynJHEI+aDnH9FgeFSZtDxr+hmt2qWq+tK1iDPfyt9GdXlpNrxFwiBiTjGA6rvKmk/Bu8pd4RkcKq+VSHOP20N43G9iSxqSUYjtvWMGvvtBXEi0aNQbwdwcBDuuOMtjVEYHWCk1+NN82eP13D8qyfPjoMYWzWKw/+eyRcFoeFSZt/uqXFIWtodXhxye+hPmOkxijBBgcIg60jGA6rrLotp8HKn5GUnkKEF/IlQDvnQ2cSUBNC7RC1vKvqwvbulV1Cdz9WhAxnOM15UR/vB1NsWftFPqIHsjDhdPmthH7cwjetWUNXbtTzByUR7gVWBVjlECBQ+CACSmWEcxortplrT3jbO732j0b6O/mfGeY1uHapS5jme8Uk1MJhYPX3lXZyoWQWE26TLToT5rigZ3vTaEP9C+RahijFIg0ODTnXnosBZ1deU3cyttq+Lh3MenKvrZaWd1eOA2Y2/0TezJyVXiNZBwCiH4cjgdZgUIHYcMYJUxNDpGeXBEUBVOoqZr2JKc4W2qKh/6FQm8l1Yz71qLYMToCiP6AIYVCB8HHGCVMDod4T64IioIp5FVounLpXBwxNYL+QqG3YnLivrUcdoyRAKI/YFSh0EHwMUYJk8OBN2WCS8p7/h3KQgyF3G6WM3G3D11lNNcKVTH98Ir5qrxszmPr64nzefUcnOoWwrrBxl280mD1FJyqXeGUuczJFzUd/6NsMrQo1jo1kpGrnXKYpnFEf8C4Q6GD4GOMEiaHA9/TK38IG/QEG1bD1Xw2qx6aLO7vNb9cVUrJt/Xy7bukwXzfj7NuZoUWp77Zzp52Sb5tRa3UvDoPGirhhRyY4RX7L5mRq/3DGX2LiP6AIYZCB8HHGCVMDgfa5E/WaU7QLv+TK6pfxMyWq6WWaCPQUnn1VWUtm6y7lR7PjHRrx9y9anHstWMaUc+jc9pVNwvrpkyZhuWgoRJeyIEZXrH/khm52j+c0beI6A8YYih0EHyMUcLkcOBNJ+HdlAtu88DkX+kHt26Wsx+uWBe9ymofQ0EKXcxm/IioLWtovx16GoavXSj09kOBA7q9CPaMlgCiP2BoodBB8DFGCZPDgUX3gCdXKEUW57fn878yZ5PtSWaxDvaskkWWSFot99pRJre3i7Pc/sPBibu/EHJHSgDRHzCwUOgg+BijhCkmB7XGNaIs07WH0pgCVnflilk/40IVkb+BFmqtzNI/tkNnv81mrV1zlrtapauKuFMsftyDDjgUSohAzKM+oW7l4QoUOihOGKOECRyChktYoYxgZuRqGHuUakEA0W8BK3ZRKHQQUYxRwgQOQcMlrFBGMAd1VZwU2QXWLSYucuyqhn17CQwa/b3ejbxAa4Ue4hlSw8cAY5RiAA4Rx2JGMJuu9jgPuNK7JQT1Yup2g/m8+h0f1agX2GIF2U0Czeg3yyCnIwLtFHqgZ0h11PcWZjFGCRY4tBg0+4pmBNNxtd95IFBZa8XolwH0aeJQK2Ay8Xc/ASf6+yugRDwC7RSaQyUT5Azd1sv5DQ/Ni2vs+6gaOfa+HvPACro/aFXd72Nu76GbfegOILr5ttFa7Izt/YrdUtr2wCFifDKC6bjKmzJBZPbNA82DVwvnsnouXPMYr92sZ6cIc+CbnFqx0rxh2kq0Oudd/TNVI4Zy3KY4yuPuZpq9a63Q3A0+FNs9Q6qqr+TZHo0qU1w2snfY6uOKytUyTVX14IkNu9RdAmOU2IJDxDGWEUzHVf6VnXw0TdA8IO/Jrw5efYy7P3Ozs4GWYDrKxSJY1KWqopj+ElDNC0aqVdhE9YhRnIApJ/oT6HFCXWyt0BQtjhkfqyzYxWLtf4ZU9dhk3Xl1PNW/ytZzzA9fagdVlamPRfN92C7JO4XK/e20lfSNg0PEGGUE03GVNvmTdZoTtGvbPFA/eOUxbtJ27SuUtXnge4tJgaYVezXTGOMRQzgNU070p9HpVHp5iELTcSglmUPIBy3nyI7SIaaOl7oeqzL1HJ9Cq2W3v65so5u0tzvdNJW0VXCIGJ6MYDqu8qaT8G7yl3iFrn6Ya5hSOE3aK73Nut5i+myc/RKgUiTRxnjEEE7DFId1Gt1Nq5etFZrcP+AZUlTRHFN7z3LzQWVOhtvjU50B6+fkNscKY5RQgAMPieMTGcF0XGXRbT8PNA9eKZyc3naW2znwfcXYRhUh880eZ7kPHbJO9A81g3qHEGin0Ie0QHXUoUT/SHrFc5vMV1z9/ZrKsP6qo02/c1Dlc01RUuYe7t3emhijhAgc9g6V8AIZwYzpqvqqbf6pQ1oqqkibGaN2C5hbl25fUda4mDBRhYK/21cm7TwSHqtJl4wZ/UmDPKTzfSn0Ib6JS1AHVo9WDWOUUA7NoTn9Rgtx/4aGhtmixxm52qJXKBpGANEP49RJKSh0EFaMUcLU5NDjkysS+sYWNGj2FWrC3FdjsP0ZuToYo/E2jOgPGFsodBB8jFHC5HDo98kVUOigsdpFISfuXTQBm8kSQPQHDE3iCj0gmVrTGKOEw+HAmzLBJeU9/zWaakOfr97+nArvbQd8rVEZsJckc72uyNAacJLLyMjV5Njl7xCiP2AModBB8DFGCZPDge/plT+EDX5yhbnLz96Qa1NagPk5FdVNglqUOdPcTtjXU2uCBkqbQg7MNlX7LpuRq32jmUB7iP6AQYZCB8HHGCVMDgfa5E/WaU7QLs+TK7x38PJNt7ox+4Aao8X2vl+7gNZ3Bee5inZgBg3EgQpl5OpAhMbcLKI/YHSh0EHwMUYJk8OBN52Ed1MuuK3WKrvmDu12Cp2nLIvhxpREXqLJjFxNlGDObiH6A0YPCh0EH2OUMDkcWHQPenIFL42NQiupNr96t2ptM/XKmc9yOw+vCIpjUoUcmEn55jiTkauO59g8ngCifzzDgy1AoYPQYYwSpngcWJXFGrp2/xfrt15j65PZW+4UY1UPCmU6heLB7LxPGbnaOYvpNYDoDxhzKHQQfIxRwgQOQcMlrFBGMDNyNYw9SrUggOi3gBW76CgVWq7PFDB7nvRQfBijRA4cDh1BnnoZwWy6KnPWN+/RZrFYr2/e41/ZFYv1V350lS+FeBD0muVOC702nnNjMtY59yNL31srdL/PkJJMww+wekn1so75fCbOmvKtSdL8zjTGKOEBh53DpN3OjGA6rhaL9dOvnrD0Fov17Qefl2VJUs0UHj56fPvB51yM8wdK1KeFgZzIsVkn+jl2IV+f2yl078+QkmDDD7BaSXqblnmnFhmsFZBtbEtjjBIZcNg2Qg7Izwim4+rmzqf8gzrZcUePHz56nIw81293kE4jvY+AE/19xbE/JoF2Cs2hkglyhw5Fzvf5qF4DR//0D2WUTOr3Vukt+wvX6lc06tS0LW235NMr9H7zqxtjoXY/UXmypNWzleiGKZ+vTt7Ofjllx7wJDhGjmxFMr6tN9f0i55k3TglRsVg/+dy1xVs368ScSaAs1REqDnR7XyDfAKi/T7uPn/Nm+p40558W6k5haycBb/R31sDOaARaKzS3zJIc9gwpdRzKE810JJocsah1HxHFuzhR/zpclbfXmsVvcvQRW7VhpFp1QJriDu1KYIwSHXDYNUpa7ssIptdVqdC0ej5/+UOHQbFY1zKrx9Bwqea0wLv4INVfqel7uD3Kt2XaGUWnbIXatMCNIBFAwBv9gHooEoFAa4WmaHHM+ChlwS4Wa88zpNTxYRa7ldt8BMpvvmJVrI9BvU1H3c7ydolcE2CZLVwQpsIYcn/Dio+2FDhEDG1GML2u8rFPl59feve2Fw4XU3sdnRTHpK2748C3363lIWzS2ni1HqcHu8vj39a1TSEVQsAb/ZCKKHM8gUMUmu/V5ASHkBL8af3zHIrmuKqO27p+2/K89t1X3nx7Fktke6yb45a/itvS1sntKe7g9iKT2AMOEcOcEUyvqyy9fAs3wZFXo517x6gAKak6FO1hbrjaHN+Bb1VWzAacaesKa/ZAl1VMAfwNIOCNfkA9FIlAoLVCU5vtnyHVPJ0lDxglpfZQkstgddTRnp3l1VEqr1DrKrKG8lv5oCXa3bEXJMYoIQKHvUMlvEBGMB1Xz1/+kHJImznNxehOb9qk3185WMzitjEt8KG59cD3zgacWZ9GvNOC4wo29xHgsO4riP3xCbRT6OPatytaj0yqA9L8U7vVoav+iR9KVfV1ZfHyQaPMxjzfKcYHO7vNX7Jrpnj39gTGKLEBh+1jpPWejGAe4OrmzqcXr95yoZiD1By09GW8OvD1kd088OVxzGlOyK/z9etlNFGYFnlacF3C9j4CB0R/n0nsDyXQp0KH+pRgOYxRCspAHOR0zKPDm8l79yaa1d27mLSJZrG9lkMLDAQz1D1ZLiNXpdtIRyGA6EfBeJgRKHQQN4xRwtTk0MsTbLwy6c0MiqYu1KwOhd5Krxn3rUWxY3QEEP0BQwqFDoKPMUqYHA59PcGmqab1c5tBMXQKNW1CoR1EdtOJu92B1AQIIPoDBhkKHQQfY5QwORx4Uya4JN/q30QsxFAo5WY5c28y4GuJs+XK3Jmw3GiDuqKbWbsSSZVVYXGXg8nkdvWFSpUrnDLlO714ydCafFLLycjV1NCNwB9Ef8AgQqGD4GOMEiaHA//ehp8BWSzWQU+wYTVczWez6pnp5v5e1k4lmuamfHOvv9JOe+OuSLKWm9/d10tWwlzLnC03altotmtE7XbuDg4aL0GFHJhBdQYqlJGrAxEac7OI/oDRhUIHwccYJUwOB9rkT9ZpTtAu/xNsKu3Vi2OVNgKtVdHc1k/3/ArNtktdmWnSUnC5pDdT/4h2ZtRe9858azCOmEz6QhA0TloVcmC2qttz4Yxc7ZnMFJpD9AeMMhQ6CD7GKGFyOPCmk/BuygW3/jXdbLn5lV4jb5azH65YF+uCqts1Aqw2vD9qNwXqdSvJ9WbqX8rOZnYFzYLOXxUaTRODaJ9MKZrFzgxl5GpnDKZrGNEfMPZQ6CD4GKOEyeHAotv+CTZaB8X57fn8r8xaVV0YNmlqVuRYuTWqrIpwWpUUJ7Tds9b6gjRnqka4plVoLd5USLXm+BI0XoIKOTCD6gxUKCNXByI05mYR/QGjC4UOgo8xSphiclDqZ4RYpus3dmm9VTKqX4OmTn5XAiy1Vaa1qOqT5MZ4zSBnsjTrR2So7Nfm0nZlYjlnJ4NGSotCMWG2aPaQohm5ekj3UGcnAUR/J55ud0Khg/hijBImcAgaLmGFMoKZkath7FGqBQFEvwWs2EUTV2he6BzTb9eIOBMaahZjlEiBQ+iICSiXEcymqzKHXo9BOfQUbkoXi/VXfnSVL4UEIIlbxD3w41qfjjUZ6+n0OpGetlboXp4hxXB2HGM7dnF1StRLqjuS5vPqBz6+Ak5tvYkxSlTAwTc6DszLCKbjarFY07sxeFTcfvB5WZbOm6wePnos33N1ICa3Wv1wdvfK7fCSshbSLgEn+u5ubHdJoJ1C9/UMKe7xjmNsxy6uTolaSbplmG8c1iVqBZzKtIkxCg7egXFMZkaDynF1c+dT/kGdJODo8cNHjztYQO8/Wo1L4SVNDfz1EXCi7yuCvK4ItFNoDpVMkGt0KHJ+w195tHBaJ7Y/Fko+0UmdmqZ/6k4hu1Xd3GPvDzI3EpkcacT8yEc/ZKq6Z6hhquE6TUYdzDW+ltLO2x7ftP1O0ruMYHpdbR4RX+Q888YpwS4W6yefu7Z462aDvXl7VXXTn5oE9G2A+sg1hy3fEWiPz6MO/IYXyAgm4I1+cG0UPIpAa4Xm1liSg54hJe+2tWl99JFSqiOTUiqTZFYfrZWQmnbr6k7Pf7QGlXbrCluM2LUzvx9e/lbHNNL4izFKSMChMTQOz8gIptdVqdC0ej5/+UMHR7FY1zOVPNcPaXWomhw+uvlAZnu8ixP1I3f3gc9mkGhPwBv99mZQ4xACrRWaosUx46OUBbtYrD3PkJIiatPyYFO5SpitiLpHoFlE0+Es6trv3brIfLXNiLStKtEXAevPVoLc360lprEDHCLGOSOYXlf52KfLzy+9e9sLh4upveKoM4V3Hsg0B1RH/uEHvmkLfw8h4I3+IYZQpz2BQxRanvWl4HEI5WbtyKypIB+TnBDPipIqyrXsgc1rX1HX7jUAvEaUNecfSbQwZQw4f7mDTv7UNsEhYsQzgul1lQ/wYrGmW7gJjrwa7dw7FqDQ1bfmirM9tI858CMGbYqmvNGfIogh+txaocnJ9s+Q4oc10kVk/jpsTnDZQ9F3gpo1VBXjupSovmbzhvZwp5EKNLvE1rdGAGOU0IDD1iHSfkdGMB1Xz1/+kHJImznNxehOb9qU4k0PbW0cqpwhz3hroHxoHnPgtw8NakgCHFaZiXQ/BNop9FE+8Qp2PjfPaVLHX+NZUfY+MHGTl7m7RPxQqrJH37nVAWz+8cJYZ7ARPti5F/ytoGaKd4sExijBAAcxKI5NZgTzAFc3dz69ePWWjxFPBHSVqX5cugdyhAPf5wPyWhA4IPotrKPoTgI9KrTHj/rB6SmQShbGKEWiyUHmdPzkCu9o8WZGGTbdWa7ck+iieNydkYxc7Q7CZC0j+gOGHgodBB9jlDA5HLp/coWUSZnmqHkzeW/bhLQm023tBJV3YAbVGahQRq4ORGjMzSL6A0YXCh0EH2OUMDkcun9yhZRJmeaoeTN5b9uEtCbTbe0ElXdgBtUZqFBGrg5EaMzNIvoDRndYhR6w4+2axhglXl4OfE8vM/0iZ9+TK7T+NR5WU79Eabf0FUtvFZ+O2muZfEuCvhuhui+h+hG9vq9YZZk7FX5lb/VX9bzNcRcjJLwwI9jtwERGrnbQ+6mbRPQHHAFQ6CD4GKOEyctBKnTwkyu0+tI9vEpQ+W5eaod1lxPmh7FUUNUW6ms0V1cWVcRTLGzxRkoLOttlT4SHtrmg0RJYyAszsG7PxTJytWcyU2gO0R8wylDoIPgYo4TJy4EVusWTK/iX7tpu9bAao8JirSvktlaF8zlh4mgX0NoMr4adx89t/cW8VGhv2jR09F8vzKOtdmIgI1c76f+0jSL6A8YfCh0EH2OUMHk5sEK3eHJFTW7ND9OVuNLK2Pd4iloVFmZOmDhaIybHWxEKzXgCEt64B9RDkTEQQPQHjGKQQlOE8DlgnBJp2jlWj3hyhTpxXC1RWVNZbVUO7eQsWl83F7WyAEESlitqsgyn7Zlr1VpoczHj4MCMaTq2rYxcjd112CsR/QEHARR6TeMv5HPAOCXS9AHH6pYnVyilbDysZvfjKVhcpVoroeV/QvJN3raz3OKMurlTTDGuzO2oFS8SB8CM13g7Sxm52q5jKB1AANEPgNRVkT0K3VWzsJsngXjHqpTboVnwIr5fR+LB7NzvjFztnMX0GkD0B4w5FHpA+Pk1He9YTUihm6fF+wlMPJid+9t0VeZ0/Cw5ecrkmJ4mNOSO6Ub/dWWs+2994i1CoSc+ANp1P96xOvh0ac6oq9PhdHtaOxTHl44H83hf9lhwXO3+WXKOPztGy45d4UacktisEXCiX9uHjY4JQKE7Bjwu8zhWI8YzI5iOq90/S87BvEOGd+wKN+KUxGaNgBP92j5sdEwACt0x4HGZx7EaMZ4ZwfS6yr+yYyZf5AQ9S875bTr9HK7xgLnGQ99UO/bOwOpuPnlLYMlV7HkRfae+eHIcO4tEKAFv9EMro9xxBKDQx/GbWG0cqxEDnhFMr6tSods8S877kznze7faD+2qyw/i53CMn5fOnKhfrhaPk6NrGD4jbA2JXQS80d9VAfviEYBCx2M5AUs4ViMGOSOYXldZoQ99lhyLKycU3eoBc/5HyshFdOMX82a5XC2r5yu1pObvA7RSrz0gNmIwx2zKG/0xdzilvkGhU4pG8r7QsYrPiASSj7ly0DtHs0If+iw5FmZOlGUpHjDXFFelwbQk9j11zu41UKHQhsQxf73RP8Yg6oYTgEKHs0LJaqaOqE8wlcWocuboI54lZwS4uqTM6+DGA+b0FWf3BDVLuRJjrstK3vzdnMpxjWRBPCUnnein5Nr4fYFCjz/G6CEIHEnggDl6y7PkxGnq+XwuVLbxgDlbUjz0zfxGTj2PrhLm6t4xocP2LLe4tUwYORLG5KofEP3JMeqsw1DoztDCMAiMhUDHczQvjcfCa1z96Dj644IVuzdQ6NhEYQ8ERkeg4zkaCp30iOk4+kn3fXDnoNCDhwAOgEDqBDqeo6HQSQ+AjqOfdN8Hdw4KPXgI4AAIpE4Ac3TqEerSP0S/S7p7bEOh9wDCbhAAAczRUx4DiP6A0YdCDwgfTYNAHgQwR+cRp268RPS74RpkFQodhAmFQGDKBDBHI/pTJjBg36HQA8JH0yCQBwEodB5x6sZLRL8brkFWodBBmFAIBKZMAHM0oj9lAgP2HQo9IHw0DQJ5EIBC5xGnbrxE9LvhGmQVCh2ECYVAYMoEmnO0zKF3W1HO+uY9ftNGsVh/5UdX+QUbDYDmZ9D2IduNIm6GqVLL92bWSuiNwGLNilPPkbGeOove+w+F7h05GgSB3Ag4c3SxWD/96glLb7FY337weVmWJNXcuYePHtN7ozmnnjhAMr1VvJn1ptRWYLFmxannONGfOo5++w+F7pc3WgOBDAk4c/Tmzqe0UHa64ujxw0ePWcWdknrzAMn0VvFmNhsMLNasOPUcJ/pTx9Fv/6HQ/fJGayCQIQHvHN1U3y9ynnnjlPpXLNZPPndt8dZNt7vqnLb6J142xdppXl1lXhlZvbeqMNu0Dl6xhY02ztXL0hjnCpwjmnM9wvZuAt7o766CvbEIQKFjkYQdEBgtAe8cLRWaVs/nL3/oICgW63qm94XNRmJX8+plzo4Ve4JaSza9dtJevTbVbTF1SluX8jbnWsf2bgLe6O+ugr2xCEChY5GEHRAYLQHvHM0KTZefX3r3trf/XEzt3SzNa53lhWEjsXoFXL32mWzZRTRlm5J6rxF0k2kX0HqRPl9tac7rJjK3EvBGf2tp7IhKAAodFSeMgcAYCXjnaJbeYrGmW7ip6/JqtHPv2BbJNBKr65POzld0ylr9LcsTI+yypDolrnebTFWTypsY+L8QmL34G0bAG/2wqih1LAEo9LEEUR8ERk/AmaPPX/6QckibOc3F6E5v2pTirW+orlRULJiNxBqOlbBytirKa+gqpS8wkx5zObXiri3B1XnvZnOmGfwNI8BhDSuOUjEJQKFj0oQtEBglgQPm6M2dTy9eveWhYU5ci1u3jMSaXUZVzY1js/m8OjmuSs7ndKsZr5dNdTqLrs9wqw+Wb50jmvM4hawdBA6I/g5r2NWKABSPhfKoAAAEF0lEQVS6FS4UBoEpEsAcPcWomz4j+obEAH+h0ANAR5MgkBcBzNF5xSuut4h+XJ6trEGhW+FCYRCYIgHM0VOMuukzom9IDPAXCj0AdDQJAnkRwBydV7zieovox+XZyhoUuhUuFAaBKRLAHD3FqJs+I/qGxAB/odADQEeTIJAXAczRecUrrreIflyeraxBoVvhQmEQmCIBzNFTjLrpM6JvSAzwFwo9AHQ0CQJ5EcAcnVe84nqL6Mfl2coaFLoVLhQGgSkSwBw9xaibPiP6hsQAf6HQA0BHkyCQFwHM0XnFK663iH5cnq2sQaFb4UJhEJgiAczRU4y66TOib0gM8BcKPQB0NAkCeRFoztFnLlwtFusnn7tGHaEC/LarsiyfuHitWKzPXLiaV0/hbZNAM/rNMsjpiAAUuiOwMAsC4yHgzNEkz1KVOU0iLTelbI+HyJR64kR/Sl0fvq9Q6OFjAA9AIHECzhzNmzJBXZAK7e8Uvf+59vIpel3VfFVeNq+u0u+lsiVrr7HS77aa+40jtwMCHOUObMPkHgJQ6D2AsBsEQMCZo+WymCX57KUbZy/d4E1ZRgAUb4pczfW7nOVLnd00vUBSvwq68X5oYRTJTgk40e+0LRh3CEChHSDYBAEQcAk4czRt8mdZlqzHUqGvnN69cnr3zY/uWXNiWWxW0UKzS5FWJSuBLku1Q2+IAtYoUt0ScKLfbWOwXicAha7zwBYIgECDgDNH86aT8G6yeCurdd3V7UjRFel6SSh0Iyb9ZXBY+2sSLRkCUGhDAn9BAAS2EHDmaBbdl9+7IxfNxWJ9/XcPyrJ8+OgxVSkW608+eySsyvPYlC1UWa6hVdosoq1ay8LCKpJdEnCi32VTsO0SgEK7RLANAiDgEIg5Ryu5Nf/UmWspujJNC24qSReh6Ww3px0fsdkVgZjR78rH0dqFQo82tOgYCMQigDk6Fskc7SD6A0YNCj0gfDQNAnkQwBydR5y68RLR74ZrkFUodBAmFAKBKRPAHI3oT5nAgH2HQg8IH02DQB4EoNB5xKkbLxH9brgGWYVCB2FCIRCYMgHM0Yj+lAkM2Hco9IDw0TQI5EEACp1HnLrxEtHvhmuQVSh0ECYUAoEpE8AcjehPmcCAfYdCDwgfTYNAHgRIofE5ZQJ5jNTReQmFHl1I0SEQiE1gysqEvhOB2GMK9oIIQKGDMKEQCIAACIAACPRMAArdM3A0BwIgAAIgAAJBBKDQQZhQCARAAARAAAR6JgCF7hk4mgMBEAABEACBIAJQ6CBMKAQCIAACIAACPROAQvcMHM2BAAiAAAiAQBABKHQQJhQCARAAARAAgZ4JQKF7Bo7mQAAEQAAEQCCIABQ6CBMKgQAIgAAIgEDPBKDQPQNHcyAAAiAAAiAQROD/AdGkq5CAp2TNAAAAAElFTkSuQmCC"),
            mimeType: "image/png",
          },
        },
        "esse e o desenho do banco de dados do n8n, porque nos nao fazemos o endpoint integration? pra ser mais facil de estender.. e tambem criamos a tabela de webhook.. e etc.. analise  e me de uma resposta moderna, cleancode best pratics..",
      ],
    },
    {
      role: "model",
      parts: [
        "**Exploring Design Alternatives**\n\nI've been meticulously examining the n8n database schema, particularly the \"integration\" table's structure, in relation to our omnichannel API design. My focus has sharpened on the integration table and how its structure could inform our design choices. I'm aiming to uncover any significant benefits or drawbacks associated with mirroring their approach.\n\n\n**Evaluating Structural Parallels**\n\nMy comparison has advanced. I'm deep diving into the `credentials_entity` and how it handles different authentication types compared to our proposed approach.  I am scrutinizing the implications of adopting n8n's design for our own security considerations and scalability objectives.  The `installed_nodes` table is proving particularly relevant as I analyze its role in managing different connection types.\n\n\n**Contrasting Core Concepts**\n\nMy perspective has shifted. The focus on mirroring n8n's design is proving less relevant. The conceptual framework behind their integrations fundamentally differs from our channels approach. Their \"integration\" translates to a \"node\" that fits into a workflow, while our design centers on managing the \"state\" of external channels and services.\n\n\n**Evaluating Endpoint Structure**\n\nI've been analyzing the potential structure of a consolidated `/integrations` endpoint and how it would interact with our current API design. I'm exploring different options and approaches for organizing `/integrations` endpoint logic. I'm also considering the potential downsides of such a design and its impact on maintainability.\n\n\n**Examining Schema Comparisons**\n\nMy focus has shifted again. I'm moving from a direct comparison to a deeper conceptual analysis. n8n's design focuses on \"nodes\" and a generalized \"webhook_entity\" for trigger definitions. Our design, however, handles \"integrations\" and webhooks in relation to channels. The key difference highlights our API already has channels and corresponding logic. I'm confident our approach is more suitable for managing specific, diverse communication channels.\n\n**Revising Integration Concepts**\n\nI've refined my perspective on the integration aspect. n8n's integrations act as nodes within workflows; ours are channels. Instead of focusing on replicating a generic integration endpoint, I'm now exploring the optimal use of `/channels` and `api_credentials`. I am confident that these are sufficient for our current design. I am also evaluating whether or not an additional outbound webhook table would be beneficial.\n\n\n**Evaluating Webhook Structures**\n\nI'm now fully immersed in comparing how n8n and our API approaches outbound webhooks. We have inbound webhooks handled efficiently, so I am weighing the benefits of a `webhooks` table for outbound notifications. I believe this would be a best practice. It will enhance our system's ability to trigger external systems and add more flexibility.\n\n\n**Evaluating Architectural Differences**\n\nOur comparison has brought greater clarity. While the n8n schema is well-suited for its purpose, it's divergent from our design. Their \"integrations\" represent nodes in workflows, while ours manage channels and service connections. The primary difference is the structure of the entities that we are modeling.\n\n\n\n**Revisiting Channel Structure**\n\nI've been examining the optimal organization of channels within our API architecture, specifically evaluating whether the current use of `/channels` remains the ideal structure. We already manage different channels, so I am considering whether a `channel_type_enum` for each channel is sufficient or if an abstract channel interface would be beneficial.\n\n\n",
        "Você trouxe um ponto excelente ao mostrar o schema do n8n! Analisar schemas de projetos maduros como o n8n é uma ótima forma de aprender e questionar as próprias decisões de design.\n\nVamos analisar o schema do n8n no contexto do que ele faz e, em seguida, discutir como esses conceitos se aplicam (ou não) à sua API omnichannel, buscando as \"best practices\" que você mencionou.\n\n**Análise do Schema do n8n (Simplificada e Focada nos Pontos Relevantes):**\n\nO n8n é uma ferramenta de **automação de workflows**. Seu schema é otimizado para:\n\n1.  **`workflow_entity`**: A entidade central. Representa um fluxo de automação com nós, conexões, configurações, etc.\n2.  **`execution_entity`**: Registra cada execução de um workflow, seu status, dados, etc.\n3.  **`credentials_entity`**: Armazena credenciais para os \"nós\" (integrações) se conectarem a serviços externos (Google, Slack, etc.). Cada workflow pode usar múltiplas credenciais.\n4.  **`installed_nodes` / `installed_packages`**: Gerencia os tipos de integrações (nós) que estão disponíveis na instância do n8n. Um \"nó\" no n8n é, na prática, uma integração (ex: \"Nó do Slack\", \"Nó do Google Sheets\").\n5.  **`webhook_entity`**: Define os webhooks que podem *disparar* um workflow no n8n. Ou seja, quando uma URL específica é chamada, um workflow associado é executado.\n6.  **`user`, `project`**: Gerenciamento de usuários e projetos (para organização e possível multi-tenancy).\n\n**Por que não fazemos o endpoint `integration` e a tabela `webhook` exatamente como o n8n?**\n\nA resposta curta é: **propósitos diferentes levam a designs diferentes, mesmo que os termos (\"integração\", \"webhook\") sejam os mesmos.**\n\n1.  **O Conceito de \"Integração\" no n8n vs. Sua API Omnichannel:**\n    *   **n8n:** Uma \"integração\" é um *bloco de construção (nó)* dentro de um workflow. Você instala um \"nó do WhatsApp\" para poder enviar mensagens do WhatsApp *como parte de uma automação*. A configuração dessa integração (o nó) é parte da definição do workflow e usa uma `credentials_entity`.\n    *   **Sua API Omnichannel:** Uma \"integração\" é um *canal de comunicação direto* (WhatsApp, Telegram) que sua plataforma gerencia ou um *serviço que sua plataforma consome* (Gemini, WP-Headless).\n        *   **Canais (WhatsApp, Telegram, etc.):** No nosso design, a tabela `channels` já cumpre o papel de \"gerenciador de integrações de comunicação\". O `POST /api/v1/channels` é, efetivamente, o endpoint para \"criar/configurar uma integração\" desse tipo. A coluna `type` e `config_jsonb`/`credentials_jsonb` na tabela `channels` permite a flexibilidade para diferentes tipos de canais.\n        *   **Serviços Consumidos (IA, WP):** A tabela `api_credentials` (ou o Supabase Vault) armazena as chaves para esses serviços. A \"integração\" aqui é mais uma configuração de acesso do que uma entidade complexa como um canal.\n\n    *   **Poderíamos ter um endpoint `/integrations` genérico?**\n        *   **Prós:** Um único ponto para gerenciar todas as \"coisas externas\".\n        *   **Contras:** A configuração de um canal WhatsApp é muito diferente da configuração de uma chave API para o Gemini. Um endpoint genérico poderia se tornar complexo e menos intuitivo do que endpoints específicos como `/channels` (para coisas que *são* canais) e `/service-configurations` (ou algo similar para gerenciar `api_credentials`).\n        *   **Best Practice (Clareza e SRP):** Geralmente, endpoints mais específicos que refletem a natureza da entidade são preferíveis (Single Responsibility Principle). `channels` é uma entidade clara. Chaves de API são outra.\n\n2.  **A Tabela `webhook_entity` no n8n vs. Webhooks na Sua API Omnichannel:**\n    *   **n8n:** A `webhook_entity` no n8n define **webhooks que o n8n expõe para serem chamados por sistemas externos para *disparar workflows***. É uma forma de iniciar uma automação.\n    *   **Sua API Omnichannel:**\n        *   **Webhooks de Entrada (Inbound):** São os webhooks que *sua API recebe* de plataformas como WhatsApp, Telegram, Instagram (ex: nova mensagem recebida).\n            *   A URL desses webhooks é configurada *na plataforma externa* (você informa ao WhatsApp qual URL chamar).\n            *   Sua API Hono simplesmente tem rotas (ex: `/webhooks/whatsapp`) para *ouvir* esses webhooks.\n            *   **Não precisamos de uma tabela para *definir* esses webhooks de entrada**, pois eles são definidos pela configuração do `channel` e pelas plataformas externas. O que precisamos é de lógica robusta nos handlers Hono para processá-los (verificar assinatura, identificar o canal/contato, salvar a mensagem).\n        *   **Webhooks de Saída (Outbound - Se sua API precisar notificar outros sistemas):**\n            *   Se sua plataforma precisar notificar *outros sistemas* sobre eventos que acontecem nela (ex: \"novo lead criado, envie um webhook para o Zapier do cliente\"), **então SIM, uma tabela `webhooks` ou `event_subscriptions` faria todo o sentido.**\n            *   Essa tabela armazenaria: `organization_id`, `event_type` (e.g., 'lead.created', 'message.received'), `target_url`, `authentication_details_jsonb`, `is_active`, etc.\n            *   Nesse caso, o design do n8n para `webhook_entity` (adaptado) seria uma boa inspiração.\n\n**Proposta Moderna, Clean Code, Best Practices para sua API:**\n\nMantendo o nosso design anterior como base, e incorporando as boas ideias da sua pergunta:\n\n**1. Gerenciamento de \"Integrações\" (Canais e Serviços):**\n\n*   **Mantenha a tabela `channels`:** Ela é perfeita para gerenciar integrações que são canais de comunicação. A flexibilidade do `type`, `config_jsonb`, e `credentials_jsonb` (idealmente usando Supabase Vault para segredos) é fundamental.\n    *   **Extensibilidade:** Para adicionar um novo tipo de canal (ex: \"Viber\"):\n        1.  Adicione `'viber'` ao `channel_type_enum`.\n        2.  No frontend, permita a seleção de \"Viber\" e colete as `config` e `credentials` necessárias.\n        3.  No backend (Hono), na camada de `services/` (ex: `src/services/viber.service.ts`), implemente a lógica para enviar/receber mensagens via API do Viber.\n        4.  O `messages.services.ts` no módulo API roteará as chamadas para o `viber.service.ts` quando o `channel.type` for 'viber'.\n*   **Mantenha a tabela `api_credentials` (ou use Supabase Vault):** Para chaves de API de serviços que sua plataforma consome (Gemini, Anthropic, Facebook CAPI, GTM Server-Side API Key se necessário, etc.).\n    *   Um endpoint como `POST /api/v1/service-credentials` poderia gerenciar isso.\n\n**2. Webhooks:**\n\n*   **Para Webhooks de Entrada (WhatsApp, Telegram, Instagram, GTM Server-Side enviando para sua API):**\n    *   **Nenhuma tabela adicional é necessária para *definir* esses webhooks.**\n    *   As rotas Hono em `src/webhooks/` (ex: `/webhooks/whatsapp`) são os handlers.\n    *   **Best Practice:**\n        *   **Verificação de Assinatura:** Absolutamente crucial. Implemente middleware em `src/webhooks/middleware/verifySignature.ts` para cada tipo de webhook que suporta isso (WhatsApp, Instagram).\n        *   **Processamento Assíncrono (Opcional, para Alto Volume):** Se o processamento do webhook for demorado, o handler do webhook deve apenas validar, enfileirar a tarefa (ex: usando BullMQ com Redis, ou Supabase Edge Functions com background tasks se disponível/adequado), e retornar 200 OK rapidamente. Um worker separado processaria a fila.\n        *   **Idempotência:** Se possível, projete seus handlers para serem idempotentes.\n*   **Para Webhooks de Saída (Sua API notificando sistemas externos):**\n    *   **Crie uma nova tabela `event_subscriptions` (ou `outbound_webhooks`):**\n        ```sql\n        CREATE TYPE event_subscription_status_enum AS ENUM ('active', 'inactive', 'failed_temporarily');\n\n        CREATE TABLE event_subscriptions (\n            id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n            organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,\n            name TEXT, -- Nome descritivo dado pelo usuário\n            event_type TEXT NOT NULL, -- e.g., 'contact.created', 'lead.status_changed::won', 'message.inbound.received'\n            target_url TEXT NOT NULL,\n            http_method TEXT DEFAULT 'POST', -- Geralmente POST\n            headers_jsonb JSONB, -- Para headers customizados, incluindo autenticação (e.g., Bearer token)\n            payload_template_jsonb JSONB, -- Opcional: um template para formatar o payload\n            is_active BOOLEAN DEFAULT TRUE,\n            last_attempt_at TIMESTAMPTZ,\n            last_success_at TIMESTAMPTZ,\n            failure_count INTEGER DEFAULT 0,\n            status event_subscription_status_enum DEFAULT 'active',\n            -- secret_for_signature TEXT, -- Se você quiser que o sistema receptor verifique a assinatura da sua API\n            created_at TIMESTAMPTZ DEFAULT NOW(),\n            updated_at TIMESTAMPTZ DEFAULT NOW()\n        );\n        -- Index: organization_id, event_type, is_active\n        ```\n    *   **API Endpoints:**\n        *   `POST /api/v1/event-subscriptions`: Criar uma nova subscrição de webhook.\n        *   `GET /api/v1/event-subscriptions`: Listar.\n        *   `PUT /api/v1/event-subscriptions/{id}`: Atualizar.\n        *   `DELETE /api/v1/event-subscriptions/{id}`: Deletar.\n    *   **Lógica de Disparo:**\n        *   Quando um evento relevante ocorrer na sua aplicação (ex: um lead é criado no `leads.services.ts`), sua lógica de serviço deve verificar se há `event_subscriptions` ativas para `organization_id` e `event_type`.\n        *   Para cada subscrição, construa o payload e envie a requisição HTTP para a `target_url`.\n        *   Implemente retentativas com backoff exponencial para falhas.\n        *   Registre o sucesso/falha na tabela `event_subscriptions`.\n\n**3. Estrutura da API (Reafirmando e Refinando):**\n\nA estrutura modular que discutimos anteriormente (`src/api/v1/modules/`, `src/webhooks/`, `src/services/`) é uma excelente base e segue \"clean code\" e \"best practices\":\n\n*   **Clareza:** Fácil de encontrar onde a lógica para uma funcionalidade específica reside.\n*   **Testabilidade:** Módulos e serviços menores são mais fáceis de testar isoladamente.\n*   **Manutenibilidade:** Alterações em um módulo têm menos probabilidade de afetar outros.\n*   **SRP (Single Responsibility Principle):**\n    *   `*.routes.ts`: Lida com roteamento HTTP, validação de entrada básica e delegação para serviços.\n    *   `*.services.ts` (nos módulos API): Orquestra a lógica de negócios, interage com o Supabase e chama outros serviços (como os de `src/services/`).\n    *   `src/services/*.service.ts`: Encapsula a lógica de comunicação com uma API de terceiro específica (ex: `whatsapp.service.ts` sabe como formatar e enviar uma mensagem via API do WhatsApp). Isso é crucial para extensibilidade e isolamento.\n\n**Conclusão e Resumo das \"Best Practices\" Aplicadas:**\n\n*   **Modelagem de Dados Orientada ao Domínio:** Seu schema de banco de dados (`channels`, `contacts`, `messages`, `leads`, etc.) reflete as entidades principais da *sua* aplicação omnichannel. Não tente forçar o schema de uma ferramenta de workflow (n8n) em um sistema de comunicação e CRM.\n*   **Endpoints Específicos e Intuitivos:** `POST /channels` é mais claro para \"adicionar um canal WhatsApp\" do que um `POST /integrations` genérico que precisaria de um `type` e lógica complexa de dispatch.\n*   **Flexibilidade com JSONB e Tipos Enum:** Permite que tabelas como `channels` e `messages` suportem diferentes tipos de integrações e conteúdos sem alterar o schema fundamental constantemente.\n*   **Camada de Serviço para Lógica de Terceiros:** Isolar a comunicação com APIs externas (WhatsApp, Gemini) em seus próprios módulos de serviço (`src/services/`) é vital para a manutenibilidade e para adicionar novas integrações sem bagunçar a lógica principal dos seus módulos API.\n*   **Segurança em Primeiro Lugar:** Criptografia de credenciais (Supabase Vault é ideal), verificação de assinatura para webhooks de entrada.\n*   **Webhooks de Saída Dedicados (se necessário):** Se sua plataforma precisa notificar ativamente outros sistemas, uma tabela `event_subscriptions` e uma lógica robusta de disparo/retentativa são essenciais.\n*   **Escalabilidade e Confiabilidade:** Considere processamento assíncrono para webhooks de entrada de alto volume e para o disparo de webhooks de saída.\n\nAo adotar esses princípios, você cria uma API que é ao mesmo tempo poderosa, flexível para estender com novas integrações e alinhada com as práticas modernas de desenvolvimento de software. O schema do n8n é uma ótima referência para o problema que *ele* resolve; seu schema deve ser uma ótima solução para o problema que *você* está resolvendo.",
      ],
    },
    {
      role: "user",
      parts: [
        "me reenvie a estrutura completa, irei usar o supabase vault, e tambem tera outputs, pois irei criar workflows de automacao para esses canais.. e etc com conexoes externas armazenando pra cada organizacao.. ",
      ],
    },
    {
      role: "model",
      parts: [
        "Entendido! Se você vai adicionar funcionalidades de workflow e automação, e precisa armazenar conexões externas por organização (similar ao conceito de \"Credentials\" do n8n, mas talvez mais focado para seus workflows), então precisamos expandir o design.\n\nA ideia é manter a clareza do sistema omnichannel principal e adicionar as camadas de workflow de forma que complementem, sem tornar o core excessivamente complexo.\n\n**Princípios Adicionais para Workflows e Conexões:**\n\n1.  **Separação de Conceitos:** Workflows e suas execuções são distintos dos canais de comunicação, embora interajam fortemente.\n2.  **Conexões Reutilizáveis:** As organizações precisarão configurar \"conexões\" (credenciais autenticadas) para serviços externos que serão usados nos workflows (ex: Google Sheets, Slack, outra API CRM).\n3.  **Supabase Vault:** Perfeito para armazenar os segredos dessas conexões. O que armazenamos no banco é a *referência* ao segredo no Vault e metadados.\n\n---\n\n**I. Esquema do Banco de Dados (Supabase - PostgreSQL) - ATUALIZADO COM WORKFLOWS E CONEXÕES**\n\nAs tabelas anteriores (organizations, user\\_profiles, channels, contacts, messages, leads, tracked\\_events, ai\\_interactions\\_log, content\\_cache, projects, tasks, live\\_chat\\_sessions) permanecem como definidas anteriormente.\n\n**Novas Tabelas / Tabelas Modificadas para Workflows e Conexões:**\n\n```sql\n-- Tabela para armazenar \"Conexões\" (Credenciais Autenticadas para Workflows)\n-- Esta substitui/complementa a 'api_credentials' anterior, tornando-a mais focada em workflows.\nCREATE TYPE connection_status_enum AS ENUM ('active', 'error', 'requires_reauth');\nCREATE TABLE connections (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,\n    name TEXT NOT NULL, -- Nome dado pelo usuário para a conexão (e.g., \"Meu Google Drive Pessoal\")\n    service_type TEXT NOT NULL, -- Tipo de serviço (e.g., 'google_sheets', 'slack', 'hubspot', 'custom_api')\n    -- Metadados não sensíveis sobre a conexão (e.g., email da conta Google, ID do time Slack)\n    metadata JSONB,\n    -- Referência ao(s) segredo(s) no Supabase Vault.\n    -- Ex: {\"access_token_vault_id\": \"uuid_do_vault\", \"refresh_token_vault_id\": \"uuid_do_vault_refresh\"}\n    vault_secret_references JSONB NOT NULL,\n    status connection_status_enum DEFAULT 'active',\n    last_tested_at TIMESTAMPTZ,\n    scopes_granted TEXT[], -- Opcional: escopos OAuth concedidos\n    created_by_user_id UUID REFERENCES user_profiles(id) ON DELETE SET NULL,\n    created_at TIMESTAMPTZ DEFAULT NOW(),\n    updated_at TIMESTAMPTZ DEFAULT NOW(),\n    UNIQUE (organization_id, name)\n);\n-- RLS: Apenas usuários autorizados da organização podem acessar/gerenciar.\n-- Index: organization_id, service_type\n\n-- Workflows (Definições)\nCREATE TABLE workflows (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,\n    name TEXT NOT NULL,\n    description TEXT,\n    -- A definição do workflow (e.g., JSON descrevendo nós, conexões entre nós, configurações)\n    -- Similar ao `nodes` e `connections` do n8n.\n    definition JSONB NOT NULL,\n    is_active BOOLEAN DEFAULT TRUE,\n    trigger_type TEXT, -- e.g., 'webhook', 'schedule', 'event_bus', 'manual'\n    trigger_config JSONB, -- Configurações específicas do trigger (e.g., cron string para schedule, path para webhook)\n    -- Se o trigger for 'webhook', este é o path único gerado para ele.\n    -- Opcional: pode ser parte do trigger_config ou um campo separado para facilitar a consulta.\n    webhook_path TEXT UNIQUE,\n    created_by_user_id UUID REFERENCES user_profiles(id) ON DELETE SET NULL,\n    version INTEGER DEFAULT 1,\n    latest_version_id UUID, -- FK para workflow_versions se versionamento detalhado\n    created_at TIMESTAMPTZ DEFAULT NOW(),\n    updated_at TIMESTAMPTZ DEFAULT NOW()\n);\n-- RLS: Acesso pela organização.\n-- Index: organization_id, is_active, trigger_type\n-- Se usar latest_version_id, adicionar FK para workflow_versions\n-- ALTER TABLE workflows ADD CONSTRAINT fk_latest_version FOREIGN KEY (latest_version_id) REFERENCES workflow_versions(id);\n\n\n-- Histórico de Versões de Workflows (Opcional, mas recomendado para workflows)\nCREATE TABLE workflow_versions (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    workflow_id UUID NOT NULL REFERENCES workflows(id) ON DELETE CASCADE,\n    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE, -- Denormalizado para RLS\n    version INTEGER NOT NULL,\n    definition JSONB NOT NULL,\n    notes TEXT, -- Notas sobre esta versão\n    created_by_user_id UUID REFERENCES user_profiles(id) ON DELETE SET NULL,\n    created_at TIMESTAMPTZ DEFAULT NOW(),\n    UNIQUE (workflow_id, version)\n);\n-- RLS: Acesso pela organização.\n-- Index: workflow_id\n\n-- Execuções de Workflows\nCREATE TYPE workflow_execution_status_enum AS ENUM ('pending', 'running', 'completed', 'failed', 'waiting', 'cancelled');\nCREATE TABLE workflow_executions (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    workflow_id UUID NOT NULL REFERENCES workflows(id) ON DELETE CASCADE,\n    workflow_version_id UUID REFERENCES workflow_versions(id) ON DELETE SET NULL, -- Versão que foi executada\n    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE, -- Denormalizado para RLS\n    status workflow_execution_status_enum DEFAULT 'pending',\n    trigger_event_data JSONB, -- Dados do evento que disparou o workflow\n    started_at TIMESTAMPTZ,\n    ended_at TIMESTAMPTZ,\n    -- Dados de entrada e saída de cada nó/passo podem ser armazenados aqui ou em tabela separada\n    -- Para simplificar inicialmente, podemos ter um log geral.\n    -- Se for muito granular, uma tabela `workflow_execution_steps_log` pode ser melhor.\n    execution_data JSONB, -- Resultado final ou dados importantes da execução\n    error_details JSONB, -- Detalhes se a execução falhou\n    retry_of_execution_id UUID REFERENCES workflow_executions(id) ON DELETE SET NULL,\n    created_at TIMESTAMPTZ DEFAULT NOW()\n);\n-- RLS: Acesso pela organização.\n-- Index: workflow_id, organization_id, status, created_at\n\n-- Log de Passos da Execução de Workflow (se precisar de detalhamento granular)\nCREATE TABLE workflow_execution_step_logs (\n    id BIGSERIAL PRIMARY KEY,\n    workflow_execution_id UUID NOT NULL REFERENCES workflow_executions(id) ON DELETE CASCADE,\n    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE, -- Denormalizado\n    node_id TEXT NOT NULL, -- ID do nó na definição do workflow\n    node_type TEXT,\n    status TEXT, -- 'success', 'error'\n    input_data JSONB,\n    output_data JSONB,\n    error_message TEXT,\n    started_at TIMESTAMPTZ,\n    duration_ms INTEGER,\n    timestamp TIMESTAMPTZ DEFAULT NOW()\n);\n-- Index: workflow_execution_id\n\n-- Webhooks de Saída (Sua API notificando sistemas externos - mantido da sugestão anterior)\n-- Esta tabela `event_subscriptions` é para webhooks que sua plataforma *envia*\n-- baseados em eventos do sistema (e.g., \"novo lead\").\nCREATE TYPE event_subscription_status_enum AS ENUM ('active', 'inactive', 'failed_temporarily');\nCREATE TABLE event_subscriptions (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,\n    name TEXT,\n    event_type TEXT NOT NULL, -- e.g., 'contact.created', 'workflow.execution.failed::workflow_id_abc'\n    target_url TEXT NOT NULL,\n    http_method TEXT DEFAULT 'POST',\n    headers_jsonb JSONB,\n    payload_template_jsonb JSONB,\n    is_active BOOLEAN DEFAULT TRUE,\n    last_attempt_at TIMESTAMPTZ,\n    last_success_at TIMESTAMPTZ,\n    failure_count INTEGER DEFAULT 0,\n    status event_subscription_status_enum DEFAULT 'active',\n    created_at TIMESTAMPTZ DEFAULT NOW(),\n    updated_at TIMESTAMPTZ DEFAULT NOW()\n);\n-- Index: organization_id, event_type, is_active\n```\n\n**Considerações sobre Supabase Vault e a tabela `connections`:**\n\n*   **Supabase Vault:** Use-o para armazenar os valores reais dos segredos (API keys, tokens de acesso, refresh tokens, etc.).\n*   **Tabela `connections`:**\n    *   `vault_secret_references`: Armazena um JSONB com os UUIDs dos segredos correspondentes no Vault.\n        Ex: `{ \"api_key_vault_id\": \"vault_secret_uuid_for_apikey\", \"oauth_access_token_vault_id\": \"vault_secret_uuid_for_accesstoken\" }`\n    *   Quando um workflow precisar usar uma conexão, sua API Hono:\n        1.  Recupera a `connection` do banco.\n        2.  Usa os `vault_secret_references` para buscar os segredos reais do Supabase Vault (isso é feito no backend, o cliente nunca vê os segredos).\n        3.  Usa os segredos para autenticar com o serviço externo.\n    *   **OAuth Flow:** Para conexões OAuth2, sua API Hono precisará de endpoints para lidar com o redirecionamento do provedor OAuth, troca de código por token, e armazenamento seguro dos tokens (access e refresh) no Vault, atualizando as `vault_secret_references` na tabela `connections`.\n\n---\n\n**II. Estrutura da API Hono (Modular) - ATUALIZADA COM WORKFLOWS E CONEXÕES**\n\nA estrutura geral permanece, mas adicionamos novos módulos.\n\n```\n/src\n  ├── index.ts            # Entry point principal da aplicação Hono\n  |\n  ├── api/\n  │   └── v1/\n  │       ├── index.ts        # Router principal da v1\n  │       │\n  │       ├── middleware/     # (auth.ts, validation.ts, rbac.ts - como antes)\n  │       │\n  │       ├── modules/\n  │       │   │\n  │       │   ├── organizations/ # (Como antes)\n  │       │   ├── channels/      # (Como antes)\n  │       │   ├── contacts/      # (Como antes)\n  │       │   ├── messages/      # (Como antes)\n  │       │   ├── leads/         # (Como antes)\n  │       │   ├── analytics/     # (Como antes)\n  │       │   ├── ai/            # (Como antes)\n  │       │   ├── content/       # (Como antes)\n  │       │   ├── projects/      # (Como antes)\n  │       │   ├── livechat/      # (Como antes)\n  │       │   ├── metrics/       # (Como antes)\n  │       │   │\n  │       │   ├── connections/   # NOVO: Gerenciamento de Conexões com serviços externos\n  │       │   │   ├── connections.routes.ts  // CRUD para conexões, OAuth handlers\n  │       │   │   ├── connections.services.ts // Lógica para testar, gerenciar segredos no Vault\n  │       │   │   └── connections.validators.ts\n  │       │   │\n  │       │   ├── workflows/     # NOVO: Gerenciamento de definições de workflow\n  │       │   │   ├── workflows.routes.ts    // CRUD para workflows, trigger manual\n  │       │   │   ├── workflows.services.ts  // Lógica de validação da definição, versionamento\n  │       │   │   └── workflows.validators.ts\n  │       │   │\n  │       │   ├── workflow_executions/ # NOVO: Gerenciamento e visualização de execuções\n  │       │   │   ├── workflow_executions.routes.ts // Listar, obter detalhes, talvez re-executar\n  │       │   │   ├── workflow_executions.services.ts\n  │       │   │   └── workflow_executions.validators.ts\n  │       │   │\n  │       │   └── event_subscriptions/ # NOVO (ou renomeado de 'outbound_webhooks'): Para webhooks de saída\n  │       │       ├── event_subscriptions.routes.ts\n  │       │       ├── event_subscriptions.services.ts\n  │       │       └── event_subscriptions.validators.ts\n  │\n  ├── webhooks/             # Webhooks de ENTRADA (como antes)\n  │   ├── index.ts\n  │   ├── whatsapp.ts\n  │   ├── telegram.ts\n  │   ├── instagram.ts\n  │   ├── gtm_server.ts\n  │   ├── workflow_trigger.ts # NOVO: Handler genérico para webhooks que disparam workflows\n  │                           # (ex: /webhooks/workflow/{workflow_webhook_path})\n  │   └── middleware/       # (verifySignature.ts - como antes)\n  │\n  ├── core/                 # (Como antes: supabase.ts, encryption.ts, logger.ts, errors.ts)\n  │\n  ├── services/             # (Como antes: whatsapp.service.ts, gemini.service.ts, etc.)\n  │   │                     # ADICIONAL:\n  │   └── oauth_client.service.ts # Utilitários para fluxos OAuth2 com vários provedores\n  │\n  ├── workflow_engine/      # NOVO: Lógica central para executar workflows\n  │   ├── index.ts          # Ponto de entrada para iniciar a execução de um workflow\n  │   ├── executor.ts       # Interpreta a definição do workflow e executa os nós\n  │   ├── node_handlers/    # Lógica específica para cada tipo de nó do workflow\n  │   │   ├── http_request.handler.ts\n  │   │   ├── send_message.handler.ts // (usaria channels.service.ts)\n  │   │   ├── ai_prompt.handler.ts    // (usaria ai.service.ts)\n  │   │   ├── delay.handler.ts\n  │   │   └── ...             # Outros tipos de nós (planilhas, CRM, etc.)\n  │   └── trigger_manager.ts  # Gerencia triggers (agenda, escuta eventos do sistema)\n  │\n  ├── types/                # (Como antes)\n  │\n  ├── jobs/                 # (Como antes - pode ser usado para workers de workflow, retentativas)\n  │\n  ├── config/               # (Como antes)\n  │\n  └── tests/                # (Como antes)\n```\n\n**Explicação das Novas Partes da Estrutura da API:**\n\n*   **`api/v1/modules/connections/`**:\n    *   Endpoints para o usuário criar, listar, atualizar e deletar \"Conexões\".\n    *   Crucial: Endpoints para lidar com o fluxo OAuth2 se a conexão usar OAuth (ex: `/connections/google/oauth/initiate`, `/connections/google/oauth/callback`).\n    *   `connections.services.ts` interage com o Supabase Vault.\n*   **`api/v1/modules/workflows/`**:\n    *   Endpoints para criar/gerenciar as *definições* dos workflows.\n    *   O payload para criar/atualizar um workflow incluiria o JSON da `definition`.\n*   **`api/v1/modules/workflow_executions/`**:\n    *   Endpoints para listar execuções, ver logs (talvez os `workflow_execution_step_logs`), status, etc.\n*   **`webhooks/workflow_trigger.ts`**:\n    *   Uma rota Hono como `/webhooks/workflow/:workflow_path_identifier` que:\n        1.  Busca o `workflow` no banco de dados pelo `workflow_path_identifier`.\n        2.  Inicia uma nova `workflow_execution` (via `workflow_engine`).\n        3.  Retorna 200 OK.\n*   **`workflow_engine/`**: Esta é a parte mais complexa e o \"coração\" da sua funcionalidade de automação.\n    *   **`executor.ts`**: Recebe uma definição de workflow e os dados do trigger. Itera sobre os nós, chama os `node_handlers` apropriados, passa dados entre eles.\n    *   **`node_handlers/`**: Cada tipo de ação que um workflow pode realizar (fazer uma requisição HTTP, enviar uma mensagem via um canal omnichannel, chamar uma IA, esperar, etc.) tem seu próprio handler. Estes handlers usarão as `connections` configuradas para autenticar com serviços externos.\n    *   **`trigger_manager.ts`**:\n        *   Para triggers de `schedule`: precisa de um mecanismo de cron (pode ser um job rodando no servidor, ou se usar Supabase, pode usar `pg_cron`).\n        *   Para triggers baseados em eventos internos da sua plataforma (ex: \"novo lead criado\"): precisa de um sistema de \"escuta\" de eventos (pode ser um pub/sub simples ou ganchos nos seus services).\n\n**Fluxo de Criação e Execução de um Workflow (Exemplo):**\n\n1.  **Usuário cria uma Conexão:**\n    *   UI chama `POST /api/v1/connections` (ex: para Google Sheets).\n    *   Se OAuth, a API Hono guia pelo fluxo OAuth. Tokens são salvos no Vault, referências na tabela `connections`.\n2.  **Usuário cria um Workflow:**\n    *   UI (um construtor visual de workflows) envia a `definition` JSON para `POST /api/v1/workflows`.\n    *   Um nó no workflow pode ser \"Adicionar Linha ao Google Sheet\" e é configurado para usar a \"Conexão Google Sheets\" criada no passo 1.\n    *   O trigger é definido como um webhook com um `webhook_path` gerado.\n3.  **Webhook Dispara o Workflow:**\n    *   Um sistema externo chama `POST /webhooks/workflow/{generated_path}`.\n    *   O `workflow_trigger.ts` handler identifica o workflow.\n    *   Ele chama o `workflow_engine` para iniciar uma nova `workflow_execution`, passando os dados do payload do webhook.\n4.  **Workflow Engine Executa:**\n    *   O `executor.ts` lê o primeiro nó.\n    *   Se for o nó \"Adicionar Linha ao Google Sheet\":\n        *   O handler do nó (`google_sheets.handler.ts` dentro de `node_handlers/`) é chamado.\n        *   Ele recupera a `connection` relevante.\n        *   Usa o `connections.services.ts` para obter os tokens reais do Vault.\n        *   Faz a chamada API para o Google Sheets.\n        *   Registra o passo em `workflow_execution_step_logs`.\n    *   Passa para o próximo nó.\n\nEste design expandido é significativamente mais complexo, mas lhe dá a base para construir uma poderosa plataforma omnichannel com capacidades de automação integradas, utilizando Supabase Vault para segurança de credenciais. Comece implementando as partes principais e adicione a complexidade do workflow engine gradualmente.",
      ],
    },
    {
      role: "user",
      parts: [
        "e sobre essa tabela do chatwhoot? o que podemos aproveitar para integrar os livechat... e etc?\n# This file is auto-generated from the current state of the database. Instead\n# of editing this file, please use the migrations feature of Active Record to\n# incrementally modify your database, and then regenerate this schema definition.\n#\n# This file is the source Rails uses to define your schema when running `bin/rails\n# db:schema:load`. When creating a new database, `bin/rails db:schema:load` tends to\n# be faster and is potentially less error prone than running all of your\n# migrations from scratch. Old migrations may fail to apply correctly if those\n# migrations use external dependencies or application code.\n#\n# It's strongly recommended that you check this file into your version control system.\n\nActiveRecord::Schema[7.1].define(version: 2025_05_23_031839) do\n  # These extensions should be enabled to support this database\n  enable_extension \"pg_stat_statements\"\n  enable_extension \"pg_trgm\"\n  enable_extension \"pgcrypto\"\n  enable_extension \"plpgsql\"\n  enable_extension \"vector\"\n\n  create_table \"access_tokens\", force: :cascade do |t|\n    t.string \"owner_type\"\n    t.bigint \"owner_id\"\n    t.string \"token\"\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.index [\"owner_type\", \"owner_id\"], name: \"index_access_tokens_on_owner_type_and_owner_id\"\n    t.index [\"token\"], name: \"index_access_tokens_on_token\", unique: true\n  end\n\n  create_table \"account_users\", force: :cascade do |t|\n    t.bigint \"account_id\"\n    t.bigint \"user_id\"\n    t.integer \"role\", default: 0\n    t.bigint \"inviter_id\"\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.datetime \"active_at\", precision: nil\n    t.integer \"availability\", default: 0, null: false\n    t.boolean \"auto_offline\", default: true, null: false\n    t.bigint \"custom_role_id\"\n    t.index [\"account_id\", \"user_id\"], name: \"uniq_user_id_per_account_id\", unique: true\n    t.index [\"account_id\"], name: \"index_account_users_on_account_id\"\n    t.index [\"custom_role_id\"], name: \"index_account_users_on_custom_role_id\"\n    t.index [\"user_id\"], name: \"index_account_users_on_user_id\"\n  end\n\n  create_table \"accounts\", id: :serial, force: :cascade do |t|\n    t.string \"name\", null: false\n    t.datetime \"created_at\", precision: nil, null: false\n    t.datetime \"updated_at\", precision: nil, null: false\n    t.integer \"locale\", default: 0\n    t.string \"domain\", limit: 100\n    t.string \"support_email\", limit: 100\n    t.bigint \"feature_flags\", default: 0, null: false\n    t.integer \"auto_resolve_duration\"\n    t.jsonb \"limits\", default: {}\n    t.jsonb \"custom_attributes\", default: {}\n    t.integer \"status\", default: 0\n    t.jsonb \"internal_attributes\", default: {}, null: false\n    t.jsonb \"settings\", default: {}\n    t.index [\"status\"], name: \"index_accounts_on_status\"\n  end\n\n  create_table \"action_mailbox_inbound_emails\", force: :cascade do |t|\n    t.integer \"status\", default: 0, null: false\n    t.string \"message_id\", null: false\n    t.string \"message_checksum\", null: false\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.index [\"message_id\", \"message_checksum\"], name: \"index_action_mailbox_inbound_emails_uniqueness\", unique: true\n  end\n\n  create_table \"active_storage_attachments\", force: :cascade do |t|\n    t.string \"name\", null: false\n    t.string \"record_type\", null: false\n    t.bigint \"record_id\", null: false\n    t.bigint \"blob_id\", null: false\n    t.datetime \"created_at\", precision: nil, null: false\n    t.index [\"blob_id\"], name: \"index_active_storage_attachments_on_blob_id\"\n    t.index [\"record_type\", \"record_id\", \"name\", \"blob_id\"], name: \"index_active_storage_attachments_uniqueness\", unique: true\n  end\n\n  create_table \"active_storage_blobs\", force: :cascade do |t|\n    t.string \"key\", null: false\n    t.string \"filename\", null: false\n    t.string \"content_type\"\n    t.text \"metadata\"\n    t.bigint \"byte_size\", null: false\n    t.string \"checksum\"\n    t.datetime \"created_at\", precision: nil, null: false\n    t.string \"service_name\", null: false\n    t.index [\"key\"], name: \"index_active_storage_blobs_on_key\", unique: true\n  end\n\n  create_table \"active_storage_variant_records\", force: :cascade do |t|\n    t.bigint \"blob_id\", null: false\n    t.string \"variation_digest\", null: false\n    t.index [\"blob_id\", \"variation_digest\"], name: \"index_active_storage_variant_records_uniqueness\", unique: true\n  end\n\n  create_table \"agent_bot_inboxes\", force: :cascade do |t|\n    t.integer \"inbox_id\"\n    t.integer \"agent_bot_id\"\n    t.integer \"status\", default: 0\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.integer \"account_id\"\n  end\n\n  create_table \"agent_bots\", force: :cascade do |t|\n    t.string \"name\"\n    t.string \"description\"\n    t.string \"outgoing_url\"\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.bigint \"account_id\"\n    t.integer \"bot_type\", default: 0\n    t.jsonb \"bot_config\", default: {}\n    t.index [\"account_id\"], name: \"index_agent_bots_on_account_id\"\n  end\n\n  create_table \"applied_slas\", force: :cascade do |t|\n    t.bigint \"account_id\", null: false\n    t.bigint \"sla_policy_id\", null: false\n    t.bigint \"conversation_id\", null: false\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.integer \"sla_status\", default: 0\n    t.index [\"account_id\", \"sla_policy_id\", \"conversation_id\"], name: \"index_applied_slas_on_account_sla_policy_conversation\", unique: true\n    t.index [\"account_id\"], name: \"index_applied_slas_on_account_id\"\n    t.index [\"conversation_id\"], name: \"index_applied_slas_on_conversation_id\"\n    t.index [\"sla_policy_id\"], name: \"index_applied_slas_on_sla_policy_id\"\n  end\n\n  create_table \"article_embeddings\", force: :cascade do |t|\n    t.bigint \"article_id\", null: false\n    t.text \"term\", null: false\n    t.vector \"embedding\", limit: 1536\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.index [\"embedding\"], name: \"index_article_embeddings_on_embedding\", using: :ivfflat\n  end\n\n  create_table \"articles\", force: :cascade do |t|\n    t.integer \"account_id\", null: false\n    t.integer \"portal_id\", null: false\n    t.integer \"category_id\"\n    t.integer \"folder_id\"\n    t.string \"title\"\n    t.text \"description\"\n    t.text \"content\"\n    t.integer \"status\"\n    t.integer \"views\"\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.bigint \"author_id\"\n    t.bigint \"associated_article_id\"\n    t.jsonb \"meta\", default: {}\n    t.string \"slug\", null: false\n    t.integer \"position\"\n    t.string \"locale\", default: \"en\", null: false\n    t.index [\"account_id\"], name: \"index_articles_on_account_id\"\n    t.index [\"associated_article_id\"], name: \"index_articles_on_associated_article_id\"\n    t.index [\"author_id\"], name: \"index_articles_on_author_id\"\n    t.index [\"portal_id\"], name: \"index_articles_on_portal_id\"\n    t.index [\"slug\"], name: \"index_articles_on_slug\", unique: true\n    t.index [\"status\"], name: \"index_articles_on_status\"\n    t.index [\"views\"], name: \"index_articles_on_views\"\n  end\n\n  create_table \"attachments\", id: :serial, force: :cascade do |t|\n    t.integer \"file_type\", default: 0\n    t.string \"external_url\"\n    t.float \"coordinates_lat\", default: 0.0\n    t.float \"coordinates_long\", default: 0.0\n    t.integer \"message_id\", null: false\n    t.integer \"account_id\", null: false\n    t.datetime \"created_at\", precision: nil, null: false\n    t.datetime \"updated_at\", precision: nil, null: false\n    t.string \"fallback_title\"\n    t.string \"extension\"\n    t.jsonb \"meta\", default: {}\n    t.index [\"account_id\"], name: \"index_attachments_on_account_id\"\n    t.index [\"message_id\"], name: \"index_attachments_on_message_id\"\n  end\n\n  create_table \"audits\", force: :cascade do |t|\n    t.bigint \"auditable_id\"\n    t.string \"auditable_type\"\n    t.bigint \"associated_id\"\n    t.string \"associated_type\"\n    t.bigint \"user_id\"\n    t.string \"user_type\"\n    t.string \"username\"\n    t.string \"action\"\n    t.jsonb \"audited_changes\"\n    t.integer \"version\", default: 0\n    t.string \"comment\"\n    t.string \"remote_address\"\n    t.string \"request_uuid\"\n    t.datetime \"created_at\", precision: nil\n    t.index [\"associated_type\", \"associated_id\"], name: \"associated_index\"\n    t.index [\"auditable_type\", \"auditable_id\", \"version\"], name: \"auditable_index\"\n    t.index [\"created_at\"], name: \"index_audits_on_created_at\"\n    t.index [\"request_uuid\"], name: \"index_audits_on_request_uuid\"\n    t.index [\"user_id\", \"user_type\"], name: \"user_index\"\n  end\n\n  create_table \"automation_rules\", force: :cascade do |t|\n    t.bigint \"account_id\", null: false\n    t.string \"name\", null: false\n    t.text \"description\"\n    t.string \"event_name\", null: false\n    t.jsonb \"conditions\", default: \"{}\", null: false\n    t.jsonb \"actions\", default: \"{}\", null: false\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.boolean \"active\", default: true, null: false\n    t.index [\"account_id\"], name: \"index_automation_rules_on_account_id\"\n  end\n\n  create_table \"campaigns\", force: :cascade do |t|\n    t.integer \"display_id\", null: false\n    t.string \"title\", null: false\n    t.text \"description\"\n    t.text \"message\", null: false\n    t.integer \"sender_id\"\n    t.boolean \"enabled\", default: true\n    t.bigint \"account_id\", null: false\n    t.bigint \"inbox_id\", null: false\n    t.jsonb \"trigger_rules\", default: {}\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.integer \"campaign_type\", default: 0, null: false\n    t.integer \"campaign_status\", default: 0, null: false\n    t.jsonb \"audience\", default: []\n    t.datetime \"scheduled_at\", precision: nil\n    t.boolean \"trigger_only_during_business_hours\", default: false\n    t.index [\"account_id\"], name: \"index_campaigns_on_account_id\"\n    t.index [\"campaign_status\"], name: \"index_campaigns_on_campaign_status\"\n    t.index [\"campaign_type\"], name: \"index_campaigns_on_campaign_type\"\n    t.index [\"inbox_id\"], name: \"index_campaigns_on_inbox_id\"\n    t.index [\"scheduled_at\"], name: \"index_campaigns_on_scheduled_at\"\n  end\n\n  create_table \"canned_responses\", id: :serial, force: :cascade do |t|\n    t.integer \"account_id\", null: false\n    t.string \"short_code\"\n    t.text \"content\"\n    t.datetime \"created_at\", precision: nil, null: false\n    t.datetime \"updated_at\", precision: nil, null: false\n  end\n\n  create_table \"captain_assistant_responses\", force: :cascade do |t|\n    t.string \"question\", null: false\n    t.text \"answer\", null: false\n    t.vector \"embedding\", limit: 1536\n    t.bigint \"assistant_id\", null: false\n    t.bigint \"documentable_id\"\n    t.bigint \"account_id\", null: false\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.integer \"status\", default: 1, null: false\n    t.string \"documentable_type\"\n    t.index [\"account_id\"], name: \"index_captain_assistant_responses_on_account_id\"\n    t.index [\"assistant_id\"], name: \"index_captain_assistant_responses_on_assistant_id\"\n    t.index [\"documentable_id\", \"documentable_type\"], name: \"idx_cap_asst_resp_on_documentable\"\n    t.index [\"embedding\"], name: \"vector_idx_knowledge_entries_embedding\", using: :ivfflat\n    t.index [\"status\"], name: \"index_captain_assistant_responses_on_status\"\n  end\n\n  create_table \"captain_assistants\", force: :cascade do |t|\n    t.string \"name\", null: false\n    t.bigint \"account_id\", null: false\n    t.string \"description\"\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.jsonb \"config\", default: {}, null: false\n    t.index [\"account_id\"], name: \"index_captain_assistants_on_account_id\"\n  end\n\n  create_table \"captain_documents\", force: :cascade do |t|\n    t.string \"name\"\n    t.string \"external_link\", null: false\n    t.text \"content\"\n    t.bigint \"assistant_id\", null: false\n    t.bigint \"account_id\", null: false\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.integer \"status\", default: 0, null: false\n    t.index [\"account_id\"], name: \"index_captain_documents_on_account_id\"\n    t.index [\"assistant_id\", \"external_link\"], name: \"index_captain_documents_on_assistant_id_and_external_link\", unique: true\n    t.index [\"assistant_id\"], name: \"index_captain_documents_on_assistant_id\"\n    t.index [\"status\"], name: \"index_captain_documents_on_status\"\n  end\n\n  create_table \"captain_inboxes\", force: :cascade do |t|\n    t.bigint \"captain_assistant_id\", null: false\n    t.bigint \"inbox_id\", null: false\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.index [\"captain_assistant_id\", \"inbox_id\"], name: \"index_captain_inboxes_on_captain_assistant_id_and_inbox_id\", unique: true\n    t.index [\"captain_assistant_id\"], name: \"index_captain_inboxes_on_captain_assistant_id\"\n    t.index [\"inbox_id\"], name: \"index_captain_inboxes_on_inbox_id\"\n  end\n\n  create_table \"categories\", force: :cascade do |t|\n    t.integer \"account_id\", null: false\n    t.integer \"portal_id\", null: false\n    t.string \"name\"\n    t.text \"description\"\n    t.integer \"position\"\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.string \"locale\", default: \"en\"\n    t.string \"slug\", null: false\n    t.bigint \"parent_category_id\"\n    t.bigint \"associated_category_id\"\n    t.string \"icon\", default: \"\"\n    t.index [\"associated_category_id\"], name: \"index_categories_on_associated_category_id\"\n    t.index [\"locale\", \"account_id\"], name: \"index_categories_on_locale_and_account_id\"\n    t.index [\"locale\"], name: \"index_categories_on_locale\"\n    t.index [\"parent_category_id\"], name: \"index_categories_on_parent_category_id\"\n    t.index [\"slug\", \"locale\", \"portal_id\"], name: \"index_categories_on_slug_and_locale_and_portal_id\", unique: true\n  end\n\n  create_table \"channel_api\", force: :cascade do |t|\n    t.integer \"account_id\", null: false\n    t.string \"webhook_url\"\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.string \"identifier\"\n    t.string \"hmac_token\"\n    t.boolean \"hmac_mandatory\", default: false\n    t.jsonb \"additional_attributes\", default: {}\n    t.index [\"hmac_token\"], name: \"index_channel_api_on_hmac_token\", unique: true\n    t.index [\"identifier\"], name: \"index_channel_api_on_identifier\", unique: true\n  end\n\n  create_table \"channel_email\", force: :cascade do |t|\n    t.integer \"account_id\", null: false\n    t.string \"email\", null: false\n    t.string \"forward_to_email\", null: false\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.boolean \"imap_enabled\", default: false\n    t.string \"imap_address\", default: \"\"\n    t.integer \"imap_port\", default: 0\n    t.string \"imap_login\", default: \"\"\n    t.string \"imap_password\", default: \"\"\n    t.boolean \"imap_enable_ssl\", default: true\n    t.boolean \"smtp_enabled\", default: false\n    t.string \"smtp_address\", default: \"\"\n    t.integer \"smtp_port\", default: 0\n    t.string \"smtp_login\", default: \"\"\n    t.string \"smtp_password\", default: \"\"\n    t.string \"smtp_domain\", default: \"\"\n    t.boolean \"smtp_enable_starttls_auto\", default: true\n    t.string \"smtp_authentication\", default: \"login\"\n    t.string \"smtp_openssl_verify_mode\", default: \"none\"\n    t.boolean \"smtp_enable_ssl_tls\", default: false\n    t.jsonb \"provider_config\", default: {}\n    t.string \"provider\"\n    t.index [\"email\"], name: \"index_channel_email_on_email\", unique: true\n    t.index [\"forward_to_email\"], name: \"index_channel_email_on_forward_to_email\", unique: true\n  end\n\n  create_table \"channel_facebook_pages\", id: :serial, force: :cascade do |t|\n    t.string \"page_id\", null: false\n    t.string \"user_access_token\", null: false\n    t.string \"page_access_token\", null: false\n    t.integer \"account_id\", null: false\n    t.datetime \"created_at\", precision: nil, null: false\n    t.datetime \"updated_at\", precision: nil, null: false\n    t.string \"instagram_id\"\n    t.index [\"page_id\", \"account_id\"], name: \"index_channel_facebook_pages_on_page_id_and_account_id\", unique: true\n    t.index [\"page_id\"], name: \"index_channel_facebook_pages_on_page_id\"\n  end\n\n  create_table \"channel_instagram\", force: :cascade do |t|\n    t.string \"access_token\", null: false\n    t.datetime \"expires_at\", null: false\n    t.integer \"account_id\", null: false\n    t.string \"instagram_id\", null: false\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.index [\"instagram_id\"], name: \"index_channel_instagram_on_instagram_id\", unique: true\n  end\n\n  create_table \"channel_line\", force: :cascade do |t|\n    t.integer \"account_id\", null: false\n    t.string \"line_channel_id\", null: false\n    t.string \"line_channel_secret\", null: false\n    t.string \"line_channel_token\", null: false\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.index [\"line_channel_id\"], name: \"index_channel_line_on_line_channel_id\", unique: true\n  end\n\n  create_table \"channel_sms\", force: :cascade do |t|\n    t.integer \"account_id\", null: false\n    t.string \"phone_number\", null: false\n    t.string \"provider\", default: \"default\"\n    t.jsonb \"provider_config\", default: {}\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.index [\"phone_number\"], name: \"index_channel_sms_on_phone_number\", unique: true\n  end\n\n  create_table \"channel_telegram\", force: :cascade do |t|\n    t.string \"bot_name\"\n    t.integer \"account_id\", null: false\n    t.string \"bot_token\", null: false\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.index [\"bot_token\"], name: \"index_channel_telegram_on_bot_token\", unique: true\n  end\n\n  create_table \"channel_twilio_sms\", force: :cascade do |t|\n    t.string \"phone_number\"\n    t.string \"auth_token\", null: false\n    t.string \"account_sid\", null: false\n    t.integer \"account_id\", null: false\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.integer \"medium\", default: 0\n    t.string \"messaging_service_sid\"\n    t.string \"api_key_sid\"\n    t.index [\"account_sid\", \"phone_number\"], name: \"index_channel_twilio_sms_on_account_sid_and_phone_number\", unique: true\n    t.index [\"messaging_service_sid\"], name: \"index_channel_twilio_sms_on_messaging_service_sid\", unique: true\n    t.index [\"phone_number\"], name: \"index_channel_twilio_sms_on_phone_number\", unique: true\n  end\n\n  create_table \"channel_twitter_profiles\", force: :cascade do |t|\n    t.string \"profile_id\", null: false\n    t.string \"twitter_access_token\", null: false\n    t.string \"twitter_access_token_secret\", null: false\n    t.integer \"account_id\", null: false\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.boolean \"tweets_enabled\", default: true\n    t.index [\"account_id\", \"profile_id\"], name: \"index_channel_twitter_profiles_on_account_id_and_profile_id\", unique: true\n  end\n\n  create_table \"channel_web_widgets\", id: :serial, force: :cascade do |t|\n    t.string \"website_url\"\n    t.integer \"account_id\"\n    t.datetime \"created_at\", precision: nil, null: false\n    t.datetime \"updated_at\", precision: nil, null: false\n    t.string \"website_token\"\n    t.string \"widget_color\", default: \"#1f93ff\"\n    t.string \"welcome_title\"\n    t.string \"welcome_tagline\"\n    t.integer \"feature_flags\", default: 7, null: false\n    t.integer \"reply_time\", default: 0\n    t.string \"hmac_token\"\n    t.boolean \"pre_chat_form_enabled\", default: false\n    t.jsonb \"pre_chat_form_options\", default: {}\n    t.boolean \"hmac_mandatory\", default: false\n    t.boolean \"continuity_via_email\", default: true, null: false\n    t.index [\"hmac_token\"], name: \"index_channel_web_widgets_on_hmac_token\", unique: true\n    t.index [\"website_token\"], name: \"index_channel_web_widgets_on_website_token\", unique: true\n  end\n\n  create_table \"channel_whatsapp\", force: :cascade do |t|\n    t.integer \"account_id\", null: false\n    t.string \"phone_number\", null: false\n    t.string \"provider\", default: \"default\"\n    t.jsonb \"provider_config\", default: {}\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.jsonb \"message_templates\", default: {}\n    t.datetime \"message_templates_last_updated\", precision: nil\n    t.index [\"phone_number\"], name: \"index_channel_whatsapp_on_phone_number\", unique: true\n  end\n\n  create_table \"contact_inboxes\", force: :cascade do |t|\n    t.bigint \"contact_id\"\n    t.bigint \"inbox_id\"\n    t.string \"source_id\", null: false\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.boolean \"hmac_verified\", default: false\n    t.string \"pubsub_token\"\n    t.index [\"contact_id\"], name: \"index_contact_inboxes_on_contact_id\"\n    t.index [\"inbox_id\", \"source_id\"], name: \"index_contact_inboxes_on_inbox_id_and_source_id\", unique: true\n    t.index [\"inbox_id\"], name: \"index_contact_inboxes_on_inbox_id\"\n    t.index [\"pubsub_token\"], name: \"index_contact_inboxes_on_pubsub_token\", unique: true\n    t.index [\"source_id\"], name: \"index_contact_inboxes_on_source_id\"\n  end\n\n  create_table \"contacts\", id: :serial, force: :cascade do |t|\n    t.string \"name\", default: \"\"\n    t.string \"email\"\n    t.string \"phone_number\"\n    t.integer \"account_id\", null: false\n    t.datetime \"created_at\", precision: nil, null: false\n    t.datetime \"updated_at\", precision: nil, null: false\n    t.jsonb \"additional_attributes\", default: {}\n    t.string \"identifier\"\n    t.jsonb \"custom_attributes\", default: {}\n    t.datetime \"last_activity_at\", precision: nil\n    t.integer \"contact_type\", default: 0\n    t.string \"middle_name\", default: \"\"\n    t.string \"last_name\", default: \"\"\n    t.string \"location\", default: \"\"\n    t.string \"country_code\", default: \"\"\n    t.boolean \"blocked\", default: false, null: false\n    t.index \"lower((email)::text), account_id\", name: \"index_contacts_on_lower_email_account_id\"\n    t.index [\"account_id\", \"email\", \"phone_number\", \"identifier\"], name: \"index_contacts_on_nonempty_fields\", where: \"(((email)::text <> ''::text) OR ((phone_number)::text <> ''::text) OR ((identifier)::text <> ''::text))\"\n    t.index [\"account_id\", \"last_activity_at\"], name: \"index_contacts_on_account_id_and_last_activity_at\", order: { last_activity_at: \"DESC NULLS LAST\" }\n    t.index [\"account_id\"], name: \"index_contacts_on_account_id\"\n    t.index [\"account_id\"], name: \"index_resolved_contact_account_id\", where: \"(((email)::text <> ''::text) OR ((phone_number)::text <> ''::text) OR ((identifier)::text <> ''::text))\"\n    t.index [\"blocked\"], name: \"index_contacts_on_blocked\"\n    t.index [\"email\", \"account_id\"], name: \"uniq_email_per_account_contact\", unique: true\n    t.index [\"identifier\", \"account_id\"], name: \"uniq_identifier_per_account_contact\", unique: true\n    t.index [\"name\", \"email\", \"phone_number\", \"identifier\"], name: \"index_contacts_on_name_email_phone_number_identifier\", opclass: :gin_trgm_ops, using: :gin\n    t.index [\"phone_number\", \"account_id\"], name: \"index_contacts_on_phone_number_and_account_id\"\n  end\n\n  create_table \"conversation_participants\", force: :cascade do |t|\n    t.bigint \"account_id\", null: false\n    t.bigint \"user_id\", null: false\n    t.bigint \"conversation_id\", null: false\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.index [\"account_id\"], name: \"index_conversation_participants_on_account_id\"\n    t.index [\"conversation_id\"], name: \"index_conversation_participants_on_conversation_id\"\n    t.index [\"user_id\", \"conversation_id\"], name: \"index_conversation_participants_on_user_id_and_conversation_id\", unique: true\n    t.index [\"user_id\"], name: \"index_conversation_participants_on_user_id\"\n  end\n\n  create_table \"conversations\", id: :serial, force: :cascade do |t|\n    t.integer \"account_id\", null: false\n    t.integer \"inbox_id\", null: false\n    t.integer \"status\", default: 0, null: false\n    t.integer \"assignee_id\"\n    t.datetime \"created_at\", precision: nil, null: false\n    t.datetime \"updated_at\", precision: nil, null: false\n    t.bigint \"contact_id\"\n    t.integer \"display_id\", null: false\n    t.datetime \"contact_last_seen_at\", precision: nil\n    t.datetime \"agent_last_seen_at\", precision: nil\n    t.jsonb \"additional_attributes\", default: {}\n    t.bigint \"contact_inbox_id\"\n    t.uuid \"uuid\", default: -> { \"gen_random_uuid()\" }, null: false\n    t.string \"identifier\"\n    t.datetime \"last_activity_at\", precision: nil, default: -> { \"CURRENT_TIMESTAMP\" }, null: false\n    t.bigint \"team_id\"\n    t.bigint \"campaign_id\"\n    t.datetime \"snoozed_until\", precision: nil\n    t.jsonb \"custom_attributes\", default: {}\n    t.datetime \"assignee_last_seen_at\", precision: nil\n    t.datetime \"first_reply_created_at\", precision: nil\n    t.integer \"priority\"\n    t.bigint \"sla_policy_id\"\n    t.datetime \"waiting_since\"\n    t.text \"cached_label_list\"\n    t.index [\"account_id\", \"display_id\"], name: \"index_conversations_on_account_id_and_display_id\", unique: true\n    t.index [\"account_id\", \"id\"], name: \"index_conversations_on_id_and_account_id\"\n    t.index [\"account_id\", \"inbox_id\", \"status\", \"assignee_id\"], name: \"conv_acid_inbid_stat_asgnid_idx\"\n    t.index [\"account_id\"], name: \"index_conversations_on_account_id\"\n    t.index [\"assignee_id\", \"account_id\"], name: \"index_conversations_on_assignee_id_and_account_id\"\n    t.index [\"campaign_id\"], name: \"index_conversations_on_campaign_id\"\n    t.index [\"contact_id\"], name: \"index_conversations_on_contact_id\"\n    t.index [\"contact_inbox_id\"], name: \"index_conversations_on_contact_inbox_id\"\n    t.index [\"first_reply_created_at\"], name: \"index_conversations_on_first_reply_created_at\"\n    t.index [\"inbox_id\"], name: \"index_conversations_on_inbox_id\"\n    t.index [\"priority\"], name: \"index_conversations_on_priority\"\n    t.index [\"status\", \"account_id\"], name: \"index_conversations_on_status_and_account_id\"\n    t.index [\"status\", \"priority\"], name: \"index_conversations_on_status_and_priority\"\n    t.index [\"team_id\"], name: \"index_conversations_on_team_id\"\n    t.index [\"uuid\"], name: \"index_conversations_on_uuid\", unique: true\n    t.index [\"waiting_since\"], name: \"index_conversations_on_waiting_since\"\n  end\n\n  create_table \"copilot_messages\", force: :cascade do |t|\n    t.bigint \"copilot_thread_id\", null: false\n    t.bigint \"account_id\", null: false\n    t.jsonb \"message\", default: {}, null: false\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.integer \"message_type\", default: 0\n    t.index [\"account_id\"], name: \"index_copilot_messages_on_account_id\"\n    t.index [\"copilot_thread_id\"], name: \"index_copilot_messages_on_copilot_thread_id\"\n  end\n\n  create_table \"copilot_threads\", force: :cascade do |t|\n    t.string \"title\", null: false\n    t.bigint \"user_id\", null: false\n    t.bigint \"account_id\", null: false\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.integer \"assistant_id\"\n    t.index [\"account_id\"], name: \"index_copilot_threads_on_account_id\"\n    t.index [\"assistant_id\"], name: \"index_copilot_threads_on_assistant_id\"\n    t.index [\"user_id\"], name: \"index_copilot_threads_on_user_id\"\n  end\n\n  create_table \"csat_survey_responses\", force: :cascade do |t|\n    t.bigint \"account_id\", null: false\n    t.bigint \"conversation_id\", null: false\n    t.bigint \"message_id\", null: false\n    t.integer \"rating\", null: false\n    t.text \"feedback_message\"\n    t.bigint \"contact_id\", null: false\n    t.bigint \"assigned_agent_id\"\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.index [\"account_id\"], name: \"index_csat_survey_responses_on_account_id\"\n    t.index [\"assigned_agent_id\"], name: \"index_csat_survey_responses_on_assigned_agent_id\"\n    t.index [\"contact_id\"], name: \"index_csat_survey_responses_on_contact_id\"\n    t.index [\"conversation_id\"], name: \"index_csat_survey_responses_on_conversation_id\"\n    t.index [\"message_id\"], name: \"index_csat_survey_responses_on_message_id\", unique: true\n  end\n\n  create_table \"custom_attribute_definitions\", force: :cascade do |t|\n    t.string \"attribute_display_name\"\n    t.string \"attribute_key\"\n    t.integer \"attribute_display_type\", default: 0\n    t.integer \"default_value\"\n    t.integer \"attribute_model\", default: 0\n    t.bigint \"account_id\"\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.text \"attribute_description\"\n    t.jsonb \"attribute_values\", default: []\n    t.string \"regex_pattern\"\n    t.string \"regex_cue\"\n    t.index [\"account_id\"], name: \"index_custom_attribute_definitions_on_account_id\"\n    t.index [\"attribute_key\", \"attribute_model\", \"account_id\"], name: \"attribute_key_model_index\", unique: true\n  end\n\n  create_table \"custom_filters\", force: :cascade do |t|\n    t.string \"name\", null: false\n    t.integer \"filter_type\", default: 0, null: false\n    t.jsonb \"query\", default: \"{}\", null: false\n    t.bigint \"account_id\", null: false\n    t.bigint \"user_id\", null: false\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.index [\"account_id\"], name: \"index_custom_filters_on_account_id\"\n    t.index [\"user_id\"], name: \"index_custom_filters_on_user_id\"\n  end\n\n  create_table \"custom_roles\", force: :cascade do |t|\n    t.string \"name\"\n    t.string \"description\"\n    t.bigint \"account_id\", null: false\n    t.text \"permissions\", default: [], array: true\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.index [\"account_id\"], name: \"index_custom_roles_on_account_id\"\n  end\n\n  create_table \"dashboard_apps\", force: :cascade do |t|\n    t.string \"title\", null: false\n    t.jsonb \"content\", default: []\n    t.bigint \"account_id\", null: false\n    t.bigint \"user_id\"\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.index [\"account_id\"], name: \"index_dashboard_apps_on_account_id\"\n    t.index [\"user_id\"], name: \"index_dashboard_apps_on_user_id\"\n  end\n\n  create_table \"data_imports\", force: :cascade do |t|\n    t.bigint \"account_id\", null: false\n    t.string \"data_type\", null: false\n    t.integer \"status\", default: 0, null: false\n    t.text \"processing_errors\"\n    t.integer \"total_records\"\n    t.integer \"processed_records\"\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.index [\"account_id\"], name: \"index_data_imports_on_account_id\"\n  end\n\n  create_table \"email_templates\", force: :cascade do |t|\n    t.string \"name\", null: false\n    t.text \"body\", null: false\n    t.integer \"account_id\"\n    t.integer \"template_type\", default: 1\n    t.integer \"locale\", default: 0, null: false\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.index [\"name\", \"account_id\"], name: \"index_email_templates_on_name_and_account_id\", unique: true\n  end\n\n  create_table \"folders\", force: :cascade do |t|\n    t.integer \"account_id\", null: false\n    t.integer \"category_id\", null: false\n    t.string \"name\"\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n  end\n\n  create_table \"inbox_members\", id: :serial, force: :cascade do |t|\n    t.integer \"user_id\", null: false\n    t.integer \"inbox_id\", null: false\n    t.datetime \"created_at\", precision: nil, null: false\n    t.datetime \"updated_at\", precision: nil, null: false\n    t.index [\"inbox_id\", \"user_id\"], name: \"index_inbox_members_on_inbox_id_and_user_id\", unique: true\n    t.index [\"inbox_id\"], name: \"index_inbox_members_on_inbox_id\"\n  end\n\n  create_table \"inboxes\", id: :serial, force: :cascade do |t|\n    t.integer \"channel_id\", null: false\n    t.integer \"account_id\", null: false\n    t.string \"name\", null: false\n    t.datetime \"created_at\", precision: nil, null: false\n    t.datetime \"updated_at\", precision: nil, null: false\n    t.string \"channel_type\"\n    t.boolean \"enable_auto_assignment\", default: true\n    t.boolean \"greeting_enabled\", default: false\n    t.string \"greeting_message\"\n    t.string \"email_address\"\n    t.boolean \"working_hours_enabled\", default: false\n    t.string \"out_of_office_message\"\n    t.string \"timezone\", default: \"UTC\"\n    t.boolean \"enable_email_collect\", default: true\n    t.boolean \"csat_survey_enabled\", default: false\n    t.boolean \"allow_messages_after_resolved\", default: true\n    t.jsonb \"auto_assignment_config\", default: {}\n    t.boolean \"lock_to_single_conversation\", default: false, null: false\n    t.bigint \"portal_id\"\n    t.integer \"sender_name_type\", default: 0, null: false\n    t.string \"business_name\"\n    t.jsonb \"csat_config\", default: {}, null: false\n    t.index [\"account_id\"], name: \"index_inboxes_on_account_id\"\n    t.index [\"channel_id\", \"channel_type\"], name: \"index_inboxes_on_channel_id_and_channel_type\"\n    t.index [\"portal_id\"], name: \"index_inboxes_on_portal_id\"\n  end\n\n  create_table \"installation_configs\", force: :cascade do |t|\n    t.string \"name\", null: false\n    t.jsonb \"serialized_value\", default: {}, null: false\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.boolean \"locked\", default: true, null: false\n    t.index [\"name\", \"created_at\"], name: \"index_installation_configs_on_name_and_created_at\", unique: true\n    t.index [\"name\"], name: \"index_installation_configs_on_name\", unique: true\n  end\n\n  create_table \"integrations_hooks\", force: :cascade do |t|\n    t.integer \"status\", default: 1\n    t.integer \"inbox_id\"\n    t.integer \"account_id\"\n    t.string \"app_id\"\n    t.integer \"hook_type\", default: 0\n    t.string \"reference_id\"\n    t.string \"access_token\"\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.jsonb \"settings\", default: {}\n  end\n\n  create_table \"labels\", force: :cascade do |t|\n    t.string \"title\"\n    t.text \"description\"\n    t.string \"color\", default: \"#1f93ff\", null: false\n    t.boolean \"show_on_sidebar\"\n    t.bigint \"account_id\"\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.index [\"account_id\"], name: \"index_labels_on_account_id\"\n    t.index [\"title\", \"account_id\"], name: \"index_labels_on_title_and_account_id\", unique: true\n  end\n\n  create_table \"macros\", force: :cascade do |t|\n    t.bigint \"account_id\", null: false\n    t.string \"name\", null: false\n    t.integer \"visibility\", default: 0\n    t.bigint \"created_by_id\"\n    t.bigint \"updated_by_id\"\n    t.jsonb \"actions\", default: {}, null: false\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.index [\"account_id\"], name: \"index_macros_on_account_id\"\n  end\n\n  create_table \"mentions\", force: :cascade do |t|\n    t.bigint \"user_id\", null: false\n    t.bigint \"conversation_id\", null: false\n    t.bigint \"account_id\", null: false\n    t.datetime \"mentioned_at\", precision: nil, null: false\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.index [\"account_id\"], name: \"index_mentions_on_account_id\"\n    t.index [\"conversation_id\"], name: \"index_mentions_on_conversation_id\"\n    t.index [\"user_id\", \"conversation_id\"], name: \"index_mentions_on_user_id_and_conversation_id\", unique: true\n    t.index [\"user_id\"], name: \"index_mentions_on_user_id\"\n  end\n\n  create_table \"messages\", id: :serial, force: :cascade do |t|\n    t.text \"content\"\n    t.integer \"account_id\", null: false\n    t.integer \"inbox_id\", null: false\n    t.integer \"conversation_id\", null: false\n    t.integer \"message_type\", null: false\n    t.datetime \"created_at\", precision: nil, null: false\n    t.datetime \"updated_at\", precision: nil, null: false\n    t.boolean \"private\", default: false, null: false\n    t.integer \"status\", default: 0\n    t.string \"source_id\"\n    t.integer \"content_type\", default: 0, null: false\n    t.json \"content_attributes\", default: {}\n    t.string \"sender_type\"\n    t.bigint \"sender_id\"\n    t.jsonb \"external_source_ids\", default: {}\n    t.jsonb \"additional_attributes\", default: {}\n    t.text \"processed_message_content\"\n    t.jsonb \"sentiment\", default: {}\n    t.index \"((additional_attributes -> 'campaign_id'::text))\", name: \"index_messages_on_additional_attributes_campaign_id\", using: :gin\n    t.index [\"account_id\", \"created_at\", \"message_type\"], name: \"index_messages_on_account_created_type\"\n    t.index [\"account_id\", \"inbox_id\"], name: \"index_messages_on_account_id_and_inbox_id\"\n    t.index [\"account_id\"], name: \"index_messages_on_account_id\"\n    t.index [\"content\"], name: \"index_messages_on_content\", opclass: :gin_trgm_ops, using: :gin\n    t.index [\"conversation_id\", \"account_id\", \"message_type\", \"created_at\"], name: \"index_messages_on_conversation_account_type_created\"\n    t.index [\"conversation_id\"], name: \"index_messages_on_conversation_id\"\n    t.index [\"created_at\"], name: \"index_messages_on_created_at\"\n    t.index [\"inbox_id\"], name: \"index_messages_on_inbox_id\"\n    t.index [\"sender_type\", \"sender_id\"], name: \"index_messages_on_sender_type_and_sender_id\"\n    t.index [\"source_id\"], name: \"index_messages_on_source_id\"\n  end\n\n  create_table \"notes\", force: :cascade do |t|\n    t.text \"content\", null: false\n    t.bigint \"account_id\", null: false\n    t.bigint \"contact_id\", null: false\n    t.bigint \"user_id\"\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.index [\"account_id\"], name: \"index_notes_on_account_id\"\n    t.index [\"contact_id\"], name: \"index_notes_on_contact_id\"\n    t.index [\"user_id\"], name: \"index_notes_on_user_id\"\n  end\n\n  create_table \"notification_settings\", force: :cascade do |t|\n    t.integer \"account_id\"\n    t.integer \"user_id\"\n    t.integer \"email_flags\", default: 0, null: false\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.integer \"push_flags\", default: 0, null: false\n    t.index [\"account_id\", \"user_id\"], name: \"by_account_user\", unique: true\n  end\n\n  create_table \"notification_subscriptions\", force: :cascade do |t|\n    t.bigint \"user_id\", null: false\n    t.integer \"subscription_type\", null: false\n    t.jsonb \"subscription_attributes\", default: {}, null: false\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.text \"identifier\"\n    t.index [\"identifier\"], name: \"index_notification_subscriptions_on_identifier\", unique: true\n    t.index [\"user_id\"], name: \"index_notification_subscriptions_on_user_id\"\n  end\n\n  create_table \"notifications\", force: :cascade do |t|\n    t.bigint \"account_id\", null: false\n    t.bigint \"user_id\", null: false\n    t.integer \"notification_type\", null: false\n    t.string \"primary_actor_type\", null: false\n    t.bigint \"primary_actor_id\", null: false\n    t.string \"secondary_actor_type\"\n    t.bigint \"secondary_actor_id\"\n    t.datetime \"read_at\", precision: nil\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.datetime \"snoozed_until\"\n    t.datetime \"last_activity_at\", default: -> { \"CURRENT_TIMESTAMP\" }\n    t.jsonb \"meta\", default: {}\n    t.index [\"account_id\"], name: \"index_notifications_on_account_id\"\n    t.index [\"last_activity_at\"], name: \"index_notifications_on_last_activity_at\"\n    t.index [\"primary_actor_type\", \"primary_actor_id\"], name: \"uniq_primary_actor_per_account_notifications\"\n    t.index [\"secondary_actor_type\", \"secondary_actor_id\"], name: \"uniq_secondary_actor_per_account_notifications\"\n    t.index [\"user_id\"], name: \"index_notifications_on_user_id\"\n  end\n\n  create_table \"platform_app_permissibles\", force: :cascade do |t|\n    t.bigint \"platform_app_id\", null: false\n    t.string \"permissible_type\", null: false\n    t.bigint \"permissible_id\", null: false\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.index [\"permissible_type\", \"permissible_id\"], name: \"index_platform_app_permissibles_on_permissibles\"\n    t.index [\"platform_app_id\", \"permissible_id\", \"permissible_type\"], name: \"unique_permissibles_index\", unique: true\n    t.index [\"platform_app_id\"], name: \"index_platform_app_permissibles_on_platform_app_id\"\n  end\n\n  create_table \"platform_apps\", force: :cascade do |t|\n    t.string \"name\", null: false\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n  end\n\n  create_table \"portals\", force: :cascade do |t|\n    t.integer \"account_id\", null: false\n    t.string \"name\", null: false\n    t.string \"slug\", null: false\n    t.string \"custom_domain\"\n    t.string \"color\"\n    t.string \"homepage_link\"\n    t.string \"page_title\"\n    t.text \"header_text\"\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.jsonb \"config\", default: {\"allowed_locales\"=>[\"en\"]}\n    t.boolean \"archived\", default: false\n    t.bigint \"channel_web_widget_id\"\n    t.index [\"channel_web_widget_id\"], name: \"index_portals_on_channel_web_widget_id\"\n    t.index [\"custom_domain\"], name: \"index_portals_on_custom_domain\", unique: true\n    t.index [\"slug\"], name: \"index_portals_on_slug\", unique: true\n  end\n\n  create_table \"portals_members\", id: false, force: :cascade do |t|\n    t.bigint \"portal_id\", null: false\n    t.bigint \"user_id\", null: false\n    t.index [\"portal_id\", \"user_id\"], name: \"index_portals_members_on_portal_id_and_user_id\", unique: true\n    t.index [\"portal_id\"], name: \"index_portals_members_on_portal_id\"\n    t.index [\"user_id\"], name: \"index_portals_members_on_user_id\"\n  end\n\n  create_table \"related_categories\", force: :cascade do |t|\n    t.bigint \"category_id\"\n    t.bigint \"related_category_id\"\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.index [\"category_id\", \"related_category_id\"], name: \"index_related_categories_on_category_id_and_related_category_id\", unique: true\n    t.index [\"related_category_id\", \"category_id\"], name: \"index_related_categories_on_related_category_id_and_category_id\", unique: true\n  end\n\n  create_table \"reporting_events\", force: :cascade do |t|\n    t.string \"name\"\n    t.float \"value\"\n    t.integer \"account_id\"\n    t.integer \"inbox_id\"\n    t.integer \"user_id\"\n    t.integer \"conversation_id\"\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.float \"value_in_business_hours\"\n    t.datetime \"event_start_time\", precision: nil\n    t.datetime \"event_end_time\", precision: nil\n    t.index [\"account_id\", \"name\", \"created_at\"], name: \"reporting_events__account_id__name__created_at\"\n    t.index [\"account_id\"], name: \"index_reporting_events_on_account_id\"\n    t.index [\"conversation_id\"], name: \"index_reporting_events_on_conversation_id\"\n    t.index [\"created_at\"], name: \"index_reporting_events_on_created_at\"\n    t.index [\"inbox_id\"], name: \"index_reporting_events_on_inbox_id\"\n    t.index [\"name\"], name: \"index_reporting_events_on_name\"\n    t.index [\"user_id\"], name: \"index_reporting_events_on_user_id\"\n  end\n\n  create_table \"sla_events\", force: :cascade do |t|\n    t.bigint \"applied_sla_id\", null: false\n    t.bigint \"conversation_id\", null: false\n    t.bigint \"account_id\", null: false\n    t.bigint \"sla_policy_id\", null: false\n    t.bigint \"inbox_id\", null: false\n    t.integer \"event_type\"\n    t.jsonb \"meta\", default: {}\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.index [\"account_id\"], name: \"index_sla_events_on_account_id\"\n    t.index [\"applied_sla_id\"], name: \"index_sla_events_on_applied_sla_id\"\n    t.index [\"conversation_id\"], name: \"index_sla_events_on_conversation_id\"\n    t.index [\"inbox_id\"], name: \"index_sla_events_on_inbox_id\"\n    t.index [\"sla_policy_id\"], name: \"index_sla_events_on_sla_policy_id\"\n  end\n\n  create_table \"sla_policies\", force: :cascade do |t|\n    t.string \"name\", null: false\n    t.float \"first_response_time_threshold\"\n    t.float \"next_response_time_threshold\"\n    t.boolean \"only_during_business_hours\", default: false\n    t.bigint \"account_id\", null: false\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.string \"description\"\n    t.float \"resolution_time_threshold\"\n    t.index [\"account_id\"], name: \"index_sla_policies_on_account_id\"\n  end\n\n  create_table \"taggings\", id: :serial, force: :cascade do |t|\n    t.integer \"tag_id\"\n    t.string \"taggable_type\"\n    t.integer \"taggable_id\"\n    t.string \"tagger_type\"\n    t.integer \"tagger_id\"\n    t.string \"context\", limit: 128\n    t.datetime \"created_at\", precision: nil\n    t.index [\"context\"], name: \"index_taggings_on_context\"\n    t.index [\"tag_id\", \"taggable_id\", \"taggable_type\", \"context\", \"tagger_id\", \"tagger_type\"], name: \"taggings_idx\", unique: true\n    t.index [\"tag_id\"], name: \"index_taggings_on_tag_id\"\n    t.index [\"taggable_id\", \"taggable_type\", \"context\"], name: \"index_taggings_on_taggable_id_and_taggable_type_and_context\"\n    t.index [\"taggable_id\", \"taggable_type\", \"tagger_id\", \"context\"], name: \"taggings_idy\"\n    t.index [\"taggable_id\"], name: \"index_taggings_on_taggable_id\"\n    t.index [\"taggable_type\"], name: \"index_taggings_on_taggable_type\"\n    t.index [\"tagger_id\", \"tagger_type\"], name: \"index_taggings_on_tagger_id_and_tagger_type\"\n    t.index [\"tagger_id\"], name: \"index_taggings_on_tagger_id\"\n  end\n\n  create_table \"tags\", id: :serial, force: :cascade do |t|\n    t.string \"name\"\n    t.integer \"taggings_count\", default: 0\n    t.index \"lower((name)::text) gin_trgm_ops\", name: \"tags_name_trgm_idx\", using: :gin\n    t.index [\"name\"], name: \"index_tags_on_name\", unique: true\n  end\n\n  create_table \"team_members\", force: :cascade do |t|\n    t.bigint \"team_id\", null: false\n    t.bigint \"user_id\", null: false\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.index [\"team_id\", \"user_id\"], name: \"index_team_members_on_team_id_and_user_id\", unique: true\n    t.index [\"team_id\"], name: \"index_team_members_on_team_id\"\n    t.index [\"user_id\"], name: \"index_team_members_on_user_id\"\n  end\n\n  create_table \"teams\", force: :cascade do |t|\n    t.string \"name\", null: false\n    t.text \"description\"\n    t.boolean \"allow_auto_assign\", default: true\n    t.bigint \"account_id\", null: false\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.index [\"account_id\"], name: \"index_teams_on_account_id\"\n    t.index [\"name\", \"account_id\"], name: \"index_teams_on_name_and_account_id\", unique: true\n  end\n\n  create_table \"telegram_bots\", id: :serial, force: :cascade do |t|\n    t.string \"name\"\n    t.string \"auth_key\"\n    t.integer \"account_id\"\n    t.datetime \"created_at\", precision: nil, null: false\n    t.datetime \"updated_at\", precision: nil, null: false\n  end\n\n  create_table \"users\", id: :serial, force: :cascade do |t|\n    t.string \"provider\", default: \"email\", null: false\n    t.string \"uid\", default: \"\", null: false\n    t.string \"encrypted_password\", default: \"\", null: false\n    t.string \"reset_password_token\"\n    t.datetime \"reset_password_sent_at\", precision: nil\n    t.datetime \"remember_created_at\", precision: nil\n    t.integer \"sign_in_count\", default: 0, null: false\n    t.datetime \"current_sign_in_at\", precision: nil\n    t.datetime \"last_sign_in_at\", precision: nil\n    t.string \"current_sign_in_ip\"\n    t.string \"last_sign_in_ip\"\n    t.string \"confirmation_token\"\n    t.datetime \"confirmed_at\", precision: nil\n    t.datetime \"confirmation_sent_at\", precision: nil\n    t.string \"unconfirmed_email\"\n    t.string \"name\", null: false\n    t.string \"display_name\"\n    t.string \"email\"\n    t.json \"tokens\"\n    t.datetime \"created_at\", precision: nil, null: false\n    t.datetime \"updated_at\", precision: nil, null: false\n    t.string \"pubsub_token\"\n    t.integer \"availability\", default: 0\n    t.jsonb \"ui_settings\", default: {}\n    t.jsonb \"custom_attributes\", default: {}\n    t.string \"type\"\n    t.text \"message_signature\"\n    t.index [\"email\"], name: \"index_users_on_email\"\n    t.index [\"pubsub_token\"], name: \"index_users_on_pubsub_token\", unique: true\n    t.index [\"reset_password_token\"], name: \"index_users_on_reset_password_token\", unique: true\n    t.index [\"uid\", \"provider\"], name: \"index_users_on_uid_and_provider\", unique: true\n  end\n\n  create_table \"webhooks\", force: :cascade do |t|\n    t.integer \"account_id\"\n    t.integer \"inbox_id\"\n    t.string \"url\"\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.integer \"webhook_type\", default: 0\n    t.jsonb \"subscriptions\", default: [\"conversation_status_changed\", \"conversation_updated\", \"conversation_created\", \"contact_created\", \"contact_updated\", \"message_created\", \"message_updated\", \"webwidget_triggered\"]\n    t.index [\"account_id\", \"url\"], name: \"index_webhooks_on_account_id_and_url\", unique: true\n  end\n\n  create_table \"working_hours\", force: :cascade do |t|\n    t.bigint \"inbox_id\"\n    t.bigint \"account_id\"\n    t.integer \"day_of_week\", null: false\n    t.boolean \"closed_all_day\", default: false\n    t.integer \"open_hour\"\n    t.integer \"open_minutes\"\n    t.integer \"close_hour\"\n    t.integer \"close_minutes\"\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.boolean \"open_all_day\", default: false\n    t.index [\"account_id\"], name: \"index_working_hours_on_account_id\"\n    t.index [\"inbox_id\"], name: \"index_working_hours_on_inbox_id\"\n  end\n\n  add_foreign_key \"active_storage_attachments\", \"active_storage_blobs\", column: \"blob_id\"\n  add_foreign_key \"active_storage_variant_records\", \"active_storage_blobs\", column: \"blob_id\"\n  add_foreign_key \"inboxes\", \"portals\"\n  create_trigger(\"accounts_after_insert_row_tr\", :generated => true, :compatibility => 1).\n      on(\"accounts\").\n      after(:insert).\n      for_each(:row) do\n    \"execute format('create sequence IF NOT EXISTS conv_dpid_seq_%s', NEW.id);\"\n  end\n\n  create_trigger(\"conversations_before_insert_row_tr\", :generated => true, :compatibility => 1).\n      on(\"conversations\").\n      before(:insert).\n      for_each(:row) do\n    \"NEW.display_id := nextval('conv_dpid_seq_' || NEW.account_id);\"\n  end\n\n  create_trigger(\"camp_dpid_before_insert\", :generated => true, :compatibility => 1).\n      on(\"accounts\").\n      name(\"camp_dpid_before_insert\").\n      after(:insert).\n      for_each(:row) do\n    \"execute format('create sequence IF NOT EXISTS camp_dpid_seq_%s', NEW.id);\"\n  end\n\n  create_trigger(\"campaigns_before_insert_row_tr\", :generated => true, :compatibility => 1).\n      on(\"campaigns\").\n      before(:insert).\n      for_each(:row) do\n    \"NEW.display_id := nextval('camp_dpid_seq_' || NEW.account_id);\"\n  end\n\nend",
      ],
    },
    {
      role: "model",
      parts: [
        "Excelente! O schema do Chatwoot é uma mina de ouro de informações para quem está construindo uma plataforma de atendimento e comunicação. Ele é um sistema maduro e resolve muitos dos problemas que você também enfrentará.\n\nVamos analisar as partes mais relevantes do schema do Chatwoot para a sua funcionalidade de Live Chat e como podemos nos inspirar nele, adaptando para o nosso design com Hono e Supabase.\n\n**Pontos Chave do Schema do Chatwoot Relevantes para Live Chat (e mais):**\n\n1.  **`accounts`**: Seria o equivalente à nossa tabela `organizations`. É a entidade principal para multi-tenancy.\n    *   **Inspiração:** Confirma a necessidade de uma entidade de \"conta\" ou \"organização\" para isolar dados. Detalhes como `name`, `locale`, `custom_attributes`, `settings`, `status` são úteis.\n\n2.  **`users`**: Usuários do sistema (agentes, administradores).\n    *   **Inspiração:** Nossa `user_profiles` (ligada à `auth.users` do Supabase) cumpre esse papel. Campos como `name`, `display_name`, `email`, `pubsub_token` (para realtime), `ui_settings`, `custom_attributes` são interessantes.\n\n3.  **`account_users`**: Tabela de junção para associar usuários a contas, definindo seus papéis (`role`).\n    *   **Inspiração:** No nosso caso, `user_profiles.organization_id` e `user_profiles.role` cobrem isso. Se um usuário pudesse pertencer a múltiplas organizações com papéis diferentes, uma tabela de junção similar seria necessária.\n\n4.  **`inboxes`**: Representa um \"ponto de entrada\" para conversas em uma conta. Cada `inbox` está associada a um canal específico (`channel_type`, `channel_id`).\n    *   **Inspiração:** Nossa tabela `channels` é a análoga direta. O Chatwoot separa a \"configuração do canal\" (ex: `channel_whatsapp`) da \"caixa de entrada\" (`inboxes`) que usa esse canal. Essa é uma distinção interessante. No nosso modelo, `channels` já tem `name` e `config`, então ela serve como a \"inbox\" e a configuração do canal em uma só.\n    *   **Detalhes da `inboxes`:**\n        *   `name`: Nome da caixa de entrada.\n        *   `enable_auto_assignment`, `auto_assignment_config`: Para roteamento automático de conversas.\n        *   `greeting_enabled`, `greeting_message`: Mensagens de boas-vindas.\n        *   `working_hours_enabled`, `out_of_office_message`, `timezone`: Gerenciamento de horário de funcionamento.\n        *   `csat_survey_enabled`: Para pesquisas de satisfação.\n        *   `lock_to_single_conversation`: Evita múltiplas conversas abertas com o mesmo contato na mesma inbox.\n\n5.  **Tabelas de Canais Específicos (`channel_api`, `channel_email`, `channel_facebook_pages`, `channel_whatsapp`, etc.):**\n    *   **Inspiração:** O Chatwoot tem uma tabela para cada tipo de canal, armazenando as configurações específicas.\n    *   **Nossa Abordagem vs. Chatwoot:**\n        *   **Chatwoot:** Múltiplas tabelas (ex: `channel_whatsapp`, `channel_telegram`). A tabela `inboxes` tem `channel_type` e `channel_id` para fazer a ligação polimórfica.\n        *   **Nossa Proposta Anterior:** Uma única tabela `channels` com `type` (enum) e `config_jsonb`/`credentials_jsonb`.\n        *   **Qual é melhor?**\n            *   **Múltiplas Tabelas (Chatwoot):** Mais estruturado, schema mais rígido, integridade referencial mais forte para cada tipo de canal. Pode ser mais fácil de consultar campos específicos de um tipo de canal.\n            *   **JSONB (Nossa Proposta):** Mais flexível para adicionar novos tipos de canais sem migrações de schema complexas. Consultar dentro do JSONB pode ser menos performático para filtros muito complexos, mas o PostgreSQL é bom nisso.\n            *   **Conclusão para Nós:** Para a flexibilidade inicial e a velocidade de desenvolvimento com Hono/Supabase, manter `channels` com JSONB é provavelmente mais ágil. Se em algum momento a complexidade das configurações de um canal específico se tornar muito grande e as consultas ao JSONB um gargalo, pode-se considerar separar esse tipo de canal em uma tabela própria e manter a ligação via `channels.id`.\n\n6.  **`contacts`**: Os clientes/usuários finais.\n    *   **Inspiração:** Praticamente idêntica à nossa tabela `contacts`. Campos como `name`, `email`, `phone_number`, `additional_attributes`, `custom_attributes`, `last_activity_at` são padrão. O `identifier` pode ser um ID customizado.\n\n7.  **`contact_inboxes`**: Associa um `contact` a uma `inbox` específica, e crucialmente, armazena o `source_id`. O `source_id` é o identificador do contato *naquela plataforma/canal específico* (ex: número do WhatsApp do cliente, ID do usuário do Telegram).\n    *   **Inspiração:** **Este é um conceito muito importante!** Nossa tabela `contact_identifiers` foi projetada para isso.\n        *   `contact_identifiers (nossa)`: `contact_id`, `channel_id` (opcional, poderia ser `channel_type_enum`), `identifier_type` (enum), `value` (o source\\_id).\n        *   **Vantagem da nossa `contact_identifiers`:** Permite que um `contact` tenha múltiplos identificadores mesmo sem estar associado a um `channel` específico da nossa plataforma (ex: só temos o email e o telefone dele, ainda não interagiu por um canal configurado).\n        *   **Ligação:** Quando uma mensagem chega de um `source_id` em um `channel_id` específico, procuramos em `contact_identifiers` por esse `value` e `identifier_type` (derivado do `channel.type`). Se encontrado, associamos ao `contact_id`. Se não, criamos um novo `contact` e um novo `contact_identifier`.\n\n8.  **`conversations`**: A entidade central do Live Chat. Agrupa mensagens entre um contato e a conta/agentes.\n    *   **Inspiração:** Nossa tabela `live_chat_sessions` foi uma tentativa de modelar isso. A tabela `conversations` do Chatwoot é mais completa e robusta. **Deveríamos adotar uma estrutura mais parecida com `conversations` do Chatwoot e talvez renomear/refinar nossa `live_chat_sessions`.**\n    *   **Campos importantes em `conversations` (Chatwoot):**\n        *   `account_id`, `inbox_id`, `contact_id`, `contact_inbox_id`\n        *   `status` (open, resolved, pending, snoozed, etc.)\n        *   `assignee_id` (agente atribuído)\n        *   `team_id` (time atribuído)\n        *   `display_id` (um ID sequencial por conta para facilitar a referência)\n        *   `contact_last_seen_at`, `agent_last_seen_at`, `assignee_last_seen_at`\n        *   `last_activity_at` (crucial para ordenação e dashboards)\n        *   `snoozed_until`\n        *   `custom_attributes`\n        *   `priority`\n        *   `first_reply_created_at` (para métricas de SLA)\n        *   `cached_label_list` (denormalização para performance)\n\n9.  **`messages`**: As mensagens individuais dentro de uma conversa.\n    *   **Inspiração:** Nossa tabela `messages` é muito similar.\n    *   **Campos importantes em `messages` (Chatwoot):**\n        *   `content`, `account_id`, `inbox_id`, `conversation_id`\n        *   `message_type` (incoming, outgoing, template, activity/internal note)\n        *   `private` (para notas internas que o cliente não vê)\n        *   `status` (sent, delivered, read, failed)\n        *   `source_id` (ID da mensagem na plataforma externa)\n        *   `content_type` (text, image, etc. - nossa enum `message_content_type_enum`)\n        *   `content_attributes` (metadados do conteúdo, e.g., para botões interativos)\n        *   `sender_type` (`User`, `Contact`, `AgentBot`) e `sender_id`\n        *   `processed_message_content` (para conteúdo após sanitização ou processamento de IA)\n        *   `sentiment`\n\n10. **`attachments`**: Anexos das mensagens. Ligados à `active_storage_blobs` (Rails Active Storage).\n    *   **Inspiração:** Precisamos de uma forma de lidar com anexos.\n        *   **Nossa `messages.media_url`:** Simples, mas assume que o arquivo já está hospedado em algum lugar (Supabase Storage, S3, etc.).\n        *   **Abordagem Chatwoot/ActiveStorage:** Mais integrada. O blob é armazenado e a tabela `attachments` referencia esse blob e o associa à mensagem.\n        *   **Para nós:** Podemos ter uma tabela `message_attachments` que liga `message_id` a um `file_id` (que poderia ser um objeto no Supabase Storage), junto com `file_name`, `file_type`, `file_size`. O `messages.media_url` seria preenchido com a URL pública (ou assinada) do Supabase Storage.\n\n11. **`teams` e `team_members`**: Para organizar agentes em times e atribuir conversas a times.\n    *   **Inspiração:** Se você precisa dessa funcionalidade, essas tabelas são um bom modelo. Nossa `user_profiles` poderia ter um `default_team_id`.\n\n12. **`agent_bots` e `agent_bot_inboxes`**: Para conectar bots (como Dialogflow, Rasa, ou seu próprio workflow de IA) a inboxes.\n    *   **Inspiração:** Se seus workflows de automação podem atuar como \"agentes\" em conversas, essa é uma ideia interessante. Um `agent_bot` poderia ser um tipo especial de `user` ou uma entidade separada que pode ser o `assignee_id` de uma conversa.\n\n13. **`automation_rules`**: Regras simples de automação baseadas em eventos (ex: \"se conversa criada na inbox X, adicionar tag Y\").\n    *   **Inspiração:** Isso é mais simples que nosso sistema de `workflows` completo, mas pode ser útil para ações rápidas. Nossos `workflows` com `trigger_type = 'event_bus'` poderiam cobrir isso.\n\n14. **`webhooks` (do Chatwoot):** Esta tabela no Chatwoot é para **webhooks de saída** que o Chatwoot envia para notificar sistemas externos sobre eventos (ex: `conversation_created`, `message_created`).\n    *   **Inspiração:** Exatamente o que nossa tabela `event_subscriptions` visa fazer. Os `subscriptions` JSONB no Chatwoot (`default: [\"conversation_status_changed\", ...]`) é uma boa maneira de definir quais eventos disparam o webhook.\n\n15. **Outros:**\n    *   `canned_responses`: Respostas prontas.\n    *   `labels`, `taggings`: Para etiquetar conversas, contatos.\n    *   `notifications`, `notification_settings`: Sistema de notificação para agentes.\n    *   `csat_survey_responses`: Feedback de satisfação.\n    *   `sla_policies`, `applied_slas`, `sla_events`: Gerenciamento de Acordos de Nível de Serviço (SLA).\n\n**Como Aproveitar para Integrar Live Chat (e mais) no Nosso Sistema:**\n\n1.  **Adote a Tabela `conversations` (inspirada no Chatwoot):**\n    *   Renomeie ou substitua nossa `live_chat_sessions` por uma tabela `conversations` mais robusta, incorporando os campos chave do Chatwoot (`status`, `assignee_id`, `team_id`, `last_activity_at`, `snoozed_until`, etc.).\n    *   Mantenha as FKs para `organization_id`, `channel_id` (nossa `channels` que é a \"inbox\"), `contact_id`.\n    *   `display_id`: Pode ser implementado com uma sequence do PostgreSQL por `organization_id` usando um trigger, como o Chatwoot faz.\n\n2.  **Refine a Tabela `messages`:**\n    *   Adicione `private` (boolean) para notas internas.\n    *   Adicione `sender_type` (enum: 'user', 'contact', 'agent_bot', 'automation') e `sender_id` (UUID, polimórfico). Isso permite que tanto usuários (agentes), contatos, bots ou workflows sejam remetentes.\n    *   `source_id` (string) para o ID da mensagem na plataforma externa é crucial.\n\n3.  **Gerenciamento de Anexos (`message_attachments`):**\n    *   Crie uma tabela `message_attachments`:\n        ```sql\n        CREATE TABLE message_attachments (\n            id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n            message_id BIGINT NOT NULL REFERENCES messages(id) ON DELETE CASCADE,\n            organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,\n            -- Se usar Supabase Storage:\n            storage_object_path TEXT NOT NULL, -- e.g., 'org_uuid/message_uuid/filename.jpg'\n            file_name TEXT NOT NULL,\n            file_type TEXT, -- MIME type\n            file_size_bytes BIGINT,\n            -- Opcional: thumbnail_url\n            created_at TIMESTAMPTZ DEFAULT NOW()\n        );\n        -- Index: message_id, organization_id\n        ```\n    *   O `messages.media_url` pode ser removido ou usado como um campo de conveniência se houver apenas um anexo principal. A tabela `message_attachments` permite múltiplos anexos.\n\n4.  **Roteamento e Atribuição:**\n    *   A lógica para `assignee_id` e `team_id` na tabela `conversations` precisará ser implementada nos seus serviços.\n    *   Isso pode envolver regras de round-robin, load-based, baseadas em skills (tags do agente), ou manuais.\n\n5.  **Status de Agente (`account_users.availability` no Chatwoot):**\n    *   Nossa tabela `user_profiles` pode ter um campo `availability_status` (enum: 'online', 'offline', 'busy') e `auto_offline_at` (timestamp). Isso é importante para o roteamento e para a UI dos agentes.\n\n6.  **`contact_inboxes` vs. `contact_identifiers`:**\n    *   A lógica principal de identificação de contatos já está na nossa `contact_identifiers`.\n    *   O `contact_inboxes.source_id` do Chatwoot é o `contact_identifiers.value` no nosso sistema.\n    *   O `contact_inboxes.pubsub_token` é para realtime específico do contato naquela inbox; podemos ter um mecanismo de realtime mais geral via Supabase Realtime para conversas/mensagens.\n\n7.  **Integração com Workflows:**\n    *   **Disparar Workflows:** Um workflow pode ser disparado por \"nova conversa criada\" ou \"nova mensagem recebida\". O `trigger_manager` do nosso `workflow_engine` lidaria com isso.\n    *   **Workflows como Agentes:** Um workflow pode atuar em uma conversa:\n        *   Lendo mensagens.\n        *   Enviando mensagens (usando `messages.services.ts`, com `sender_type = 'automation'`, `sender_id = workflow_execution_id`).\n        *   Alterando o status da conversa, atribuindo a um agente/time, adicionando tags.\n        *   O `agent_bots` do Chatwoot é uma boa inspiração. Podemos ter uma forma de \"atribuir\" uma conversa a um `workflow_id` para que ele processe.\n\n**Estrutura da API Hono para Live Chat (focando no módulo):**\n\n```\n/src/api/v1/modules/\n  ├── conversations/  # Antigo livechat, agora mais robusto\n  │   ├── conversations.routes.ts\n  │   │   // GET /conversations (listar com filtros: status, assignee, team, inbox)\n  │   │   // GET /conversations/{id}\n  │   │   // POST /conversations (criar manualmente, raro, geralmente via webhook)\n  │   │   // PUT /conversations/{id}/assign (atribuir agente/time)\n  │   │   // PUT /conversations/{id}/status (mudar status: open, resolve, snooze)\n  │   │   // PUT /conversations/{id}/priority\n  │   │   // POST /conversations/{id}/labels (adicionar/remover labels)\n  │   │   // POST /conversations/{id}/messages (agente envia mensagem - usa messages.services)\n  │   │   // GET /conversations/{id}/messages (listar mensagens da conversa)\n  │   ├── conversations.services.ts\n  │   │   // Lógica para criar, atualizar, atribuir, mudar status.\n  │   │   // Lógica de roteamento (se não for feita por um workflow dedicado).\n  │   │   // Interage com Supabase Realtime para notificar UIs.\n  │   └── conversations.validators.ts\n  │\n  ├── messages/       # Permanece central, mas agora com `sender_type`, `private`\n  │   ├── messages.routes.ts\n  │   │   // POST /messages (endpoint genérico para enviar, usado por conversations e workflows)\n  │   ├── messages.services.ts\n  │   │   // Determina o canal correto, formata para a plataforma, envia.\n  │   │   // Cria o registro de mensagem no DB.\n  │   │   // Lida com upload de anexos para Supabase Storage e cria registros em `message_attachments`.\n  │   └── messages.validators.ts\n  │\n  ├── user_profiles/ (ou um módulo `agents/`)\n  │   ├── user_profiles.routes.ts\n  │   │   // PUT /me/availability (agente muda seu status online/offline)\n  │   └── user_profiles.services.ts\n```\n\n**Conclusão sobre Chatwoot:**\n\nO schema do Chatwoot é muito rico e bem pensado para uma plataforma de atendimento. Podemos (e devemos) nos inspirar fortemente nele para a parte de Live Chat, especialmente para as tabelas `conversations` e `messages`, e para conceitos como status de agente, times e roteamento.\n\nNão precisamos replicar *exatamente* todas as tabelas (especialmente a forma como eles lidam com canais vs. inboxes, onde nossa abordagem com JSONB é mais ágil inicialmente), mas os *conceitos e campos chave* são extremamente valiosos. A ideia é pegar o melhor do Chatwoot e adaptar ao nosso ecossistema Hono/Supabase e aos requisitos específicos do seu projeto omnichannel com workflows.",
      ],
    },
    {
      role: "user",
      parts: [
        "agora tem essa do typebot que acho muito bacana o flow builder deles.. muito pratico\ngenerator client {\n  provider        = \"prisma-client-js\"\n  previewFeatures = [\"metrics\"]\n}\n\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel Account {\n  id                       String  @id @default(cuid())\n  userId                   String\n  type                     String\n  provider                 String\n  providerAccountId        String\n  refresh_token            String?\n  access_token             String?\n  expires_at               Int?\n  token_type               String?\n  scope                    String?\n  id_token                 String?\n  session_state            String?\n  oauth_token_secret       String?\n  oauth_token              String?\n  refresh_token_expires_in Int?\n  user                     User    @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@unique([provider, providerAccountId])\n}\n\nmodel Session {\n  id           String   @id @default(cuid())\n  sessionToken String   @unique\n  userId       String\n  expires      DateTime\n  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)\n}\n\nmodel User {\n  id                          String                    @id @default(cuid())\n  createdAt                   DateTime                  @default(now())\n  updatedAt                   DateTime                  @default(now()) @updatedAt\n  lastActivityAt              DateTime                  @default(now())\n  name                        String?\n  email                       String?                   @unique\n  emailVerified               DateTime?\n  image                       String?\n  company                     String?\n  onboardingCategories        Json\n  referral                    String?\n  graphNavigation             GraphNavigation?\n  preferredAppAppearance      String?\n  accounts                    Account[]\n  apiTokens                   ApiToken[]\n  CollaboratorsOnTypebots     CollaboratorsOnTypebots[]\n  workspaces                  MemberInWorkspace[]\n  sessions                    Session[]\n  bannedIps                   BannedIp[]\n  displayedInAppNotifications Json?\n  credentials                 UserCredentials[]\n  groupTitlesAutoGeneration   Json?\n  preferredLanguage           String?\n}\n\nmodel ApiToken {\n  id        String   @id @default(cuid())\n  createdAt DateTime @default(now())\n  token     String   @unique\n  name      String\n  ownerId   String\n  owner     User     @relation(fields: [ownerId], references: [id], onDelete: Cascade)\n}\n\nmodel Workspace {\n  id                            String                @id @default(cuid())\n  createdAt                     DateTime              @default(now())\n  updatedAt                     DateTime              @default(now()) @updatedAt\n  name                          String\n  icon                          String?\n  plan                          Plan                  @default(FREE)\n  stripeId                      String?               @unique\n  credentials                   Credentials[]\n  customDomains                 CustomDomain[]\n  folders                       DashboardFolder[]\n  members                       MemberInWorkspace[]\n  typebots                      Typebot[]\n  invitations                   WorkspaceInvitation[]\n  additionalChatsIndex          Int                   @default(0)\n  additionalStorageIndex        Int                   @default(0)\n  chatsLimitFirstEmailSentAt    DateTime?\n  storageLimitFirstEmailSentAt  DateTime?\n  chatsLimitSecondEmailSentAt   DateTime?\n  storageLimitSecondEmailSentAt DateTime?\n  claimableCustomPlan           ClaimableCustomPlan?\n  customChatsLimit              Int?\n  customStorageLimit            Int?\n  customSeatsLimit              Int?\n  isQuarantined                 Boolean               @default(false)\n  isSuspended                   Boolean               @default(false)\n  isPastDue                     Boolean               @default(false)\n  isVerified                    Boolean?\n  themeTemplates                ThemeTemplate[]\n  chatsHardLimit                Int?\n  // TODO: remove\n  settings                      Json?\n  lastActivityAt                DateTime?\n  inactiveFirstEmailSentAt      DateTime?\n  inactiveSecondEmailSentAt     DateTime?\n}\n\nmodel MemberInWorkspace {\n  createdAt   DateTime      @default(now())\n  updatedAt   DateTime      @default(now()) @updatedAt\n  userId      String\n  workspaceId String\n  role        WorkspaceRole\n  user        User          @relation(fields: [userId], references: [id], onDelete: Cascade)\n  workspace   Workspace     @relation(fields: [workspaceId], references: [id], onDelete: Cascade)\n\n  @@unique([userId, workspaceId])\n}\n\nmodel WorkspaceInvitation {\n  id          String        @id @default(cuid())\n  createdAt   DateTime      @default(now())\n  updatedAt   DateTime      @default(now()) @updatedAt\n  email       String\n  workspaceId String\n  type        WorkspaceRole\n  workspace   Workspace     @relation(fields: [workspaceId], references: [id], onDelete: Cascade)\n}\n\nmodel CustomDomain {\n  name        String    @id\n  createdAt   DateTime  @default(now())\n  workspaceId String\n  workspace   Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)\n}\n\nmodel Credentials {\n  id          String    @id @default(cuid())\n  createdAt   DateTime  @default(now())\n  workspaceId String\n  data        String\n  name        String\n  type        String\n  iv          String\n  workspace   Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)\n}\n\nmodel UserCredentials {\n  id        String   @id @default(cuid())\n  createdAt DateTime @default(now())\n  userId    String\n  data      String   @db.Text\n  name      String\n  type      String\n  iv        String\n  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)\n}\n\nmodel VerificationToken {\n  identifier String\n  token      String   @unique\n  value      String?\n  expires    DateTime\n\n  @@unique([identifier, token])\n}\n\nmodel DashboardFolder {\n  id             String            @id @default(cuid())\n  createdAt      DateTime          @default(now())\n  updatedAt      DateTime          @default(now()) @updatedAt\n  name           String\n  parentFolderId String?\n  workspaceId    String\n  parentFolder   DashboardFolder?  @relation(\"ParentChild\", fields: [parentFolderId], references: [id])\n  workspace      Workspace         @relation(fields: [workspaceId], references: [id], onDelete: Cascade)\n  childrenFolder DashboardFolder[] @relation(\"ParentChild\")\n  typebots       Typebot[]\n}\n\nmodel Typebot {\n  id                      String                    @id @default(cuid())\n  version                 String?\n  createdAt               DateTime                  @default(now())\n  updatedAt               DateTime                  @default(now()) @updatedAt\n  icon                    String?\n  name                    String\n  folderId                String?\n  groups                  Json\n  events                  Json?\n  variables               Json\n  edges                   Json\n  theme                   Json\n  selectedThemeTemplateId String?\n  settings                Json\n  publicId                String?                   @unique\n  customDomain            String?                   @unique\n  workspaceId             String\n  resultsTablePreferences Json?\n  folder                  DashboardFolder?          @relation(fields: [folderId], references: [id])\n  workspace               Workspace                 @relation(fields: [workspaceId], references: [id], onDelete: Cascade)\n  collaborators           CollaboratorsOnTypebots[]\n  invitations             Invitation[]\n  publishedTypebot        PublicTypebot?\n  results                 Result[]\n  webhooks                Webhook[]\n  isArchived              Boolean                   @default(false)\n  isClosed                Boolean                   @default(false)\n  whatsAppCredentialsId   String?\n  riskLevel               Int?\n  bannedIps               BannedIp[]\n\n  @@index([workspaceId])\n  @@index([isArchived, createdAt(sort: Desc)])\n}\n\nmodel Invitation {\n  createdAt DateTime          @default(now())\n  updatedAt DateTime          @default(now()) @updatedAt\n  email     String\n  typebotId String\n  type      CollaborationType\n  typebot   Typebot           @relation(fields: [typebotId], references: [id], onDelete: Cascade)\n\n  @@unique([email, typebotId])\n}\n\nmodel CollaboratorsOnTypebots {\n  createdAt DateTime          @default(now())\n  updatedAt DateTime          @default(now()) @updatedAt\n  userId    String\n  typebotId String\n  type      CollaborationType\n  typebot   Typebot           @relation(fields: [typebotId], references: [id], onDelete: Cascade)\n  user      User              @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@unique([userId, typebotId])\n}\n\nmodel PublicTypebot {\n  id        String   @id @default(cuid())\n  version   String?\n  createdAt DateTime @default(now())\n  updatedAt DateTime @default(now()) @updatedAt\n  typebotId String   @unique\n  groups    Json\n  events    Json?\n  variables Json\n  edges     Json\n  theme     Json\n  settings  Json\n  typebot   Typebot  @relation(fields: [typebotId], references: [id], onDelete: Cascade)\n}\n\nmodel Result {\n  id                 String                   @id @default(cuid())\n  createdAt          DateTime                 @default(now())\n  typebotId          String\n  variables          Json\n  isCompleted        Boolean\n  hasStarted         Boolean?\n  isArchived         Boolean?                 @default(false)\n  lastChatSessionId  String?\n  typebot            Typebot                  @relation(fields: [typebotId], references: [id], onDelete: Cascade)\n  answers            Answer[]\n  answersV2          AnswerV2[]\n  logs               Log[]\n  edges              VisitedEdge[]\n  setVariableHistory SetVariableHistoryItem[]\n\n  @@index([typebotId, hasStarted, createdAt(sort: Desc)])\n  @@index([typebotId, isCompleted])\n}\n\nmodel SetVariableHistoryItem {\n  result     Result @relation(fields: [resultId], references: [id], onDelete: Cascade)\n  resultId   String\n  index      Int\n  variableId String\n  blockId    String\n  value      Json // string or list \n\n  @@unique([resultId, index])\n}\n\nmodel VisitedEdge {\n  result   Result @relation(fields: [resultId], references: [id], onDelete: Cascade)\n  resultId String\n  edgeId   String\n  index    Int\n\n  @@unique([resultId, index])\n}\n\nmodel Log {\n  id          String   @id @default(cuid())\n  createdAt   DateTime @default(now())\n  resultId    String\n  status      String\n  context     String?\n  description String\n  details     String?\n  result      Result   @relation(fields: [resultId], references: [id], onDelete: Cascade)\n\n  @@index([resultId])\n}\n\nmodel Answer {\n  createdAt  DateTime @default(now()) @updatedAt\n  resultId   String\n  blockId    String\n  groupId    String\n  variableId String?\n  content    String\n  result     Result   @relation(fields: [resultId], references: [id], onDelete: Cascade)\n\n  @@unique([resultId, blockId, groupId])\n}\n\nmodel AnswerV2 {\n  id               Int      @id @default(autoincrement())\n  createdAt        DateTime @default(now())\n  blockId          String\n  content          String\n  attachedFileUrls Json?\n  resultId         String\n  result           Result   @relation(fields: [resultId], references: [id], onDelete: Cascade)\n\n  @@index([blockId])\n}\n\nmodel Coupon {\n  userPropertiesToUpdate Json\n  code                   String    @id @unique\n  dateRedeemed           DateTime?\n}\n\nmodel Webhook {\n  id          String   @id @default(cuid())\n  createdAt   DateTime @default(now())\n  updatedAt   DateTime @default(now()) @updatedAt\n  url         String?\n  method      String\n  queryParams Json\n  headers     Json\n  body        String?\n  typebotId   String\n  typebot     Typebot  @relation(fields: [typebotId], references: [id], onDelete: Cascade)\n}\n\nmodel ClaimableCustomPlan {\n  id           String    @id @default(cuid())\n  createdAt    DateTime  @default(now())\n  claimedAt    DateTime?\n  name         String\n  description  String?\n  price        Int\n  currency     String\n  workspaceId  String    @unique\n  workspace    Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)\n  chatsLimit   Int\n  storageLimit Int\n  seatsLimit   Int\n  isYearly     Boolean   @default(false)\n  companyName  String?\n  vatType      String?\n  vatValue     String?\n}\n\nmodel ChatSession {\n  id         String   @id @default(cuid())\n  createdAt  DateTime @default(now())\n  updatedAt  DateTime @default(now()) @updatedAt\n  state      Json\n  isReplying Boolean?\n}\n\nmodel ThemeTemplate {\n  id          String    @id @default(cuid())\n  createdAt   DateTime  @default(now())\n  updatedAt   DateTime  @default(now()) @updatedAt\n  name        String\n  theme       Json\n  workspace   Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)\n  workspaceId String\n}\n\nmodel BannedIp {\n  id                   String   @id @default(cuid())\n  createdAt            DateTime @default(now())\n  ip                   String   @unique\n  responsibleTypebot   Typebot  @relation(fields: [responsibleTypebotId], references: [id], onDelete: Restrict)\n  responsibleTypebotId String\n  user                 User     @relation(fields: [userId], references: [id], onDelete: Restrict)\n  userId               String\n}\n\nenum WorkspaceRole {\n  ADMIN\n  MEMBER\n  GUEST\n}\n\nenum GraphNavigation {\n  MOUSE\n  TRACKPAD\n}\n\nenum Plan {\n  FREE\n  STARTER\n  PRO\n  LIFETIME\n  OFFERED\n  CUSTOM\n  UNLIMITED\n  ENTERPRISE\n}\n\nenum CollaborationType {\n  READ\n  WRITE\n  FULL_ACCESS\n}\n",
      ],
    },
    {
      role: "model",
      parts: [
        "O schema do Typebot é realmente muito interessante, especialmente a forma como eles modelam a construção e execução dos \"typebots\" (que são essencialmente chatbots ou fluxos de conversa). O foco deles é claramente na criação e gerenciamento desses fluxos interativos.\n\nVamos analisar o que podemos aprender com o schema do Typebot e como isso se encaixa ou inspira o nosso sistema omnichannel com funcionalidades de workflow.\n\n**Pontos Chave do Schema do Typebot Relevantes para Flow Builders e Workflows:**\n\n1.  **`Workspace`**: Similar à nossa `organizations` ou à `accounts` do Chatwoot. É a entidade de agrupamento principal.\n    *   **Inspiração:** Reforça o modelo multi-tenant. Detalhes como `plan`, `stripeId`, limites (`customChatsLimit`, `customStorageLimit`), `isQuarantined`, `isSuspended` são específicos para um produto SaaS com billing, o que pode ou não ser seu foco inicial, mas é bom ter em mente para o futuro.\n\n2.  **`User`**: Usuários do sistema.\n    *   **Inspiração:** Padrão. `lastActivityAt` é bom para tracking.\n\n3.  **`Typebot`**: A entidade central, análoga aos nossos `workflows` ou aos `workflow_entity` do n8n. É a definição do bot/fluxo.\n    *   **Campos Cruciais:**\n        *   `groups`: JSON que provavelmente define os blocos/nós do fluxo. **Este é o coração do flow builder.**\n        *   `events`: JSON para eventos dentro do bot (talvez triggers ou ações específicas).\n        *   `variables`: JSON definindo as variáveis usadas no bot.\n        *   `edges`: JSON definindo as conexões/transições entre os `groups` (blocos).\n        *   `theme`: Configurações de aparência do bot quando embarcado.\n        *   `settings`: Outras configurações do bot.\n        *   `publicId`: ID público para acessar o bot.\n        *   `publishedTypebot`: Relação com a versão publicada.\n    *   **Inspiração para Nossos `workflows.definition`:** O schema do Typebot nos dá uma ideia mais concreta de como a `definition` JSON dos nossos workflows poderia ser estruturada. Em vez de um JSON monolítico, poderíamos ter sub-objetos como `nodes` (equivalente a `groups`), `edges`, `variables_schema`, `global_settings` dentro da nossa `workflows.definition`.\n\n4.  **`PublicTypebot`**: Representa a versão \"publicada\" e estável de um `Typebot`.\n    *   **Inspiração:** Muito importante para workflows. Permite que você trabalhe em um rascunho (`Typebot`) sem afetar a versão que está em produção (`PublicTypebot`). Nossa tabela `workflow_versions` e o campo `workflows.latest_version_id` (ou um campo `published_version_id`) tentam cobrir isso. Ter uma tabela separada para a versão publicada é uma abordagem limpa.\n\n5.  **`Result`**: Análogo à nossa `workflow_executions` ou à `execution_entity` do n8n. Registra uma \"sessão\" de interação com um `Typebot`.\n    *   **Campos Interessantes:**\n        *   `variables`: Os valores das variáveis *durante esta execução específica*.\n        *   `isCompleted`, `hasStarted`.\n        *   `lastChatSessionId`: Se o Typebot interage com um sistema de chat.\n    *   **Relações:**\n        *   `answers` / `answersV2`: Respostas dadas pelo usuário durante a execução.\n        *   `logs`: Logs da execução.\n        *   `edges` (`VisitedEdge`): Quais conexões foram percorridas.\n        *   `setVariableHistory`: Histórico de como as variáveis foram definidas.\n    *   **Inspiração para Nossos `workflow_executions` e `workflow_execution_step_logs`:** O Typebot tem um log bem detalhado por execução. `VisitedEdge` e `SetVariableHistoryItem` são ótimos para depuração e análise do fluxo. Nossa `workflow_execution_step_logs` poderia ser enriquecida para capturar informações similares sobre quais \"edges\" (transições entre nossos nós de workflow) foram tomadas e como as variáveis do workflow foram alteradas em cada passo.\n\n6.  **`Webhook` (do Typebot):** Esta tabela no Typebot parece definir webhooks que são *configurados dentro de um nó/bloco de um Typebot* para serem chamados como uma ação durante a execução do fluxo (ex: um bloco \"Chamar API Externa\").\n    *   **Inspiração:** No nosso sistema de workflow, um nó do tipo \"HTTP Request\" precisaria de configurações similares (URL, método, headers, body). Essas configurações seriam parte da `definition` do nó dentro da `workflows.definition`, e não necessariamente uma tabela separada `Webhook` no nível do Typebot, a menos que esses webhooks fossem reutilizáveis entre múltiplos nós/typebots.\n    *   **Diferença da Nossa `event_subscriptions`:** Nossa `event_subscriptions` é para webhooks que *nossa plataforma envia para fora* quando eventos do sistema acontecem. O `Webhook` do Typebot é para webhooks que *o workflow/typebot chama como parte de sua lógica*.\n\n7.  **`Credentials` e `UserCredentials`:**\n    *   `Credentials` (ligada a `Workspace`): Armazena credenciais que podem ser usadas por Typebots dentro de um workspace. O `data` é uma string (provavelmente criptografada, dado o campo `iv` - Initialization Vector).\n    *   `UserCredentials` (ligada a `User`): Credenciais específicas do usuário.\n    *   **Inspiração para Nossas `connections`:** Nossa tabela `connections` (ligada a `organization_id`) é análoga. O Typebot armazena o dado criptografado e o IV diretamente na tabela. Nós planejamos usar Supabase Vault e armazenar apenas as referências aos segredos no Vault. Ambas são abordagens válidas para segurança. A vantagem do Vault é que ele é um serviço dedicado a segredos.\n\n8.  **`ChatSession`**: Parece ser uma tabela para gerenciar o estado de uma sessão de chat em andamento com um Typebot, especialmente se o bot precisar \"lembrar\" onde parou ou se está esperando uma resposta.\n    *   **Inspiração:** Se os nossos `workflows` puderem ter interações de longa duração ou \"esperar\" por uma resposta de um usuário em um canal de chat, precisaríamos de algo para gerenciar esse estado de \"pausa\" e \"retomada\". Nossa `workflow_executions.status = 'waiting'` e `workflow_executions.execution_data` (para armazenar o estado de continuação) poderiam servir para isso.\n\n**Como Integrar/Aproveitar as Ideias do Typebot no Nosso Sistema:**\n\n1.  **Melhorar a Estrutura do `workflows.definition`:**\n    *   Inspirado pelos campos `groups`, `events`, `variables`, `edges` do `Typebot`, podemos definir uma estrutura JSON mais clara para nossa `workflows.definition`:\n        ```json\n        // Exemplo para workflows.definition\n        {\n          \"nodes\": [ // Equivalente aos \"groups\" do Typebot\n            { \"id\": \"node_1\", \"type\": \"trigger_whatsapp_message\", \"config\": { /*...*/ } },\n            { \"id\": \"node_2\", \"type\": \"ai_sentiment_analysis\", \"config\": { \"textInput\": \"{{node_1.outputs.message_text}}\", \"connectionId\": \"gemini_conn_uuid\" } },\n            { \"id\": \"node_3\", \"type\": \"http_request\", \"config\": { \"url\": \"...\", \"method\": \"POST\", \"body\": \"...\" } }\n          ],\n          \"edges\": [ // Conexões entre os nós\n            { \"id\": \"edge_1\", \"sourceNodeId\": \"node_1\", \"targetNodeId\": \"node_2\" },\n            { \"id\": \"edge_2\", \"sourceNodeId\": \"node_2\", \"targetNodeId\": \"node_3\", \"condition\": \"{{node_2.outputs.sentiment == 'positive'}}\" } // Condições nas edges\n          ],\n          \"variablesSchema\": [ // Definição das variáveis do workflow (nome, tipo, valor inicial)\n            { \"id\": \"var_1\", \"name\": \"customerName\", \"type\": \"string\", \"initialValue\": \"\" }\n          ],\n          \"globalSettings\": {\n            \"errorHandlingNodeId\": \"node_error_handler\" // Opcional: nó para onde ir em caso de erro\n          }\n        }\n        ```\n    *   **Flow Builder UI:** Essa estrutura JSON seria o que seu flow builder visual (frontend) geraria e consumiria.\n\n2.  **Enriquecer `workflow_execution_step_logs`:**\n    *   Adicionar campos para `edge_taken_id` (qual transição foi usada para chegar a este nó) e `variable_changes_jsonb` (um diff ou snapshot das variáveis após a execução do nó). Isso espelha a granularidade de `VisitedEdge` e `SetVariableHistoryItem` do Typebot e é imensamente útil para depuração.\n\n3.  **Conceito de \"Publicação\" de Workflows:**\n    *   Nossa tabela `workflow_versions` e a ideia de ter um `published_version_id` na tabela `workflows` é boa. O `PublicTypebot` do Typebot reforça a importância disso. Garante que as execuções sempre usem uma versão estável e testada, enquanto se pode trabalhar em novas versões.\n\n4.  **Nós de Workflow do Tipo \"Webhook\" (Chamar API Externa):**\n    *   Um tipo de nó no nosso `workflow_engine/node_handlers/` seria `http_request.handler.ts`. As configurações desse nó (URL, método, headers, body, qual `connection` usar para autenticação se necessário) seriam parte da `definition` do nó, como discutido acima. Isso é similar ao `Webhook` do Typebot, mas embutido na definição do workflow.\n\n5.  **Armazenamento de Estado para Workflows Interativos/Pausados:**\n    *   Se um workflow precisa esperar por uma entrada de usuário (ex: um bot perguntando algo no chat e esperando a resposta), o `workflow_engine` precisará:\n        1.  Salvar o estado atual da execução (em `workflow_executions.execution_data` ou um campo similar).\n        2.  Mudar o `workflow_executions.status` para `'waiting'`.\n        3.  Ter um mecanismo para \"retomar\" a execução quando a entrada do usuário chegar (ex: uma nova mensagem no chat que referencia a conversa/execução em espera). O `ChatSession` do Typebot é uma inspiração para esse estado de espera.\n\n6.  **Credenciais (`connections` vs. `Credentials` do Typebot):**\n    *   Nossa abordagem com `connections` e Supabase Vault é robusta. A chave é ter uma UI clara para o usuário configurar essas conexões e o `workflow_engine` usá-las de forma transparente e segura.\n\n**O que o Typebot NÃO foca tanto (e nós sim):**\n\n*   **Gestão Omnichannel Detalhada:** O Typebot é focado em criar *bots*. Nosso sistema é focado em gerenciar *canais de comunicação* e *conversas* nesses canais, com a automação (workflows) sendo uma camada poderosa por cima.\n*   **CRM/Leads/Project Management:** Essas são funcionalidades centrais para nós, mas secundárias (ou inexistentes) para o Typebot.\n\n**Conclusão:**\n\nO schema do Typebot é uma excelente referência para a parte de **construção e execução de fluxos/bots**. Podemos nos inspirar muito na forma como eles estruturam a definição de um \"typebot\" (`groups`, `edges`, `variables`) e o log detalhado de suas execuções (`Result` e suas tabelas relacionadas).\n\nA ideia é integrar esses conceitos de \"flow builder\" e \"execução de fluxo\" dentro da nossa arquitetura de `workflows`, `workflow_executions`, e `workflow_engine`, mantendo a robustez do nosso backend omnichannel.\n\n**Próximos Passos Chave Inspirados pelo Typebot:**\n\n1.  **Definir a Estrutura Detalhada do JSON para `workflows.definition`:** Inspirado em `groups`, `edges`, `variables` do Typebot.\n2.  **Projetar o `workflow_engine/executor.ts`:** Para interpretar essa definição.\n3.  **Planejar os `workflow_engine/node_handlers/`:** Quais tipos de blocos/nós seu flow builder oferecerá inicialmente? (Ex: Enviar Mensagem Omnichannel, Chamar API, Condição If/Else, Delay, Ler/Escrever Variáveis, Chamar IA).\n4.  **Melhorar o Logging em `workflow_execution_step_logs`:** Para incluir mais detalhes sobre o fluxo e as variáveis.\n\nEssa análise comparativa é muito produtiva! Continuar olhando para sistemas existentes nos ajuda a construir algo ainda melhor e mais adequado às nossas necessidades.",
      ],
    },
    {
      role: "user",
      parts: [
        "seria meio que fazer automacao de funil pra abordar leads, aquecer.. manter o followup.. agendar envios.. regras... basicamente as features do Manychat e expandingo alguns outros como processar e segmentar as acoes com LMM..\n",
      ],
    },
    {
      role: "model",
      parts: [
        "Entendido perfeitamente! Se o objetivo é criar automações de funil para abordar leads, aquecer, fazer follow-up, agendar envios, aplicar regras e, crucialmente, segmentar e processar ações com LLMs (Grandes Modelos de Linguagem), então o design do nosso `workflow_engine` e a estrutura do `workflows.definition` se tornam ainda mais centrais e precisam ser pensados com essas capacidades em mente.\n\nVamos focar em como adaptar e expandir nosso design para suportar essas funcionalidades de automação de marketing e vendas, inspirando-nos em ferramentas como ManyChat, mas com o poder adicional dos LLMs.\n\n**Requisitos Chave para Automação de Funil com LLMs:**\n\n1.  **Triggers Flexíveis:**\n    *   Novo lead de uma fonte específica (Webhook de formulário, nova conversa em canal X).\n    *   Lead atinge um certo estágio no CRM.\n    *   Ação do usuário (clica em um link rastreado, visita uma página).\n    *   Tempo (agendamentos, delays).\n    *   Mudança de tag ou segmento do contato.\n    *   Mensagem recebida com certas palavras-chave ou intenção (detectada por LLM).\n\n2.  **Ações Poderosas:**\n    *   Enviar mensagens personalizadas em múltiplos canais (usando nossa camada omnichannel).\n    *   Adicionar/remover tags, atualizar campos customizados do contato/lead.\n    *   Mover lead para outro estágio do funil.\n    *   Atribuir lead/conversa a um agente/time.\n    *   **Chamar LLM para:**\n        *   Analisar sentimento/intenção de mensagens recebidas.\n        *   Gerar respostas personalizadas.\n        *   Resumir conversas.\n        *   Extrair informações de textos.\n        *   Classificar/segmentar leads com base em texto livre.\n    *   Fazer requisições HTTP para APIs externas.\n    *   Adicionar a audiências de retargeting (Facebook, Google).\n    *   Esperar por um tempo ou por uma ação específica do usuário.\n\n3.  **Lógica e Condições:**\n    *   Ramificações (If/Else) baseadas em:\n        *   Atributos do contato/lead.\n        *   Tags.\n        *   Interações anteriores.\n        *   Conteúdo da mensagem.\n        *   Saída de um nó LLM (ex: se sentimento é positivo).\n    *   A/B testing de mensagens ou caminhos do fluxo.\n\n4.  **Segmentação e Personalização:**\n    *   Usar dados do contato/lead e histórico de interações para personalizar mensagens e caminhos.\n    *   LLMs podem ajudar a criar segmentos dinâmicos ou hiper-personalizar conteúdo.\n\n5.  **Gerenciamento e Análise:**\n    *   Visualizar o fluxo e o progresso dos leads através dele.\n    *   Analytics sobre a performance do funil (taxas de abertura, cliques, conversões por etapa).\n\n**Adaptando Nosso Design (Workflows, Conexões, IA):**\n\n**1. Tabela `workflows` e `workflows.definition` (Foco no Funil):**\n\n*   **`workflows.trigger_type`**: Deve incluir opções como:\n    *   `'webhook_generic'` (para formulários, etc.)\n    *   `'channel_message_received'` (com filtros por canal, palavras-chave, intenção LLM)\n    *   `'contact_created'`\n    *   `'contact_updated'` (ex: tag adicionada, campo alterado)\n    *   `'lead_stage_changed'`\n    *   `'tracked_event_received'` (do nosso tracker.js)\n    *   `'schedule_cron'`\n    *   `'schedule_datetime'` (agendamento específico)\n*   **`workflows.definition` (Estrutura JSON - exemplo focado em funil):**\n    ```json\n    {\n      \"nodes\": [\n        {\n          \"id\": \"trigger_new_lead_form\",\n          \"type\": \"trigger:webhook\", // Um tipo de nó especial para o trigger\n          \"config\": { \"webhookPath\": \"/funnel_a_lead_form\" }, // Path único para este trigger\n          \"outputs\": { \"leadData\": \"object\" } // Define o que este nó produz\n        },\n        {\n          \"id\": \"send_welcome_whatsapp\",\n          \"type\": \"action:send_message\",\n          \"config\": {\n            \"channelType\": \"whatsapp\",\n            \"contactIdentifier\": \"{{trigger_new_lead_form.outputs.leadData.phone}}\", // Mapeia do trigger\n            \"messageTemplateId\": \"whatsapp_welcome_template_xyz\", // Ou texto direto\n            \"templateParams\": { \"name\": \"{{trigger_new_lead_form.outputs.leadData.name}}\" }\n          }\n        },\n        {\n          \"id\": \"delay_24h\",\n          \"type\": \"action:delay\",\n          \"config\": { \"duration\": 24, \"unit\": \"hours\" }\n        },\n        {\n          \"id\": \"llm_analyze_interest\",\n          \"type\": \"action:llm_prompt\",\n          \"config\": {\n            \"connectionId\": \"gemini_pro_connection\", // Referência à tabela 'connections'\n            \"prompt\": \"Analise o seguinte interesse do lead: {{trigger_new_lead_form.outputs.leadData.interest_text}}. Classifique o nível de interesse como 'alto', 'médio', ou 'baixo' e extraia os principais tópicos de interesse. Responda em JSON: {'level': '...', 'topics': ['...']}\",\n            \"outputVariable\": \"llm_interest_analysis\" // Nome da variável para armazenar a saída do LLM\n          }\n        },\n        {\n          \"id\": \"condition_interest_level\",\n          \"type\": \"logic:if_else\",\n          \"config\": {\n            \"conditions\": [\n              { \"pathName\": \"Alto Interesse\", \"condition\": \"{{llm_interest_analysis.level == 'alto'}}\" },\n              { \"pathName\": \"Médio Interesse\", \"condition\": \"{{llm_interest_analysis.level == 'médio'}}\" }\n              // \"Baixo Interesse\" seria o caminho 'else' (sem condição explícita ou um nó 'default')\n            ]\n          }\n        },\n        {\n          \"id\": \"tag_hot_lead\",\n          \"type\": \"action:update_contact\",\n          \"config\": {\n            \"contactId\": \"{{trigger_new_lead_form.outputs.leadData.contact_id}}\", // Se o trigger já criou/identificou o contato\n            \"addTags\": [\"hot_lead\", \"{{llm_interest_analysis.topics[0]}}\"] // Adiciona tags dinâmicas\n          }\n        },\n        {\n          \"id\": \"assign_to_sales_agent\",\n          \"type\": \"action:assign_conversation_or_lead\", // Precisa definir melhor esta ação\n          \"config\": {\n            \"leadId\": \"...\",\n            \"agentEmail\": \"sales_team_lead@example.com\"\n          }\n        }\n        // ... mais nós para follow-up, etc.\n      ],\n      \"edges\": [\n        { \"sourceNodeId\": \"trigger_new_lead_form\", \"targetNodeId\": \"send_welcome_whatsapp\" },\n        { \"sourceNodeId\": \"send_welcome_whatsapp\", \"targetNodeId\": \"delay_24h\" },\n        { \"sourceNodeId\": \"delay_24h\", \"targetNodeId\": \"llm_analyze_interest\" },\n        { \"sourceNodeId\": \"llm_analyze_interest\", \"targetNodeId\": \"condition_interest_level\" },\n        { \"sourceNodeId\": \"condition_interest_level\", \"targetNodeId\": \"tag_hot_lead\", \"sourceHandle\": \"Alto Interesse\" }, // Handle corresponde ao pathName da condição\n        { \"sourceNodeId\": \"tag_hot_lead\", \"targetNodeId\": \"assign_to_sales_agent\" }\n        // ...\n      ],\n      \"variablesSchema\": [ // Variáveis globais ao workflow, além das saídas dos nós\n        { \"id\": \"var_funnel_stage\", \"name\": \"currentFunnelStage\", \"type\": \"string\", \"initialValue\": \"awareness\" }\n      ]\n    }\n    ```\n    *   **Mapeamento de Dados:** A sintaxe `{{node_id.outputs.variable_name}}` ou `{{variables.variable_name}}` é crucial para passar dados entre os nós.\n\n**2. Tabela `connections` (e Supabase Vault):**\n\n*   Será usada intensamente pelos nós do workflow que interagem com serviços externos (LLMs, CRMs de terceiros, plataformas de anúncio, etc.).\n*   Cada `connection` representa uma autenticação configurada para um serviço (ex: \"Minha Chave API Gemini\", \"Minha Conta Google Ads\").\n\n**3. Tabela `ai_interactions_log`:**\n\n*   Continuará registrando todas as chamadas aos LLMs, sejam elas diretas pela API ou iniciadas por um nó de workflow. O `workflow_execution_id` pode ser adicionado como um campo opcional para ligar a interação de IA à execução específica do workflow que a originou.\n\n**4. `workflow_engine/node_handlers/` (Tipos de Nós Essenciais para Funis):**\n\n*   **`trigger:[type].handler.ts`**:\n    *   `trigger:webhook.handler.ts`: Recebe dados de webhooks genéricos.\n    *   `trigger:message_received.handler.ts`: Dispara quando uma mensagem chega, pode ter lógica para extrair dados ou chamar um LLM para pré-análise.\n    *   `trigger:contact_event.handler.ts`: Dispara em criação/atualização de contato/lead.\n    *   `trigger:schedule.handler.ts`: Para agendamentos.\n*   **`action:send_message.handler.ts`**:\n    *   Configurável para diferentes canais (`channels.type`).\n    *   Suporte a templates, variáveis, e conteúdo dinâmico (potencialmente gerado por LLM em um passo anterior).\n*   **`action:delay.handler.ts`**:\n    *   Aguardar por um período (minutos, horas, dias).\n    *   Aguardar até uma data/hora específica.\n    *   Aguardar até um dia específico da semana/mês.\n*   **`action:llm_prompt.handler.ts`**:\n    *   Seleciona a `connection` do LLM (Gemini, Anthropic, etc.).\n    *   Envia um prompt (que pode conter variáveis do workflow).\n    *   Processa a resposta e a disponibiliza como output do nó.\n    *   Casos de uso: análise de sentimento, extração de entidade, classificação, geração de texto, sumarização, tradução.\n*   **`logic:if_else.handler.ts` (ou `logic:condition_branch.handler.ts`)**:\n    *   Avalia uma ou mais condições.\n    *   Direciona o fluxo para diferentes \"edges\" de saída com base no resultado.\n*   **`action:update_contact_or_lead.handler.ts`**:\n    *   Adicionar/remover tags.\n    *   Atualizar campos customizados (ex: `contact.custom_fields.funnel_stage = 'engaged'`).\n    *   Mudar status do lead.\n*   **`action:http_request.handler.ts`**:\n    *   Para integrar com qualquer API externa (CRMs, planilhas, ferramentas de marketing).\n*   **`action:assign.handler.ts`**:\n    *   Atribuir uma conversa (da tabela `conversations`) a um agente/time.\n    *   Atribuir um lead (da tabela `leads`) a um agente.\n*   **`action:wait_for_reply.handler.ts` (Avançado):**\n    *   Pausa o workflow e espera por uma resposta do contato no mesmo canal/conversa.\n    *   Precisa de um timeout e um caminho de \"não respondeu\".\n    *   Requer que a execução do workflow possa ser \"pausada\" e \"retomada\".\n\n**5. Interação entre Workflows e a Camada Omnichannel:**\n\n*   **Envio de Mensagens:** O nó `action:send_message` usará os `messages.services.ts` para abstrair a complexidade de cada canal.\n*   **Recebimento de Mensagens como Trigger:** O `webhooks/[channel].ts` (ex: `whatsapp.ts`) pode, além de salvar a mensagem e criar/atualizar o contato/conversa, verificar se há workflows ativos que devem ser disparados por essa mensagem (ex: com base no canal, palavras-chave, ou até mesmo uma rápida chamada LLM para intenção).\n*   **Atualização de Contatos/Leads:** Os nós de workflow interagem diretamente com as tabelas `contacts` e `leads`.\n\n**6. Segmentação com LLMs:**\n\n*   Um nó `action:llm_prompt` pode receber dados do lead/contato (ex: histórico de mensagens, descrição do interesse, dados de formulário) e o prompt pediria ao LLM para:\n    *   \"Classifique este lead nos segmentos: A, B, C com base no seu interesse e urgência.\"\n    *   \"Gere 3 tags que melhor descrevem este lead.\"\n    *   \"Com base nesta conversa, qual o próximo melhor produto a oferecer?\"\n*   A saída do LLM (segmentos, tags, sugestões) pode então ser usada para:\n    *   Atualizar o contato/lead.\n    *   Ramificar o workflow.\n    *   Personalizar a próxima mensagem.\n\n**Estrutura da API Hono (Módulos Chave):**\n\nA estrutura modular anterior ainda se aplica. O `workflow_engine` e os `node_handlers` são onde a mágica acontece.\n\n**Considerações Específicas:**\n\n*   **Agendamento de Envios:**\n    *   **Delay Simples:** O nó `action:delay` cobre isso.\n    *   **Data/Hora Específica:** Um nó `action:schedule_at` ou uma configuração no `action:delay`. O `workflow_engine` precisaria de um mecanismo para \"acordar\" execuções pausadas no momento certo. Isso pode ser feito com um sistema de jobs/scheduler (como `pg_cron` no Supabase, ou BullMQ com Redis se rodar um servidor Node.js persistente). A execução do workflow ficaria no estado `waiting` com um `resume_at` timestamp.\n*   **\"Aquecimento\" de Leads:** Sequências de mensagens com delays, conteúdo educativo, e talvez alguma interação leve via LLM para qualificação.\n*   **Follow-up:** Agendamentos e condições (ex: \"se não respondeu em X dias, enviar follow-up Y\").\n*   **Regras:** Implementadas através dos nós de condição (`logic:if_else`) e da lógica nos triggers.\n\n**Desafios:**\n\n*   **Gerenciamento de Estado do Workflow:** Especialmente para delays longos ou esperas por ação do usuário. Onde e como o estado da execução é persistido e retomado de forma eficiente.\n*   **UI do Flow Builder:** Construir um frontend intuitivo para montar esses workflows complexos é um projeto à parte.\n*   **Escalabilidade do Workflow Engine:** Se muitos workflows estiverem rodando, especialmente com muitos delays ou chamadas a LLMs, a infraestrutura precisa ser robusta. Execução assíncrona de nós e talvez workers dedicados podem ser necessários.\n\nEste é um projeto ambicioso e incrivelmente poderoso! Ao combinar a base omnichannel com um motor de workflow flexível e a inteligência dos LLMs, você pode criar automações de funil muito sofisticadas. A chave é começar com os tipos de nós mais importantes e expandir a partir daí, mantendo o design modular.",
      ],
    },
    {
      role: "user",
      parts: [
        "a ideia tambem é que todas as analises que as LMMS fizer ser armazenada no pgvetor, para consumirmos isso cada vez mais na qual a nossa tabela vai populando",
      ],
    },
    {
      role: "model",
      parts: [
        "Excelente ideia! Integrar `pgvector` para armazenar e consultar os embeddings gerados a partir das análises dos LLMs abre um leque enorme de possibilidades para enriquecer suas automações, segmentações e a inteligência geral da plataforma.\n\nIsso transforma os resultados das LLMs de simples saídas textuais em ativos semânticos que podem ser comparados, clusterizados e usados para encontrar similaridades.\n\nVamos refinar o design para incorporar o `pgvector` de forma eficaz.\n\n**Princípios para Integração com `pgvector`:**\n\n1.  **Onde Armazenar Embeddings:** Decidir quais entidades se beneficiarão mais de terem embeddings associados.\n2.  **Quando Gerar Embeddings:** Definir os momentos em que os embeddings serão calculados (ex: após uma análise de LLM, ao receber uma mensagem, ao criar um lead).\n3.  **Como Usar os Embeddings:** Quais tipos de consultas de similaridade serão úteis para seus workflows e funcionalidades.\n\n**Atualizações no Schema do Banco de Dados com `pgvector`:**\n\nPrimeiro, certifique-se de que a extensão `vector` está habilitada no seu Supabase (você já mencionou isso no schema do Chatwoot, então provavelmente já está ciente).\n\n```sql\nCREATE EXTENSION IF NOT EXISTS vector;\n```\n\nAgora, vamos identificar tabelas onde os embeddings fariam sentido e como adicioná-los:\n\n1.  **`contacts` (ou uma tabela associada `contact_profiles_data`):**\n    *   **Propósito:** Entender o perfil semântico de um contato com base em suas interações, descrições, etc.\n    *   **Campos:**\n        ```sql\n        -- Na tabela contacts ou em uma tabela de perfil estendida\n        ALTER TABLE contacts ADD COLUMN profile_summary_embedding VECTOR(1536); -- Ajuste a dimensão para o seu modelo de embedding (e.g., text-embedding-ada-002 da OpenAI é 1536, modelos Gemini podem variar)\n        ALTER TABLE contacts ADD COLUMN last_profile_embedding_updated_at TIMESTAMPTZ;\n        -- Index para busca por similaridade\n        CREATE INDEX ON contacts USING ivfflat (profile_summary_embedding vector_cosine_ops) WITH (lists = 100); -- Ou HNSW dependendo da versão do pgvector e necessidades\n        ```\n    *   **Conteúdo para Embedding:** Poderia ser um resumo de todas as interações do contato, o texto de \"sobre\" fornecido por ele, ou um resumo gerado por um LLM sobre o contato.\n\n2.  **`messages`:**\n    *   **Propósito:** Permitir a busca por mensagens semanticamente similares, identificar intenções recorrentes, ou encontrar mensagens relacionadas a um tópico específico, mesmo que usem palavras diferentes.\n    *   **Campos:**\n        ```sql\n        ALTER TABLE messages ADD COLUMN content_embedding VECTOR(1536);\n        -- Index\n        CREATE INDEX ON messages USING ivfflat (content_embedding vector_cosine_ops) WITH (lists = 100);\n        ```\n    *   **Conteúdo para Embedding:** O `text_content` da mensagem (após alguma limpeza, se necessário).\n\n3.  **`leads`:**\n    *   **Propósito:** Encontrar leads similares, ou classificar leads com base na similaridade com perfis de \"lead ideal\".\n    *   **Campos:**\n        ```sql\n        ALTER TABLE leads ADD COLUMN description_embedding VECTOR(1536);\n        -- Index\n        CREATE INDEX ON leads USING ivfflat (description_embedding vector_cosine_ops) WITH (lists = 100);\n        ```\n    *   **Conteúdo para Embedding:** A descrição do lead, notas sobre o lead, ou uma combinação de campos textuais relevantes.\n\n4.  **`ai_interactions_log` (Onde as análises LLM são armazenadas):**\n    *   Esta tabela já armazena `prompt_text` e `response_text`. Se a *resposta* do LLM for um texto rico que você queira comparar semanticamente (ex: um resumo gerado, uma classificação textual), você pode adicionar um embedding para ele.\n    *   **Campos:**\n        ```sql\n        ALTER TABLE ai_interactions_log ADD COLUMN response_text_embedding VECTOR(1536);\n        -- Index\n        CREATE INDEX ON ai_interactions_log USING ivfflat (response_text_embedding vector_cosine_ops) WITH (lists = 100);\n        ```\n\n5.  **Nova Tabela: `knowledge_base_chunks` (Para RAG - Retrieval Augmented Generation):**\n    *   Se você planeja que seus LLMs consultem uma base de conhecimento interna (documentos de produtos, FAQs, políticas da empresa) para gerar respostas mais precisas, você precisará de uma tabela para esses \"chunks\" de conhecimento.\n    *   **Campos:**\n        ```sql\n        CREATE TABLE knowledge_base_chunks (\n            id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n            organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,\n            source_document_id TEXT, -- ID do documento original (e.g., nome do arquivo, URL da FAQ)\n            content_chunk TEXT NOT NULL,\n            chunk_embedding VECTOR(1536) NOT NULL,\n            metadata JSONB, -- e.g., título do documento, seção, tags\n            created_at TIMESTAMPTZ DEFAULT NOW(),\n            updated_at TIMESTAMPTZ DEFAULT NOW()\n        );\n        -- Index\n        CREATE INDEX ON knowledge_base_chunks USING ivfflat (chunk_embedding vector_cosine_ops) WITH (lists = 100);\n        -- Index: organization_id, source_document_id\n        ```\n\n**Fluxo de Trabalho com LLMs e `pgvector`:**\n\n1.  **Análise LLM Inicial:**\n    *   Um nó no workflow (`action:llm_prompt`) recebe um texto (ex: descrição de um lead, mensagem de um cliente).\n    *   O prompt instrui o LLM a realizar uma tarefa (ex: \"Classifique este lead. Extraia seus principais interesses. Gere um resumo de uma frase sobre o lead.\").\n    *   A resposta do LLM (ex: `{ \"classification\": \"hot\", \"interests\": [\"AI\", \"SaaS\"], \"summary\": \"Lead interessado em soluções AI para SaaS.\" }`) é armazenada na variável de output do nó.\n\n2.  **Geração e Armazenamento de Embeddings:**\n    *   **Opção A: Nó de Workflow Dedicado para Embedding:**\n        *   Um novo tipo de nó: `action:generate_embedding`.\n        *   Input: Texto a ser \"embeddado\" (ex: `{{llm_node_output.summary}}` ou `{{trigger_data.message_text}}`).\n        *   Input: Referência à `connection` de um serviço de embedding (OpenAI, Gemini, Cohere, ou um modelo self-hosted).\n        *   Ação: Chama o serviço de embedding.\n        *   Output: O vetor de embedding.\n    *   **Opção B: Embedding como parte de outro nó:**\n        *   O nó `action:update_contact_or_lead` ou um nó `action:log_message_analysis` poderia ter uma flag \"gerar e salvar embedding\".\n    *   **Armazenamento:** Após gerar o embedding, o workflow (ou o serviço que o workflow chama) atualiza a tabela relevante (`contacts`, `messages`, `leads`) com o vetor de embedding.\n\n3.  **Consumo dos Embeddings (Consultas de Similaridade):**\n    *   **Novos Tipos de Nós de Workflow:**\n        *   `action:find_similar_contacts`:\n            *   Input: `contact_id` (para pegar seu `profile_summary_embedding`) ou um texto para gerar um embedding de consulta \"on-the-fly\".\n            *   Input: `limit` (quantos similares retornar).\n            *   Ação: Faz uma consulta `pgvector` na tabela `contacts` (`ORDER BY profile_summary_embedding <-> query_embedding LIMIT N`).\n            *   Output: Lista de `contact_id`s similares e suas distâncias/similaridades.\n        *   `action:find_similar_messages`: Similar, mas na tabela `messages`.\n        *   `action:find_relevant_knowledge`:\n            *   Input: Pergunta do usuário ou tópico de interesse (texto).\n            *   Ação: Gera um embedding para o input, consulta `knowledge_base_chunks` por similaridade.\n            *   Output: Os `content_chunk`s mais relevantes.\n    *   **Em Triggers:**\n        *   Um trigger `message_received` poderia, *após* gerar o embedding da nova mensagem, buscar por mensagens anteriores *do mesmo contato* que são semanticamente similares para fornecer contexto a um agente ou a um LLM de resposta.\n    *   **Em Nós LLM (RAG):**\n        *   Um nó `action:llm_prompt_with_rag`:\n            1.  Recebe a pergunta original do usuário/lead.\n            2.  Usa um nó interno (ou lógica) `action:find_relevant_knowledge` para buscar chunks relevantes da `knowledge_base_chunks`.\n            3.  Constrói um novo prompt para o LLM que inclui a pergunta original *e* os chunks de conhecimento encontrados. Ex: \"Com base no seguinte contexto de nossa base de conhecimento: [chunks aqui]. Responda à seguinte pergunta do usuário: [pergunta aqui]\".\n            4.  Chama o LLM.\n\n**Exemplo de Workflow com `pgvector` para Qualificação de Lead:**\n\n1.  **Trigger:** Novo lead de formulário (`trigger:webhook`). Contém `lead_data.description_text`.\n2.  **Nó 1 (`action:generate_embedding`):**\n    *   Input: `{{trigger.outputs.lead_data.description_text}}`.\n    *   Gera `lead_description_embedding`.\n3.  **Nó 2 (`action:update_lead`):**\n    *   Salva o `lead_description_embedding` no registro do lead.\n4.  **Nó 3 (`action:find_similar_leads`):**\n    *   Input: `lead_description_embedding` do lead atual.\n    *   Consulta a tabela `leads` por outros leads com `description_embedding` similar.\n    *   Output: `similar_leads_list`.\n5.  **Nó 4 (`action:llm_prompt_analyze_similarity`):**\n    *   Input: Descrição do lead atual, descrições dos `similar_leads_list` (os top N).\n    *   Prompt: \"O lead atual X é similar aos leads Y, Z que foram classificados como 'Hot'. O lead X também parece ser 'Hot'? Justifique.\"\n    *   Output: `llm_analysis_json` (ex: `{ \"is_hot_candidate\": true, \"reason\": \"Similar a outros leads convertidos...\" }`).\n6.  **Nó 5 (`logic:if_else`):**\n    *   Condição: `{{llm_analysis_json.is_hot_candidate == true}}`.\n    *   Caminho \"Sim\": Nó `action:tag_lead` (tag \"AI Qualified Hot\"), Nó `action:assign_to_senior_agent`.\n    *   Caminho \"Não\": Nó `action:add_to_nurturing_sequence`.\n\n**Estrutura da API Hono:**\n\n*   **`api/v1/modules/embeddings/` (Opcional, mas pode ser útil):**\n    *   `embeddings.routes.ts`:\n        *   `POST /embeddings/generate`: Um endpoint genérico para gerar um embedding para um dado texto (usado internamente pelos workflows ou para testes).\n    *   `embeddings.services.ts`:\n        *   Lógica para interagir com os diferentes provedores de modelos de embedding (OpenAI, Gemini, etc.) usando as `connections` configuradas.\n*   **Serviços Existentes (`leads.services.ts`, `contacts.services.ts`, etc.):**\n    *   Precisarão de métodos para atualizar os campos de embedding.\n    *   Precisarão de métodos para realizar buscas por similaridade usando `pgvector` (ex: `findSimilarLeads(embedding, limit)`).\n*   **`workflow_engine/node_handlers/`:**\n    *   Novos handlers como `generate_embedding.handler.ts`, `find_similar.handler.ts`.\n    *   Handlers existentes (como `llm_prompt.handler.ts`) podem ser estendidos para RAG.\n\n**Considerações de Implementação:**\n\n*   **Escolha do Modelo de Embedding:** A dimensão do vetor (`VECTOR(1536)`) depende do modelo. Certifique-se de que é consistente.\n*   **Custo:** Gerar embeddings e fazer chamadas LLM tem custo. Planeje o uso.\n*   **Performance de `pgvector`:** Para grandes volumes de dados, a escolha do tipo de índice (`ivfflat` vs `hnsw`) e seus parâmetros (`lists`, `m`, `ef_construction`) é crucial. HNSW geralmente oferece melhor trade-off de recall/velocidade para muitos casos de uso, mas requer versões mais recentes do `pgvector`.\n*   **Atualização de Embeddings:** Se o texto fonte de um embedding mudar (ex: descrição do lead é editada), o embedding precisa ser recalculado e atualizado.\n*   **Batching:** Para popular embeddings em dados existentes ou para processar muitos itens, use operações em lote.\n\nIntegrar `pgvector` desta forma adiciona uma camada de \"inteligência semântica\" profunda à sua plataforma. Isso permite que seus workflows e análises vão além de correspondências de palavras-chave e entendam o *significado* por trás dos dados, o que é fundamental para as automações avançadas de funil e segmentação que você descreveu.",
      ],
    },
    {
      role: "user",
      parts: [
        "documente tudo agora e crie os principais codigos para nosso projeto",
      ],
    },
    {
      role: "model",
      parts: [
        "**Outlining API Architecture**\n\nI've started by deeply understanding the core request: crafting thorough documentation and foundational code for a Hono-based omnichannel API. The initial focus is on outlining the API architecture, pinpointing key features, and defining the core functionalities it should encompass. My goal is to create a solid framework.\n\n\n**Mapping Out Core Features**\n\nI'm now zeroing in on detailing the API's core features. This involves mapping out lead funnels, LLM integration, and semantic search. The tech stack, including Hono, Supabase, and workflow automation, is being fleshed out. The initial focus is on the  `connections`, `workflows`, and `workflow_executions` tables. I am prioritising core code generation, since generating all of it is impossible!\n\n\n**Prioritizing Code Generation**\n\nI'm now zeroing in on code generation priorities. I will create Hono boilerplate, Supabase setup, and JWT authentication middleware. I'll craft a `Channels` module as a CRUD example and develop foundational `workflows.routes.ts`, `workflows.services.ts`, and a high-level `workflow_engine/executor.ts`. I will conceptualize services for AI and embeddings, and demonstrate Supabase Vault and webhook integration.\n\n\n**Finalizing Documentation Structure**\n\nI've decided to finalize the documentation structure, ensuring a solid foundation for the project. I've broken it into standard project sections: an overview, core features, and tech stack. Crucially, I'm focusing on key sections like the database schema, API endpoint design, and the conceptual workflow engine. The goal is to provide a clear and accessible roadmap.\n\n\n**Finalizing the Code Strategy**\n\nI've clarified the code generation strategy. I'll focus on foundational elements: Hono/Supabase boilerplate, JWT authentication, and a CRUD `Channels` module. For `workflows`, I'll provide `routes.ts`, `services.ts`, and a high-level executor skeleton. I'll also demonstrate Supabase Vault and robust webhook handling. I've re-reviewed the database schema to make sure it is updated.\n\n\n**Finalizing the Code Strategy**\n\nI've clarified the code generation strategy. I'll focus on foundational elements: Hono/Supabase boilerplate, JWT authentication, and a CRUD `Channels` module. For `workflows`, I'll provide `routes.ts`, `services.ts`, and a high-level executor skeleton. I'll also demonstrate Supabase Vault and robust webhook handling. I've re-reviewed the database schema to make sure it is updated.\n\n\n**Defining the Code Structure**\n\nI've made the decision to define the code structure, mapping out the architecture. I'm prioritizing the core Hono application setup, Supabase client initialization, and essential API modules. The goal is to provide a solid foundation for more complex features to be added later. I've also re-reviewed the database schema to make sure it is updated.\n\n\n",
        "Okay, este é um grande passo! Vamos consolidar tudo em uma estrutura de documentação e gerar os códigos principais para dar o pontapé inicial no seu projeto.\n\n**Aviso:** Este será um conjunto **fundamental** de códigos. Um sistema completo como o que você descreveu é um empreendimento considerável. O código fornecido servirá como base e demonstração dos conceitos discutidos.\n\n---\n\n**DOCUMENTAÇÃO DO PROJETO (README.md - Esqueleto)**\n\n```markdown\n# Omnichannel API com Workflows e IA (Hono + Supabase)\n\n## Visão Geral\n\nUma API REST omnichannel robusta e extensível construída com Hono e Supabase. Projetada para gerenciar comunicações em múltiplos canais (WhatsApp, Telegram, etc.), leads, contatos, e potencializada por um motor de workflow para automações de funil, com integração nativa a LLMs e busca semântica via pgvector.\n\n## Funcionalidades Principais (Core Features)\n\n*   **Gerenciamento Omnichannel:**\n    *   Conexão e gerenciamento de canais (WhatsApp, Telegram, Instagram, Web Chat).\n    *   Envio e recebimento unificado de mensagens.\n*   **Gestão de Contatos e Leads (CRM Leve):**\n    *   Criação, atualização e segmentação de contatos e leads.\n*   **Motor de Workflow de Automação:**\n    *   Construtor de fluxos (conceitual, backend suporta a definição JSON).\n    *   Triggers (webhooks, eventos de sistema, agendamentos).\n    *   Ações (enviar mensagem, atualizar CRM, chamar LLM, requisições HTTP, delays, condições).\n    *   Foco em automação de funis de marketing/vendas.\n*   **Integração com LLMs (Grandes Modelos de Linguagem):**\n    *   Análise de sentimento/intenção.\n    *   Geração de respostas e conteúdo.\n    *   Extração de informações e classificação.\n    *   Sumarização.\n*   **Busca Semântica com pgvector:**\n    *   Armazenamento de embeddings de textos (mensagens, descrições de leads, conhecimento).\n    *   Consultas de similaridade para RAG (Retrieval Augmented Generation), encontrar contatos/leads similares, etc.\n*   **Live Chat:**\n    *   Interface para agentes atenderem conversas em tempo real.\n    *   Atribuição de conversas, status, notas internas.\n*   **Analytics Proprietário:**\n    *   Endpoint de tracking de eventos.\n*   **Outros:**\n    *   Gerenciador de Projetos (básico).\n    *   Cache de Conteúdo (ex: WP-Headless).\n\n## Stack Tecnológica\n\n*   **Backend API:** Hono (executando em Node.js ou Deno, ou como Supabase Edge Function)\n*   **Banco de Dados:** Supabase (PostgreSQL)\n    *   **Auth:** Supabase Auth (JWT)\n    *   **Storage:** Supabase Storage (para anexos)\n    *   **Vector Database:** pgvector (extensão PostgreSQL)\n    *   **Secrets Management:** Supabase Vault\n*   **Validação:** Zod\n*   **Linguagem:** TypeScript\n\n## Estrutura do Projeto\n\n(Será detalhada abaixo com o código)\n\n## Esquema do Banco de Dados (Principais Tabelas e Conceitos)\n\n*   **`organizations`**: Para multi-tenancy.\n*   **`user_profiles`**: Estende `auth.users` com dados da aplicação.\n*   **`channels`**: Configuração dos canais de comunicação (WhatsApp, Telegram, etc.).\n    *   `type` (enum), `config_jsonb`, `credentials_vault_path_jsonb` (caminhos para segredos no Supabase Vault).\n*   **`contacts`**: Informações dos clientes/usuários finais.\n    *   `profile_summary_embedding VECTOR(DIMENSION)`: Para busca semântica.\n*   **`contact_identifiers`**: Mapeia contatos para seus IDs nas diferentes plataformas.\n*   **`messages`**: Todas as mensagens omnichannel.\n    *   `content_embedding VECTOR(DIMENSION)`: Para busca semântica.\n    *   `sender_type`, `sender_id`: Para identificar remetente (User, Contact, Automation).\n*   **`message_attachments`**: Anexos das mensagens (referenciando Supabase Storage).\n*   **`conversations`**: Agrupa mensagens para live chat e acompanhamento.\n*   **`leads`**: Gerenciamento de leads.\n    *   `description_embedding VECTOR(DIMENSION)`: Para busca semântica.\n*   **`connections`**: Credenciais autenticadas para serviços externos usados em workflows (LLMs, CRMs, etc.).\n    *   `service_type`, `metadata`, `vault_secret_references_jsonb`.\n*   **`workflows`**: Definições dos fluxos de automação.\n    *   `definition JSONB` (estrutura com nós, edges, variáveis).\n    *   `trigger_type`, `trigger_config`.\n    *   `published_version_id` (opcional, para versionamento).\n*   **`workflow_versions`**: Histórico de versões de workflows.\n*   **`workflow_executions`**: Registros de cada execução de um workflow.\n    *   `status`, `trigger_event_data`, `execution_data` (estado/resultados).\n*   **`workflow_execution_step_logs`**: Logs detalhados de cada nó executado.\n*   **`ai_interactions_log`**: Log de todas as chamadas a LLMs.\n    *   `response_text_embedding VECTOR(DIMENSION)`.\n*   **`knowledge_base_chunks`**: Pedaços de texto e seus embeddings para RAG.\n    *   `content_chunk`, `chunk_embedding VECTOR(DIMENSION)`.\n*   **`event_subscriptions`**: Webhooks de SAÍDA que a plataforma envia.\n*   **Outras:** `tracked_events`, `projects`, `tasks`.\n\n*(Lembre-se de ajustar `DIMENSION` para o tamanho do vetor do seu modelo de embedding, ex: 1536 para text-embedding-ada-002).*\n\n## Design da API (Principais Endpoints por Módulo)\n\n*   `/api/v1/organizations` (CRUD)\n*   `/api/v1/channels` (CRUD)\n*   `/api/v1/contacts` (CRUD, busca)\n*   `/api/v1/conversations` (CRUD, atribuir, status, mensagens)\n*   `/api/v1/messages` (POST para enviar)\n*   `/api/v1/leads` (CRUD)\n*   `/api/v1/connections` (CRUD, handlers OAuth)\n*   `/api/v1/workflows` (CRUD para definições)\n*   `/api/v1/workflows/{id}/execute` (para disparar manualmente)\n*   `/api/v1/workflow-executions` (Listar, GET por ID com logs)\n*   `/api/v1/ai/prompt` (para chamadas diretas a LLMs)\n*   `/api/v1/embeddings/generate` (para gerar embeddings)\n*   `/api/v1/embeddings/search/contacts` (exemplo de busca semântica)\n*   `/api/v1/knowledge-base` (CRUD para chunks de conhecimento)\n*   `/api/v1/track/event` (para o tracker.js)\n\n## Autenticação e Autorização\n\n*   **Autenticação:** JWT Bearer Tokens emitidos pelo Supabase Auth.\n*   **Autorização:**\n    *   Middleware Hono para verificar JWT e extrair `user_id` e `organization_id` (via custom claims no JWT).\n    *   RLS (Row Level Security) no Supabase para garantir que os usuários só acessem dados de suas organizações.\n    *   RBAC (Role-Based Access Control) pode ser implementado na camada da API para permissões mais granulares (admin, agent).\n\n## Webhooks\n\n*   **Entrada (Inbound):**\n    *   `/webhooks/whatsapp`\n    *   `/webhooks/telegram`\n    *   `/webhooks/instagram`\n    *   `/webhooks/workflow/{workflow_path}` (para disparar workflows)\n    *   Verificação de assinatura é crucial.\n*   **Saída (Outbound):**\n    *   Configurados via `/api/v1/event-subscriptions`.\n    *   Disparados por eventos internos do sistema.\n\n## Motor de Workflow (Workflow Engine) - Conceitual\n\n*   Localizado em `src/workflow_engine/`.\n*   **`executor.ts`**: Interpreta a `workflows.definition` JSON.\n*   **`node_handlers/`**: Lógica para cada tipo de nó (enviar mensagem, chamar LLM, delay, condição, HTTP request, etc.).\n*   **`trigger_manager.ts`**: Lida com o disparo de workflows (agendamentos, escuta de eventos).\n*   Usa as `connections` para autenticar com serviços externos.\n*   Registra execuções e logs nas tabelas `workflow_executions` e `workflow_execution_step_logs`.\n\n## Integração LLM & pgvector\n\n1.  **Análise LLM:** Nós de workflow ou endpoints diretos chamam serviços de LLM (via `src/services/ai_providers/[provider].service.ts`).\n2.  **Geração de Embedding:** O texto relevante (mensagens, descrições, respostas de LLM) é enviado para um serviço de embedding (via `src/services/embedding.service.ts`).\n3.  **Armazenamento:** O vetor resultante é salvo no campo `VECTOR` apropriado nas tabelas do Supabase.\n4.  **Busca Semântica:**\n    *   Nós de workflow ou endpoints de API podem gerar um embedding para uma consulta.\n    *   Este embedding é usado em uma consulta `pgvector` (operador `<->` para distância de cosseno) para encontrar itens semanticamente similares.\n    *   Usado para RAG, encontrar leads/contatos similares, recomendar conteúdo, etc.\n\n## Setup e Execução\n\n1.  **Clone o repositório.**\n2.  **Crie um projeto Supabase.**\n    *   Habilite as extensões `uuid-ossp`, `vector`.\n    *   Configure o Supabase Auth.\n    *   Configure o Supabase Vault para armazenar segredos das `connections`.\n    *   Aplique as migrações do banco de dados (SQL do schema).\n3.  **Configure as variáveis de ambiente (`.env`):**\n    ```env\n    SUPABASE_URL=your_supabase_url\n    SUPABASE_ANON_KEY=your_supabase_anon_key\n    SUPABASE_SERVICE_ROLE_KEY=your_supabase_service_role_key\n    SUPABASE_JWT_SECRET=your_supabase_jwt_secret\n    # SUPABASE_VAULT_URL (se aplicável, ou use SDK do Supabase para acessar o Vault)\n\n    # Dimensão do vetor para seu modelo de embedding\n    EMBEDDING_DIMENSION=1536\n\n    # API Keys para LLMs e outros serviços (idealmente, referências para o Vault)\n    OPENAI_API_KEY_VAULT_ID=...\n    GEMINI_API_KEY_VAULT_ID=...\n\n    PORT=3000\n    ```\n4.  **Instale as dependências:** `npm install` ou `yarn install`.\n5.  **Execute a API:** `npm run dev` ou `yarn dev`.\n\n## Roadmap / Melhorias Futuras\n\n*   UI completa para o Flow Builder.\n*   Dashboard de Agente para Live Chat.\n*   Analytics e relatórios detalhados.\n*   Mais tipos de nós de workflow.\n*   Testes unitários e de integração abrangentes.\n*   Otimizações de performance para `pgvector` e `workflow_engine`.\n*   Suporte a mais canais.\n\n## Contribuições\n\n(Instruções para contribuir)\n\n## Licença\n\n(Ex: MIT)\n```\n\n---\n\n**CÓDIGOS PRINCIPAIS (Estrutura de Pastas e Arquivos Fundamentais)**\n\n**1. Estrutura de Pastas (Revisada e Expandida):**\n\n```\n/src\n  ├── index.ts            # Entry point principal da aplicação Hono\n  |\n  ├── api/\n  │   └── v1/\n  │       ├── index.ts        # Router principal da v1\n  │       ├── middleware/\n  │       │   ├── auth.ts\n  │       │   ├── validation.ts\n  │       │   └── rbac.ts\n  │       └── modules/\n  │           ├── channels/\n  │           │   ├── channels.routes.ts\n  │           │   ├── channels.services.ts\n  │           │   └── channels.validators.ts\n  │           ├── contacts/    # (similar structure)\n  │           ├── conversations/ # (similar structure)\n  │           ├── messages/    # (similar structure)\n  │           ├── leads/       # (similar structure)\n  │           ├── connections/\n  │           │   ├── connections.routes.ts\n  │           │   ├── connections.services.ts # Lida com Supabase Vault\n  │           │   └── connections.validators.ts\n  │           ├── workflows/\n  │           │   ├── workflows.routes.ts\n  │           │   ├── workflows.services.ts\n  │           │   └── workflows.validators.ts\n  │           ├── workflow_executions/ # (similar structure)\n  │           ├── ai/\n  │           │   ├── ai.routes.ts\n  │           │   └── ai.validators.ts\n  │           ├── embeddings/\n  │           │   ├── embeddings.routes.ts\n  │           │   └── embeddings.validators.ts\n  │           └── knowledge_base/ # (similar structure)\n  │\n  ├── webhooks/\n  │   ├── index.ts\n  │   ├── middleware/\n  │   │   └── signatureVerifier.ts # Genérico, adaptável\n  │   ├── whatsapp.webhook.ts\n  │   ├── telegram.webhook.ts\n  │   └── workflow_trigger.webhook.ts\n  │\n  ├── core/\n  │   ├── supabase.ts\n  │   ├── logger.ts\n  │   ├── errors.ts\n  │   └── vault.service.ts      # Serviço para interagir com Supabase Vault\n  │\n  ├── services/                 # Camada de serviço para integrações com terceiros e lógica complexa\n  │   ├── channels/             # Lógica específica por tipo de canal\n  │   │   ├── whatsapp.channel.service.ts\n  │   │   └── telegram.channel.service.ts\n  │   ├── ai_providers/         # Lógica para diferentes LLMs\n  │   │   ├── gemini.service.ts\n  │   │   └── openai.service.ts\n  │   ├── embedding.service.ts  # Lógica para gerar embeddings e consultar pgvector\n  │   └── oauth.service.ts      # Helpers para fluxos OAuth2 (para connections)\n  │\n  ├── workflow_engine/\n  │   ├── index.ts\n  │   ├── executor.ts\n  │   ├── trigger_manager.ts\n  │   └── node_handlers/\n  │       ├── send_message.handler.ts\n  │       ├── llm_prompt.handler.ts\n  │       ├── delay.handler.ts\n  │       ├── condition.handler.ts\n  │       ├── http_request.handler.ts\n  │       └── generate_embedding.handler.ts # Novo\n  │       └── find_similar.handler.ts     # Novo\n  │\n  ├── types/\n  │   ├── index.ts              # HonoEnv, tipos de dados globais\n  │   ├── channel.types.ts\n  │   ├── workflow.types.ts\n  │   └── ...\n  │\n  ├── config/\n  │   └── index.ts              # Carrega e exporta env vars\n  │\n  └── db/                       # Migrações SQL, seeds\n      └── schema.sql            # SQL completo do schema (você geraria este)\n      └── migrations/\n```\n\n**2. Código de Exemplo (Arquivos Chave):**\n\n**`src/config/index.ts`**\n```typescript\nimport 'dotenv/config';\n\nconst requireEnv = (key: string): string => {\n  const value = process.env[key];\n  if (value === undefined) {\n    throw new Error(`Missing environment variable: ${key}`);\n  }\n  return value;\n};\n\nexport const config = {\n  port: parseInt(process.env.PORT || '3000', 10),\n  supabaseUrl: requireEnv('SUPABASE_URL'),\n  supabaseAnonKey: requireEnv('SUPABASE_ANON_KEY'),\n  supabaseServiceRoleKey: requireEnv('SUPABASE_SERVICE_ROLE_KEY'),\n  supabaseJwtSecret: requireEnv('SUPABASE_JWT_SECRET'),\n  embeddingDimension: parseInt(requireEnv('EMBEDDING_DIMENSION'), 10),\n  // Add other config values as needed\n};\n```\n\n**`src/core/supabase.ts`**\n```typescript\nimport { createClient, SupabaseClient } from '@supabase/supabase-js';\nimport { config } from '@/config';\n\n// Client for general use, respects RLS if user JWT is provided\nexport const supabase = createClient(config.supabaseUrl, config.supabaseAnonKey);\n\n// Admin client, bypasses RLS. Use with extreme caution.\nexport const supabaseAdmin = createClient(config.supabaseUrl, config.supabaseServiceRoleKey, {\n  auth: {\n    autoRefreshToken: false,\n    persistSession: false,\n  }\n});\n\nexport const getSupabaseClientForUser = (jwt: string): SupabaseClient => {\n  return createClient(config.supabaseUrl, config.supabaseAnonKey, {\n    global: {\n      headers: { Authorization: `Bearer ${jwt}` },\n    },\n  });\n};\n\n// pgvector helper function (example)\nexport async function findSimilarVectors(\n  client: SupabaseClient,\n  tableName: string,\n  embeddingColumn: string,\n  queryEmbedding: number[],\n  matchThreshold: number = 0.7, // Adjust as needed\n  matchCount: number = 5\n) {\n  // Note: Supabase RPC might be more direct for this if complex\n  // This is a simplified direct query example, ensure your RLS allows it or use supabaseAdmin\n  const { data, error } = await client\n    .from(tableName)\n    .select(`*, ${embeddingColumn} <-> '${JSON.stringify(queryEmbedding)}' as similarity_score`)\n    // .gt(`(${embeddingColumn} <-> '${JSON.stringify(queryEmbedding)}')`, -matchThreshold) // Cosine distance is 1 - similarity. So distance < (1-similarity_threshold)\n    // Or use a direct RPC call for more control:\n    // .rpc('match_documents', { // Assuming you created an RPC function\n    //   query_embedding: queryEmbedding,\n    //   match_threshold: matchThreshold,\n    //   match_count: matchCount\n    // })\n    .order(`similarity_score`, { ascending: true }) // Lower distance is more similar\n    .limit(matchCount);\n\n  if (error) {\n    console.error(`Error finding similar vectors in ${tableName}:`, error);\n    throw error;\n  }\n  return data;\n}\n\nconsole.log('Supabase client initialized.');\n```\n\n**`src/core/vault.service.ts` (Conceitual - Supabase Vault SDK é preferível)**\n```typescript\nimport { supabaseAdmin } from './supabase'; // Admin client needed for direct Vault access if not using Vault SDK with user context\n\n// ESTA É UMA ABSTRAÇÃO. O SUPABASE AINDA NÃO TEM UM SDK JS DEDICADO AO VAULT.\n// VOCÊ PRECISARIA CHAMAR AS APIs HTTP DO VAULT DIRETAMENTE OU USAR UMA FUNÇÃO EDGE.\n// A MELHOR ABORDAGEM FUTURA SERÁ USAR UM SDK OFICIAL QUANDO DISPONÍVEL.\n// Alternativamente, funções Edge do Supabase podem acessar segredos do Vault.\n\n/**\n * Placeholder para buscar um segredo do Supabase Vault.\n * Em um cenário real, isso chamaria a API do Supabase Vault ou usaria um SDK.\n * @param secretPath - O caminho/ID do segredo no Vault (ex: 'openai-api-key')\n * @returns O valor do segredo\n */\nexport async function getSecretFromVault(secretPathOrId: string): Promise<string | null> {\n  console.warn(`VAULT: Attempting to fetch secret for path/id: ${secretPathOrId}. This is a placeholder implementation.`);\n  // Exemplo de como poderia ser com uma função Edge 'get-vault-secret'\n  // const { data, error } = await supabaseAdmin.functions.invoke('get-vault-secret', {\n  //   body: { secretId: secretPathOrId },\n  // });\n  // if (error) {\n  //   console.error(`Error fetching secret ${secretPathOrId} from Vault:`, error);\n  //   return null;\n  // }\n  // return data?.secretValue;\n\n  // Simulação (REMOVA EM PRODUÇÃO)\n  if (secretPathOrId === process.env.OPENAI_API_KEY_VAULT_ID_EXAMPLE) {\n    return process.env.OPENAI_API_KEY_EXAMPLE_VALUE;\n  }\n  if (secretPathOrId === process.env.GEMINI_API_KEY_VAULT_ID_EXAMPLE) {\n     return process.env.GEMINI_API_KEY_EXAMPLE_VALUE;\n  }\n  console.error(`VAULT: Secret not found or mock not configured for ${secretPathOrId}`);\n  return null;\n}\n```\n\n**`src/types/index.ts`**\n```typescript\nimport { JwtVariables } from 'hono/jwt';\nimport { Organization, UserProfile } from './db.types'; // Supondo que você gere tipos do seu schema com supabase gen types\n\nexport type HonoEnv = {\n  Variables: {\n    user?: UserProfile & { sub: string; organization_id?: string; [key: string]: any }; // User payload from JWT\n    organization?: Organization;\n    // supabaseUserClient?: SupabaseClient;\n  } & JwtVariables;\n  Bindings: { /* ... */ };\n};\n\n// Adicione outros tipos globais aqui\n// Exemplo para definição de workflow (muito simplificado)\nexport interface WorkflowNode {\n  id: string;\n  type: string; // e.g., 'action:send_message', 'trigger:webhook', 'logic:if_else'\n  config: Record<string, any>;\n  outputs?: Record<string, string>; // { outputName: outputType }\n}\n\nexport interface WorkflowEdge {\n  id: string;\n  sourceNodeId: string;\n  targetNodeId: string;\n  sourceHandle?: string; // Para nós com múltiplas saídas (como if/else)\n  condition?: string; // Expressão de condição para a transição\n}\n\nexport interface WorkflowVariable {\n  id: string;\n  name: string;\n  type: 'string' | 'number' | 'boolean' | 'object' | 'array';\n  initialValue?: any;\n}\n\nexport interface WorkflowDefinition {\n  nodes: WorkflowNode[];\n  edges: WorkflowEdge[];\n  variablesSchema?: WorkflowVariable[];\n  globalSettings?: Record<string, any>;\n}\n```\n\n**`src/api/v1/middleware/auth.ts`**\n```typescript\nimport { createMiddleware } from 'hono/factory';\nimport { verify } from 'hono/jwt';\nimport { HonoEnv } from '@/types';\nimport { config } from '@/config';\nimport { supabaseAdmin } from '@/core/supabase'; // Para buscar perfil/org\n\nexport const authMiddleware = createMiddleware<HonoEnv>(async (c, next) => {\n  const authHeader = c.req.header('Authorization');\n  if (!authHeader || !authHeader.startsWith('Bearer ')) {\n    return c.json({ error: 'Unauthorized', message: 'Bearer token missing' }, 401);\n  }\n  const token = authHeader.substring(7);\n\n  try {\n    const decodedPayload = await verify(token, config.supabaseJwtSecret);\n    if (!decodedPayload.sub) {\n      return c.json({ error: 'Unauthorized', message: 'Invalid token: subject missing' }, 401);\n    }\n\n    // Opcional: buscar perfil e organização para injetar no contexto\n    // Assumindo que 'organization_id' está nas app_metadata do JWT ou na user_profiles\n    const userId = decodedPayload.sub as string;\n    let organizationId = decodedPayload.organization_id as string | undefined; // Se estiver no token\n\n    const { data: userProfile, error: profileError } = await supabaseAdmin\n      .from('user_profiles')\n      .select(`*, organization_id, organizations(*)`) // Pega a organização junto\n      .eq('id', userId)\n      .single();\n\n    if (profileError || !userProfile) {\n      console.error('Auth Middleware: User profile not found or error', profileError);\n      return c.json({ error: 'Forbidden', message: 'User profile not found' }, 403);\n    }\n\n    if (!organizationId && userProfile.organization_id) {\n        organizationId = userProfile.organization_id;\n    }\n\n    if (!organizationId && userProfile.organizations) { // Se organizations é um objeto e não ID direto\n        organizationId = userProfile.organizations.id;\n    }\n\n\n    if (!organizationId) {\n        // Se a organização é obrigatória para todas as rotas protegidas\n        console.warn(`Auth Middleware: Organization ID not found for user ${userId}. JWT custom claims might be needed or user_profile.organization_id is null.`);\n        // Dependendo da sua lógica, pode retornar 403 aqui se org for sempre necessária\n    }\n\n\n    c.set('user', { ...userProfile, ...decodedPayload, sub: userId, organization_id: organizationId });\n    if (userProfile.organizations) {\n        c.set('organization', userProfile.organizations);\n    }\n\n\n    await next();\n  } catch (err: any) {\n    console.error('JWT Verification Error:', err.message, err);\n    return c.json({ error: 'Unauthorized', message: 'Invalid or expired token.' }, 401);\n  }\n});\n```\n\n**`src/api/v1/modules/workflows/workflows.routes.ts` (Esqueleto)**\n```typescript\nimport { Hono } from 'hono';\nimport { zValidator } from '@hono/zod-validator';\nimport { authMiddleware } from '../../middleware/auth';\nimport { HonoEnv } from '@/types';\nimport * as WorkflowService from './workflows.services';\nimport { createWorkflowSchema, updateWorkflowSchema } from './workflows.validators'; // Crie estes\n\nconst workflowsApp = new Hono<HonoEnv>();\n\nworkflowsApp.use('*', authMiddleware); // Proteger todas as rotas de workflow\n\nworkflowsApp.post('/', zValidator('json', createWorkflowSchema), async (c) => {\n  const data = c.req.valid('json');\n  const user = c.get('user');\n  const organizationId = user?.organization_id;\n\n  if (!organizationId) {\n    return c.json({ error: 'Forbidden', message: 'Organization not found for user' }, 403);\n  }\n\n  try {\n    const workflow = await WorkflowService.createWorkflow(organizationId, user.id, data);\n    return c.json(workflow, 201);\n  } catch (error: any) {\n    return c.json({ error: 'Failed to create workflow', message: error.message }, 500);\n  }\n});\n\nworkflowsApp.get('/:id', async (c) => {\n  const { id } = c.req.param();\n  const user = c.get('user');\n  const organizationId = user?.organization_id;\n\n  if (!organizationId) return c.json({ error: 'Forbidden' }, 403);\n\n  try {\n    const workflow = await WorkflowService.getWorkflowById(id, organizationId);\n    if (!workflow) return c.json({ error: 'Not Found' }, 404);\n    return c.json(workflow);\n  } catch (error: any) {\n    return c.json({ error: 'Failed to fetch workflow', message: error.message }, 500);\n  }\n});\n\n// ... Outros endpoints: PUT, DELETE, GET (listar), POST /{id}/execute\n// POST /{id}/execute - para disparar manualmente\nworkflowsApp.post('/:id/execute', async (c) => {\n    const { id: workflowId } = c.req.param();\n    const user = c.get('user');\n    const organizationId = user?.organization_id;\n    const triggerPayload = await c.req.json().catch(() => ({})); // Payload opcional para o trigger\n\n    if (!organizationId) return c.json({ error: 'Forbidden' }, 403);\n\n    try {\n        // A execução real seria delegada ao workflow_engine\n        const execution = await WorkflowService.executeWorkflow(workflowId, organizationId, triggerPayload, user.id);\n        return c.json(execution, 202); // 202 Accepted, pois a execução é assíncrona\n    } catch (error: any) {\n        console.error(`Error executing workflow ${workflowId}:`, error);\n        return c.json({ error: 'Failed to execute workflow', message: error.message }, 500);\n    }\n});\n\n\nexport default workflowsApp;\n```\n\n**`src/api/v1/modules/workflows/workflows.services.ts` (Esqueleto)**\n```typescript\nimport { supabaseAdmin } from '@/core/supabase';\nimport { WorkflowDefinition } from '@/types';\nimport { WorkflowEngine } from '@/workflow_engine'; // Supondo que a classe/objeto principal do engine está aqui\n\ninterface CreateWorkflowDto {\n  name: string;\n  description?: string;\n  definition: WorkflowDefinition; // Usar o tipo WorkflowDefinition\n  trigger_type?: string;\n  trigger_config?: object;\n  is_active?: boolean;\n}\n\nexport async function createWorkflow(\n  organizationId: string,\n  userId: string,\n  data: CreateWorkflowDto\n) {\n  const { data: workflow, error } = await supabaseAdmin\n    .from('workflows')\n    .insert({\n      organization_id: organizationId,\n      created_by_user_id: userId,\n      name: data.name,\n      description: data.description,\n      definition: data.definition, // Assegure que isso é um JSONB válido\n      trigger_type: data.trigger_type,\n      trigger_config: data.trigger_config,\n      is_active: data.is_active ?? true,\n    })\n    .select()\n    .single();\n\n  if (error) throw error;\n  return workflow;\n}\n\nexport async function getWorkflowById(id: string, organizationId: string) {\n  const { data: workflow, error } = await supabaseAdmin\n    .from('workflows')\n    .select('*')\n    .eq('id', id)\n    .eq('organization_id', organizationId)\n    .single();\n\n  if (error) throw error;\n  return workflow;\n}\n\n// Função para disparar um workflow (simplificado)\nexport async function executeWorkflow(\n    workflowId: string,\n    organizationId: string,\n    triggerPayload: any,\n    triggeredByUserId?: string\n) {\n    const workflowData = await getWorkflowById(workflowId, organizationId);\n    if (!workflowData) {\n        throw new Error('Workflow not found or not accessible.');\n    }\n\n    // Instanciar e rodar o motor de workflow\n    const engine = new WorkflowEngine(supabaseAdmin); // Passar cliente Supabase, talvez config\n    const executionResult = await engine.run(workflowData, triggerPayload, triggeredByUserId);\n\n    return executionResult; // Deve retornar um ID de execução ou status\n}\n\n// ... Outros serviços: updateWorkflow, deleteWorkflow, listWorkflows\n```\n\n**`src/workflow_engine/index.ts` (Classe WorkflowEngine - Esqueleto)**\n```typescript\nimport { SupabaseClient } from '@supabase/supabase-js';\nimport { WorkflowDefinition } from '@/types'; // Importe seus tipos de Workflow e Node\nimport { executeNode } from './executor'; // executor.ts conterá a lógica de execução do nó\n\ninterface WorkflowSchema { // Este tipo viria da sua tabela 'workflows'\n    id: string;\n    organization_id: string;\n    definition: WorkflowDefinition; // Usar o tipo WorkflowDefinition\n    // ... outros campos do workflow\n}\n\nexport class WorkflowEngine {\n  private supabase: SupabaseClient;\n\n  constructor(supabaseClient: SupabaseClient) {\n    this.supabase = supabaseClient;\n  }\n\n  public async run(workflow: WorkflowSchema, triggerData: any, triggeredByUserId?: string) {\n    const executionId = crypto.randomUUID(); // Gerar um ID para a execução\n    console.log(`Starting workflow execution ${executionId} for workflow ${workflow.id}`);\n\n    // 1. Criar registro em workflow_executions\n    const { data: executionRecord, error: executionError } = await this.supabase\n      .from('workflow_executions')\n      .insert({\n        id: executionId,\n        workflow_id: workflow.id,\n        // workflow_version_id: workflow.published_version_id, // Se aplicável\n        organization_id: workflow.organization_id,\n        status: 'running',\n        trigger_event_data: triggerData,\n        started_at: new Date().toISOString(),\n        // triggered_by_user_id: triggeredByUserId,\n      })\n      .select()\n      .single();\n\n    if (executionError) {\n      console.error('Failed to create workflow execution record:', executionError);\n      throw executionError;\n    }\n\n    let currentContext: Record<string, any> = {\n        trigger: { outputs: triggerData },\n        variables: {}, // Inicializar variáveis globais do workflow aqui\n    };\n\n    // Inicializar variáveis globais do workflow a partir do schema\n    workflow.definition.variablesSchema?.forEach(v => {\n        currentContext.variables[v.name] = v.initialValue;\n    });\n\n    try {\n      // Encontrar o(s) nó(s) de início (trigger)\n      const startNode = workflow.definition.nodes.find(node => node.type.startsWith('trigger:'));\n      if (!startNode) {\n        throw new Error('No start/trigger node found in workflow definition.');\n      }\n\n      // Lógica de execução sequencial simplificada (um motor real seria mais complexo, lidando com grafos)\n      let currentNodeId: string | undefined = startNode.id;\n\n      while (currentNodeId) {\n          const node = workflow.definition.nodes.find(n => n.id === currentNodeId);\n          if (!node) throw new Error(`Node ${currentNodeId} not found in definition.`);\n\n          const nodeStartTime = Date.now();\n          let nodeOutput: any;\n          let nodeError: any;\n          let nodeStatus: string = 'running';\n\n          try {\n              console.log(`Executing node ${node.id} (type: ${node.type})`);\n              // `executeNode` precisará do supabase client, connections, vault, etc.\n              nodeOutput = await executeNode(node, currentContext, this.supabase, workflow.organization_id);\n              currentContext[node.id] = { outputs: nodeOutput }; // Armazenar saída do nó no contexto\n              nodeStatus = 'completed';\n          } catch (err: any) {\n              console.error(`Error executing node ${node.id}:`, err);\n              nodeError = { message: err.message, stack: err.stack };\n              nodeStatus = 'failed';\n              // Aqui você pode ter lógica de retry ou ir para um nó de erro global\n              throw err; // Propaga o erro para parar a execução por enquanto\n          } finally {\n              // Log do passo da execução\n              await this.supabase.from('workflow_execution_step_logs').insert({\n                  workflow_execution_id: executionId,\n                  organization_id: workflow.organization_id,\n                  node_id: node.id,\n                  node_type: node.type,\n                  status: nodeStatus,\n                  input_data: { config: node.config, contextSnapshot: { ...currentContext[node.id === startNode.id ? 'trigger' : 'previous_node_outputs_placeholder'] } }, // Capturar o input relevante\n                  output_data: nodeOutput,\n                  error_message: nodeError?.message,\n                  started_at: new Date(nodeStartTime).toISOString(),\n                  duration_ms: Date.now() - nodeStartTime,\n              });\n          }\n\n          if (nodeStatus === 'failed') break; // Parar se um nó falhar\n\n          // Encontrar o próximo nó (simplificado para fluxo linear)\n          const edge = workflow.definition.edges.find(e => e.sourceNodeId === currentNodeId);\n          // Um motor real avaliaria condições nas edges, lidaria com múltiplos caminhos, etc.\n          currentNodeId = edge?.targetNodeId;\n      }\n\n      // 2. Atualizar registro em workflow_executions para 'completed'\n      await this.supabase\n        .from('workflow_executions')\n        .update({ status: 'completed', ended_at: new Date().toISOString(), execution_data: currentContext })\n        .eq('id', executionId);\n\n      return { executionId, status: 'completed', finalContext: currentContext };\n\n    } catch (error: any) {\n      // 3. Atualizar registro em workflow_executions para 'failed'\n      await this.supabase\n        .from('workflow_executions')\n        .update({\n          status: 'failed',\n          ended_at: new Date().toISOString(),\n          error_details: { message: error.message, stack: error.stack },\n          execution_data: currentContext\n        })\n        .eq('id', executionId);\n      console.error(`Workflow execution ${executionId} failed:`, error);\n      return { executionId, status: 'failed', error: error.message, finalContext: currentContext };\n    }\n  }\n}\n```\n\n**`src/workflow_engine/executor.ts` (Esqueleto)**\n```typescript\nimport { SupabaseClient } from '@supabase/supabase-js';\nimport { WorkflowNode } from '@/types';\n// Importe seus handlers de nó aqui\nimport { handleSendMessage } from './node_handlers/send_message.handler';\nimport { handleLlmPrompt } from './node_handlers/llm_prompt.handler';\n// ... outros handlers\n\nexport async function executeNode(\n  node: WorkflowNode,\n  context: Record<string, any>,\n  supabase: SupabaseClient,\n  organizationId: string\n): Promise<any> {\n  // `context` contém saídas de nós anteriores e variáveis globais\n  // ex: context.trigger.outputs, context.node_anterior_id.outputs, context.variables\n\n  switch (node.type) {\n    case 'action:send_message':\n      return await handleSendMessage(node.config, context, supabase, organizationId);\n    case 'action:llm_prompt':\n      return await handleLlmPrompt(node.config, context, supabase, organizationId);\n    // case 'action:delay':\n    //   return await handleDelay(node.config, context);\n    // case 'logic:if_else':\n    //   return handleCondition(node.config, context); // Isso determinaria o próximo nó, não necessariamente um output direto\n    // Adicione cases para todos os seus tipos de nó\n    case 'trigger:webhook': // Triggers podem ter uma lógica de output inicial\n        return context.trigger?.outputs || {}; // O output do trigger já está no contexto\n    default:\n      console.warn(`No handler for node type: ${node.type}`);\n      return {}; // Ou lançar um erro\n  }\n}\n```\n\n**`src/services/embedding.service.ts` (Esqueleto)**\n```typescript\nimport { SupabaseClient } from '@supabase/supabase-js';\nimport { config } from '@/config';\nimport { getSecretFromVault } from '@/core/vault.service';\n// Supondo que você use a biblioteca OpenAI ou Gemini\n// import OpenAI from 'openai';\n// import { GoogleGenerativeAI } from \"@google/generative-ai\";\n\n// Placeholder para clientes de IA - inicialize-os com as chaves do Vault\n// let openai: OpenAI | null = null;\n// let genAI: GoogleGenerativeAI | null = null;\n\n// async function getOpenAIClient() {\n//   if (openai) return openai;\n//   const apiKey = await getSecretFromVault(config.openaiApiKeyVaultId); // Substitua pelos seus IDs do Vault\n//   if (!apiKey) throw new Error('OpenAI API key not found in Vault');\n//   openai = new OpenAI({ apiKey });\n//   return openai;\n// }\n\n// async function getGeminiClient() { /* ... similar ... */ }\n\n\nexport async function generateEmbedding(\n  text: string,\n  provider: 'openai' | 'gemini' | 'custom' = 'openai', // Ou o que você configurar\n  // model: string = 'text-embedding-ada-002' // Específico do provedor\n): Promise<number[] | null> {\n  if (!text || text.trim() === '') return null;\n\n  try {\n    // Exemplo com OpenAI (descomente e adapte)\n    // if (provider === 'openai') {\n    //   const client = await getOpenAIClient();\n    //   const response = await client.embeddings.create({\n    //     model: model,\n    //     input: text.replace(/\\n/g, ' '), // OpenAI recomenda substituir newlines\n    //   });\n    //   if (response.data && response.data[0]?.embedding) {\n    //     return response.data[0].embedding;\n    //   }\n    // }\n    // Adicione lógica para Gemini ou outros provedores\n\n    console.warn(`Embedding generation not fully implemented for provider: ${provider}. Returning dummy embedding.`);\n    // Retornar um embedding dummy com a dimensão correta para desenvolvimento\n    return Array(config.embeddingDimension).fill(0.1);\n\n  } catch (error) {\n    console.error('Error generating embedding:', error);\n    return null;\n  }\n}\n\nexport async function findSimilarItemsInTable(\n  supabaseClient: SupabaseClient, // Pode ser o client admin ou o client do usuário com RLS\n  tableName: string,\n  embeddingColumnName: string,\n  queryEmbedding: number[],\n  organizationId: string, // Sempre filtre pela organização!\n  limit: number = 5,\n  selectColumns: string = '*' // Colunas a serem retornadas\n): Promise<any[] | null> {\n  if (!queryEmbedding || queryEmbedding.length === 0) return null;\n\n  const { data, error } = await supabaseClient\n    .rpc('match_documents_by_org', { // CRIE ESTA FUNÇÃO SQL NO SUPABASE\n      org_id: organizationId,\n      query_embedding: queryEmbedding,\n      table_name_param: tableName, // Nome da tabela como parâmetro\n      embedding_column_name_param: embeddingColumnName, // Nome da coluna de embedding como parâmetro\n      match_count: limit,\n      select_columns_param: selectColumns,\n      // match_threshold: 0.7 // Distância de cosseno, 1 - similaridade. (0.3 para 70% similaridade)\n    });\n\n  // Exemplo de função SQL 'match_documents_by_org' (simplificada):\n  /*\n  CREATE OR REPLACE FUNCTION match_documents_by_org (\n    org_id uuid,\n    query_embedding vector(1536),\n    table_name_param text,\n    embedding_column_name_param text,\n    match_count int,\n    select_columns_param text default '*'\n  ) RETURNS SETOF record -- ou TABLE(...) se souber as colunas exatas\n  LANGUAGE plpgsql\n  AS $$\n  BEGIN\n    RETURN QUERY EXECUTE format(\n      'SELECT %s, (tbl.%I <-> $1) AS similarity_score ' ||\n      'FROM %I AS tbl ' ||\n      'WHERE tbl.organization_id = $2 ' ||\n      'ORDER BY similarity_score ASC ' || -- Lower distance = more similar\n      'LIMIT $3',\n      select_columns_param,              -- Colunas a selecionar\n      embedding_column_name_param,       -- Coluna de embedding\n      table_name_param,                  -- Nome da tabela\n      embedding_column_name_param        -- Coluna de embedding para a cláusula WHERE/ORDER BY\n    )\n    USING query_embedding, org_id, match_count;\n  END;\n  $$;\n  */\n\n\n  if (error) {\n    console.error(`Error finding similar items in ${tableName} for org ${organizationId}:`, error);\n    return null;\n  }\n  return data;\n}\n```\n\n**`src/index.ts` (Hono App - Esqueleto Principal)**\n```typescript\nimport { Hono } from 'hono';\nimport { cors } from 'hono/cors';\nimport { logger } from 'hono/logger';\nimport { secureHeaders } from 'hono/secure-headers';\nimport { prettyJSON } from 'hono/pretty-json';\nimport { config } from './config';\nimport { HonoEnv } from './types';\n\nimport v1ApiApp from './api/v1';\nimport webhooksApp from './webhooks'; // Router para todos os webhooks\n\nconst app = new Hono<HonoEnv>();\n\n// Middleware Global\napp.use('*', logger());\napp.use('*', prettyJSON());\napp.use('*', secureHeaders());\napp.use(\n  '/api/*',\n  cors({\n    origin: ['http://localhost:3001', 'http://localhost:3002', 'https://your-frontend-app.com'], // Adicione suas origens permitidas\n    allowMethods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],\n    allowHeaders: ['Content-Type', 'Authorization'],\n    credentials: true,\n  })\n);\n\n// Rotas\napp.get('/', (c) => c.json({ message: 'Omnichannel API with Workflows and IA is ALIVE!' }));\napp.route('/api/v1', v1ApiApp);\napp.route('/webhooks', webhooksApp);\n\n// Error Handling\napp.onError((err, c) => {\n  console.error(`[${c.req.method}] ${c.req.path} - Unhandled Error:`, err);\n  // TODO: Implementar um error handler mais robusto\n  if (err instanceof Error && 'status' in err && typeof err.status === 'number') {\n    return c.json({ error: err.name || 'Error', message: err.message }, err.status);\n  }\n  return c.json({ error: 'InternalServerError', message: (err as Error).message || 'An unexpected error occurred' }, 500);\n});\n\napp.notFound((c) => {\n  return c.json({ error: 'NotFound', message: `The path ${c.req.path} was not found.` }, 404);\n});\n\nconsole.log(`Omnichannel API server running on port ${config.port}`);\n\nexport default {\n  port: config.port,\n  fetch: app.fetch,\n};\n```\n\n---\n\nEste conjunto de documentação e código é um ponto de partida robusto. Os próximos passos seriam:\n\n1.  **Completar o Schema SQL (`db/schema.sql`):** Escrever todo o DDL para criar as tabelas, enums, funções e políticas RLS.\n2.  **Gerar Tipos do Banco de Dados:** Usar `supabase gen types typescript --project-id <your-project-id> > src/types/db.types.ts` para ter type-safety com seu schema.\n3.  **Implementar os `*.services.ts` e `*.validators.ts`** para cada módulo da API.\n4.  **Construir o `workflow_engine`** com seus `node_handlers`. Esta é a parte mais complexa.\n5.  **Configurar e testar a integração com Supabase Vault.**\n6.  **Desenvolver os Webhook Handlers** com verificação de assinatura e lógica de processamento.\n7.  **Escrever testes!**\n\nBoa sorte com este projeto ambicioso!",
      ],
    },
    {
      role: "user",
      parts: [
        "continue criando os arquivos",
      ],
    },
    {
      role: "model",
      parts: [
        "**Refining API Structure**\n\nI'm currently working on completing core API modules like 'contacts' and 'messages' to establish a clear structural foundation. My focus now is also on sketching a comprehensive `README.md` to guide users through the project's architecture.\n\n\n**Developing Key Modules**\n\nI've just finalized the initial drafts of the `contacts` and `messages` modules, including validators, routes, and services, forming a solid basis. My current emphasis is on sketching a concrete `node_handler` for the `workflow_engine`. I'm also planning a basic WhatsApp webhook handler and drafting Zod validators. Focusing on Supabase integration, modularity with Hono, workflows, AI, and pgvector remains my guiding principles.\n\n\n**Implementing Key Components**\n\nI'm now focusing on completing core API modules and services, starting with `contacts` and `messages`. This involves crafting validators, routes, and services for a functional structure. I'm also drafting a WhatsApp webhook handler and a concrete `node_handler` for the `workflow_engine`. I'll also create several placeholder files for types, modules, and handlers, to demonstrate the project's architecture. The main principles remain integration, modularity, workflows, AI, and pgvector.\n\n\n",
        "Okay, vamos continuar expandindo a base de código, focando em alguns módulos e serviços chave para ilustrar melhor a arquitetura.\n\n**1. `src/types/db.types.ts` (Placeholder)**\n\nEste arquivo seria gerado pelo Supabase CLI (`supabase gen types typescript ...`). Como não temos o schema completo executado no Supabase para gerar, vou criar um placeholder com alguns tipos que usaremos. **Você DEVE gerar este arquivo a partir do seu schema real.**\n\n```typescript\n// src/types/db.types.ts (MANUAL PLACEHOLDER - GERE COM SUPABASE CLI)\n\nexport type Json =\n  | string\n  | number\n  | boolean\n  | null\n  | { [key: string]: Json | undefined }\n  | Json[]\n\nexport interface Database {\n  public: {\n    Tables: {\n      organizations: {\n        Row: {\n          id: string\n          name: string\n          created_at: string\n          updated_at: string\n          // ... outros campos\n        }\n        Insert: {\n          id?: string\n          name: string\n          created_at?: string\n          updated_at?: string\n        }\n        Update: {\n          id?: string\n          name?: string\n          updated_at?: string\n        }\n      }\n      user_profiles: {\n        Row: {\n          id: string // FK para auth.users\n          organization_id: string | null\n          full_name: string | null\n          avatar_url: string | null\n          role: string | null // 'admin', 'agent', 'member'\n          created_at: string\n          updated_at: string\n          // Adicione aqui a relação com organizations se o Supabase gen types fizer\n          organizations?: Database['public']['Tables']['organizations']['Row'] | null\n        }\n        Insert: { /* ... */ }\n        Update: { /* ... */ }\n      }\n      channels: {\n        Row: {\n          id: string\n          organization_id: string\n          name: string\n          type: 'whatsapp' | 'telegram' | 'instagram' | 'web_chat' | 'email' // channel_type_enum\n          is_active: boolean\n          config_jsonb: Json | null\n          credentials_vault_path_jsonb: Json | null // { accessTokenVaultId: \"...\", ... }\n          created_at: string\n          updated_at: string\n        }\n        Insert: { /* ... */ }\n        Update: { /* ... */ }\n      }\n      contacts: {\n        Row: {\n          id: string\n          organization_id: string\n          full_name: string | null\n          email: string | null\n          phone_number: string | null\n          // profile_summary_embedding: number[] | null // pgvector\n          custom_fields: Json | null\n          created_at: string\n          updated_at: string\n        }\n        Insert: { /* ... */ }\n        Update: { /* ... */ }\n      }\n      contact_identifiers: {\n        Row: {\n            id: string\n            contact_id: string\n            channel_id: string | null\n            identifier_type: Database['public']['Tables']['channels']['Row']['type'] // ou sua enum\n            value: string\n            is_primary: boolean\n            created_at: string\n        }\n        Insert: { /* ... */ }\n        Update: { /* ... */ }\n      }\n      messages: {\n        Row: {\n          id: number // bigserial\n          organization_id: string\n          channel_id: string\n          contact_id: string\n          agent_user_id: string | null\n          direction: 'inbound' | 'outbound'\n          content_type: 'text' | 'image' | 'template' // etc.\n          text_content: string | null\n          // content_embedding: number[] | null // pgvector\n          status: 'pending' | 'sent' | 'delivered' | 'read' | 'failed' | 'received'\n          timestamp: string\n          created_at: string\n          updated_at: string\n          // ... outros campos\n        }\n        Insert: { /* ... */ }\n        Update: { /* ... */ }\n      }\n      conversations: {\n        Row: {\n            id: string\n            organization_id: string\n            channel_id: string\n            contact_id: string\n            status: 'open' | 'resolved' | 'pending' | 'snoozed' // etc.\n            assignee_user_id: string | null\n            team_id: string | null\n            last_activity_at: string\n            // ... outros campos\n        }\n        Insert: { /* ... */ }\n        Update: { /* ... */ }\n      }\n      // ... Defina placeholders para outras tabelas importantes como\n      // workflows, workflow_executions, connections, etc.\n    }\n    Views: {\n      // ... suas views\n    }\n    Functions: {\n      match_documents_by_org?: { // RPC function para pgvector\n        Args: {\n          org_id: string\n          query_embedding: number[] // ou string se passar como JSON '[1,2,3]'\n          table_name_param: string\n          embedding_column_name_param: string\n          match_count: number\n          select_columns_param?: string\n          // match_threshold?: number\n        }\n        Returns: { /* Defina o tipo de retorno, pode ser SETOF record ou JSON */ }[]\n      }\n      // ... suas funções RPC\n    }\n    Enums: {\n      // channel_type_enum: 'whatsapp' | 'telegram' | ...\n    }\n  }\n}\n\n// Tipos utilitários baseados no placeholder (exemplo)\nexport type Organization = Database['public']['Tables']['organizations']['Row'];\nexport type UserProfile = Database['public']['Tables']['user_profiles']['Row'];\nexport type Channel = Database['public']['Tables']['channels']['Row'];\nexport type Contact = Database['public']['Tables']['contacts']['Row'];\nexport type Message = Database['public']['Tables']['messages']['Row'];\nexport type Conversation = Database['public']['Tables']['conversations']['Row'];\n```\n\n**2. Módulo `contacts`**\n\n**`src/api/v1/modules/contacts/contacts.validators.ts`**\n```typescript\nimport { z } from 'zod';\n\nexport const createContactSchema = z.object({\n  full_name: z.string().optional().nullable(),\n  email: z.string().email().optional().nullable(),\n  phone_number: z.string().optional().nullable(),\n  // Para identificadores, pode ser um array ou tratado separadamente\n  identifiers: z.array(z.object({\n    type: z.enum(['whatsapp', 'telegram', 'email', 'instagram', 'web_chat']), // Corresponde a channel_type_enum\n    value: z.string().min(1),\n    is_primary: z.boolean().optional()\n  })).optional(),\n  custom_fields: z.record(z.any()).optional().nullable(),\n});\nexport type CreateContactInput = z.infer<typeof createContactSchema>;\n\nexport const updateContactSchema = createContactSchema.partial().extend({\n    // Não permitir mudar identifiers facilmente via PUT genérico, talvez um endpoint específico\n    identifiers: z.undefined().optional(), // Excluir identifiers do update parcial direto\n});\nexport type UpdateContactInput = z.infer<typeof updateContactSchema>;\n```\n\n**`src/api/v1/modules/contacts/contacts.routes.ts`**\n```typescript\nimport { Hono } from 'hono';\nimport { zValidator } from '@hono/zod-validator';\nimport { authMiddleware } from '../../middleware/auth';\nimport { HonoEnv } from '@/types';\nimport * as ContactService from './contacts.services';\nimport { createContactSchema, updateContactSchema } from './contacts.validators';\n\nconst contactsApp = new Hono<HonoEnv>();\n\ncontactsApp.use('*', authMiddleware);\n\ncontactsApp.post('/', zValidator('json', createContactSchema), async (c) => {\n  const data = c.req.valid('json');\n  const user = c.get('user');\n  if (!user?.organization_id) return c.json({ error: 'Forbidden' }, 403);\n\n  try {\n    const contact = await ContactService.createContact(user.organization_id, data);\n    return c.json(contact, 201);\n  } catch (error: any) {\n    return c.json({ error: 'Failed to create contact', message: error.message }, 500);\n  }\n});\n\ncontactsApp.get('/:id', async (c) => {\n  const { id } = c.req.param();\n  const user = c.get('user');\n  if (!user?.organization_id) return c.json({ error: 'Forbidden' }, 403);\n\n  try {\n    const contact = await ContactService.getContactById(id, user.organization_id);\n    if (!contact) return c.json({ error: 'Not Found' }, 404);\n    return c.json(contact);\n  } catch (error: any) {\n    return c.json({ error: 'Failed to fetch contact', message: error.message }, 500);\n  }\n});\n\ncontactsApp.put('/:id', zValidator('json', updateContactSchema), async (c) => {\n    const { id } = c.req.param();\n    const data = c.req.valid('json');\n    const user = c.get('user');\n    if (!user?.organization_id) return c.json({ error: 'Forbidden' }, 403);\n\n    try {\n        const updatedContact = await ContactService.updateContact(id, user.organization_id, data);\n        if (!updatedContact) return c.json({ error: 'Not Found or update failed' }, 404);\n        return c.json(updatedContact);\n    } catch (error: any) {\n        return c.json({ error: 'Failed to update contact', message: error.message }, 500);\n    }\n});\n\n// TODO: GET / (listar com paginação e filtros), DELETE /:id\n// TODO: Endpoints para gerenciar contact_identifiers (POST /:contactId/identifiers)\n\nexport default contactsApp;\n```\n\n**`src/api/v1/modules/contacts/contacts.services.ts`**\n```typescript\nimport { supabaseAdmin } from '@/core/supabase';\nimport { CreateContactInput, UpdateContactInput } from './contacts.validators';\nimport { Contact as DbContact } from '@/types/db.types'; // Usar o tipo gerado\n\nexport async function createContact(\n  organizationId: string,\n  contactData: CreateContactInput\n): Promise<DbContact> {\n  const { identifiers, ...mainContactData } = contactData;\n\n  const { data: newContact, error } = await supabaseAdmin\n    .from('contacts')\n    .insert({\n      ...mainContactData,\n      organization_id: organizationId,\n    })\n    .select()\n    .single();\n\n  if (error) throw error;\n  if (!newContact) throw new Error('Contact creation failed to return data.');\n\n  if (identifiers && identifiers.length > 0) {\n    const identifierInserts = identifiers.map(id => ({\n        contact_id: newContact.id,\n        // channel_id: null, // Se não for específico de um canal nosso, mas de um tipo\n        identifier_type: id.type,\n        value: id.value,\n        is_primary: id.is_primary ?? false,\n        // organization_id: organizationId // Se a tabela contact_identifiers tiver org_id\n    }));\n    const { error: idError } = await supabaseAdmin.from('contact_identifiers').insert(identifierInserts);\n    if (idError) {\n        console.warn('Failed to insert some contact identifiers, but contact created:', idError);\n        // Pode-se optar por deletar o contato recém-criado ou retornar com aviso.\n    }\n  }\n\n  return newContact as DbContact;\n}\n\nexport async function getContactById(id: string, organizationId: string): Promise<DbContact | null> {\n  const { data, error } = await supabaseAdmin\n    .from('contacts')\n    .select(`\n        *,\n        contact_identifiers ( * )\n    `)\n    .eq('id', id)\n    .eq('organization_id', organizationId)\n    .single();\n\n  if (error) {\n    if (error.code === 'PGRST116') return null; // Not found\n    throw error;\n  }\n  return data as DbContact;\n}\n\nexport async function updateContact(\n    id: string,\n    organizationId: string,\n    contactData: UpdateContactInput\n): Promise<DbContact | null> {\n    const { data: updatedContact, error } = await supabaseAdmin\n        .from('contacts')\n        .update({ ...contactData, updated_at: new Date().toISOString() })\n        .eq('id', id)\n        .eq('organization_id', organizationId)\n        .select()\n        .single();\n\n    if (error) {\n        if (error.code === 'PGRST116') return null; // Not found\n        throw error;\n    }\n    return updatedContact as DbContact;\n}\n\n// Função para encontrar ou criar contato e seu identificador\nexport async function findOrCreateContactByIdentifier(\n  organizationId: string,\n  identifierType: CreateContactInput['identifiers'][0]['type'],\n  identifierValue: string,\n  contactInfo?: Partial<Omit<CreateContactInput, 'identifiers'>> // Informações adicionais para criar\n): Promise<{contact: DbContact, identifier: any, isNewContact: boolean}> {\n  // 1. Tentar encontrar o identificador\n  let { data: existingIdentifier, error: findIdError } = await supabaseAdmin\n    .from('contact_identifiers')\n    .select('*, contacts(*)') // Pegar o contato junto\n    .eq('identifier_type', identifierType)\n    .eq('value', identifierValue)\n    // .eq('organization_id', organizationId) // Se contact_identifiers tiver org_id\n    .maybeSingle(); // Pode não existir\n\n  if (findIdError && findIdError.code !== 'PGRST116') throw findIdError;\n\n  if (existingIdentifier && existingIdentifier.contacts && existingIdentifier.contacts.organization_id === organizationId) {\n    // Identificador e contato existem e pertencem à organização\n    return { contact: existingIdentifier.contacts as DbContact, identifier: existingIdentifier, isNewContact: false };\n  }\n\n  // Se o identificador não existe OU o contato associado não é da mesma organização\n  // (isso pode indicar um problema de dados ou um identificador global que outra org já usou)\n  // Por simplicidade, vamos criar um novo contato se não encontrado na org.\n  // Em um sistema real, pode haver uma lógica mais complexa para fundir contatos se o source_id for global.\n\n  // 2. Criar novo contato e identificador\n  const newContactData: CreateContactInput = {\n    ...contactInfo,\n    full_name: contactInfo?.full_name || `Contact ${identifierValue}`, // Nome default\n  };\n\n  const { data: newContact, error: createContactError } = await supabaseAdmin\n    .from('contacts')\n    .insert({ ...newContactData, organization_id: organizationId })\n    .select()\n    .single();\n\n  if (createContactError) throw createContactError;\n  if (!newContact) throw new Error('Failed to create new contact');\n\n  const { data: newIdentifier, error: createIdError } = await supabaseAdmin\n    .from('contact_identifiers')\n    .insert({\n      contact_id: newContact.id,\n      identifier_type: identifierType,\n      value: identifierValue,\n      is_primary: true,\n    })\n    .select()\n    .single();\n\n  if (createIdError) throw createIdError;\n  if (!newIdentifier) throw new Error('Failed to create new contact identifier');\n\n  return { contact: newContact as DbContact, identifier: newIdentifier, isNewContact: true };\n}\n```\n\n**3. Módulo `messages`**\n\n**`src/api/v1/modules/messages/messages.validators.ts`**\n```typescript\nimport { z } from 'zod';\n\nexport const sendMessageSchema = z.object({\n  channel_id: z.string().uuid(),\n  contact_id: z.string().uuid().optional(), // Opcional se for uma nova conversa e o contato for identificado pelo `to`\n  to_identifier_value: z.string().optional(), // e.g., número do WhatsApp se contact_id não for fornecido\n  to_identifier_type: z.enum(['whatsapp', 'telegram', 'email', 'instagram', 'web_chat']).optional(),\n  content_type: z.enum(['text', 'image', 'template', 'interactive']), // Adicione mais tipos\n  text_content: z.string().optional(),\n  media_url: z.string().url().optional(),\n  template_data: z.record(z.any()).optional(), // Para mensagens de template\n  interactive_data: z.record(z.any()).optional(), // Para botões, listas\n});\nexport type SendMessageInput = z.infer<typeof sendMessageSchema>;\n```\n\n**`src/api/v1/modules/messages/messages.routes.ts`**\n```typescript\nimport { Hono } from 'hono';\nimport { zValidator } from '@hono/zod-validator';\nimport { authMiddleware } from '../../middleware/auth';\nimport { HonoEnv } from '@/types';\nimport * as MessageService from './messages.services';\nimport { sendMessageSchema } from './messages.validators';\n\nconst messagesApp = new Hono<HonoEnv>();\n\nmessagesApp.use('*', authMiddleware);\n\nmessagesApp.post('/', zValidator('json', sendMessageSchema), async (c) => {\n  const data = c.req.valid('json');\n  const user = c.get('user'); // Agente que está enviando\n  if (!user?.organization_id) return c.json({ error: 'Forbidden' }, 403);\n\n  try {\n    const sentMessage = await MessageService.sendMessage(user.organization_id, user.id, data);\n    return c.json(sentMessage, 201);\n  } catch (error: any) {\n    console.error('Error sending message via API:', error);\n    return c.json({ error: 'Failed to send message', message: error.message }, 500);\n  }\n});\n\n// GET /messages?conversation_id=...&contact_id=... (para listar mensagens)\n// ...\n\nexport default messagesApp;\n```\n\n**`src/api/v1/modules/messages/messages.services.ts`**\n```typescript\nimport { supabaseAdmin } from '@/core/supabase';\nimport { SendMessageInput } from './messages.validators';\nimport { Message as DbMessage, Channel as DbChannel } from '@/types/db.types';\nimport { findOrCreateContactByIdentifier } from '../contacts/contacts.services';\n\n// Importar os serviços de canal específicos\nimport * as WhatsappChannelService from '@/services/channels/whatsapp.channel.service';\nimport * as TelegramChannelService from '@/services/channels/telegram.channel.service';\n// ... outros canais\n\nexport async function sendMessage(\n  organizationId: string,\n  agentUserId: string,\n  messageData: SendMessageInput\n): Promise<DbMessage> {\n  // 1. Validar Canal\n  const { data: channel, error: channelError } = await supabaseAdmin\n    .from('channels')\n    .select('*')\n    .eq('id', messageData.channel_id)\n    .eq('organization_id', organizationId)\n    .single();\n\n  if (channelError || !channel) {\n    throw new Error('Channel not found or not accessible.');\n  }\n  if (!channel.is_active) {\n    throw new Error('Channel is not active.');\n  }\n\n  // 2. Determinar/Validar Contato\n  let contactId = messageData.contact_id;\n  let targetIdentifier = messageData.to_identifier_value;\n\n  if (!contactId && !targetIdentifier) {\n    throw new Error('Either contact_id or to_identifier_value must be provided.');\n  }\n\n  if (!contactId && targetIdentifier && messageData.to_identifier_type) {\n    const { contact } = await findOrCreateContactByIdentifier(\n      organizationId,\n      messageData.to_identifier_type,\n      targetIdentifier,\n      { /* informações básicas do contato se for criar */ }\n    );\n    contactId = contact.id;\n  } else if (contactId && !targetIdentifier) {\n    // Se temos contact_id, precisamos buscar o identificador principal para o tipo de canal\n    const { data: mainIdentifier, error: idError } = await supabaseAdmin\n      .from('contact_identifiers')\n      .select('value')\n      .eq('contact_id', contactId)\n      .eq('identifier_type', channel.type) // Usar o tipo do canal para encontrar o identificador correto\n      .eq('is_primary', true) // Ou alguma lógica para pegar o identificador correto\n      .single();\n\n    if (idError || !mainIdentifier) {\n        throw new Error(`Primary ${channel.type} identifier not found for contact ${contactId}`);\n    }\n    targetIdentifier = mainIdentifier.value;\n  }\n\n  if (!contactId || !targetIdentifier) {\n    throw new Error('Could not determine target contact or identifier.');\n  }\n\n  // 3. Construir o payload da mensagem para o serviço do canal\n  const platformPayload: any = { // Tipo específico por plataforma\n    to: targetIdentifier,\n    // Mapear messageData para o formato esperado pela API da plataforma\n    // Ex: text_content, media_url, template_data, interactive_data\n  };\n  if (messageData.text_content) platformPayload.text = messageData.text_content;\n  // ... outros campos\n\n  let externalMessageId: string | null = null;\n\n  // 4. Enviar através do serviço do canal apropriado\n  try {\n    switch (channel.type) {\n      case 'whatsapp':\n        externalMessageId = await WhatsappChannelService.sendMessage(organizationId, channel as DbChannel, platformPayload);\n        break;\n      case 'telegram':\n        // externalMessageId = await TelegramChannelService.sendMessage(channel, platformPayload);\n        throw new Error('Telegram send not yet implemented');\n        break;\n      // ... outros casos\n      default:\n        throw new Error(`Sending messages via ${channel.type} is not supported yet.`);\n    }\n  } catch (sendError: any) {\n    // Salvar mensagem com status 'failed' ANTES de relançar o erro\n    await saveMessageToDb(organizationId, channel.id, contactId, agentUserId, messageData, 'failed', null, sendError.message);\n    throw sendError; // Relançar para o route handler\n  }\n\n\n  // 5. Salvar mensagem no banco de dados com status 'sent' (ou o que a plataforma retornar)\n  const dbMessage = await saveMessageToDb(organizationId, channel.id, contactId, agentUserId, messageData, 'sent', externalMessageId);\n\n  // 6. Opcional: Atualizar `last_activity_at` da conversa\n  await updateConversationActivity(organizationId, channel.id, contactId);\n\n\n  return dbMessage as DbMessage;\n}\n\n\nasync function saveMessageToDb(\n    organizationId: string,\n    channelId: string,\n    contactId: string,\n    agentUserId: string,\n    messageData: SendMessageInput,\n    status: DbMessage['status'],\n    externalMessageId?: string | null,\n    errorMessage?: string\n) {\n    const { data: dbMessage, error: dbError } = await supabaseAdmin\n    .from('messages')\n    .insert({\n      organization_id: organizationId,\n      channel_id: channelId,\n      contact_id: contactId,\n      agent_user_id: agentUserId,\n      direction: 'outbound',\n      content_type: messageData.content_type,\n      text_content: messageData.text_content,\n      media_url: messageData.media_url,\n      template_data: messageData.template_data,\n      interactive_data: messageData.interactive_data,\n      status: status,\n      external_message_id: externalMessageId,\n      timestamp: new Date().toISOString(),\n      // Se falhou, pode-se armazenar o erro em metadata ou um campo 'error_message'\n      metadata: errorMessage ? { error: errorMessage } : undefined\n    })\n    .select()\n    .single();\n\n  if (dbError) {\n    console.error('Failed to save message to DB:', dbError);\n    // Não relançar aqui se a mensagem foi enviada, mas logar intensamente\n    // Se a mensagem FALHOU ao enviar, o erro já foi relançado antes.\n    if (status === 'failed') throw dbError; // Se era para salvar uma falha e falhou, aí sim é crítico\n  }\n  if (!dbMessage) throw new Error('Message saving failed to return data.');\n  return dbMessage as DbMessage;\n}\n\nexport async function storeInboundMessage(\n    organizationId: string,\n    channel: Pick<DbChannel, 'id' | 'type'>, // Apenas o ID e tipo do canal\n    contact: Pick<DbContact, 'id'>, // Apenas o ID do contato\n    messageDetails: {\n        externalMessageId?: string;\n        textContent?: string | null;\n        mediaUrl?: string | null;\n        contentType: DbMessage['content_type'];\n        timestamp?: Date | string; // Timestamp da plataforma\n        additionalPlatformData?: Json; // Dados brutos ou extras da plataforma\n    }\n): Promise<DbMessage> {\n    const { data: dbMessage, error: dbError } = await supabaseAdmin\n    .from('messages')\n    .insert({\n      organization_id: organizationId,\n      channel_id: channel.id,\n      contact_id: contact.id,\n      agent_user_id: null, // Mensagem de entrada não tem agente remetente\n      direction: 'inbound',\n      content_type: messageDetails.contentType,\n      text_content: messageDetails.textContent,\n      media_url: messageDetails.mediaUrl,\n      status: 'received',\n      external_message_id: messageDetails.externalMessageId,\n      timestamp: messageDetails.timestamp ? new Date(messageDetails.timestamp).toISOString() : new Date().toISOString(),\n      metadata: messageDetails.additionalPlatformData\n    })\n    .select()\n    .single();\n\n    if (dbError) {\n        console.error('Failed to store inbound message to DB:', dbError);\n        throw dbError;\n    }\n    if (!dbMessage) throw new Error('Inbound message saving failed to return data.');\n\n    // Opcional: Atualizar `last_activity_at` da conversa\n    await updateConversationActivity(organizationId, channel.id, contact.id);\n\n    return dbMessage as DbMessage;\n}\n\nasync function updateConversationActivity(organizationId: string, channelId: string, contactId: string) {\n    // Encontrar ou criar a conversa\n    // Esta lógica pode ser mais complexa, dependendo se uma conversa \"fecha\"\n    let { data: conversation, error: convError } = await supabaseAdmin\n        .from('conversations')\n        .select('id')\n        .eq('organization_id', organizationId)\n        .eq('channel_id', channelId)\n        .eq('contact_id', contactId)\n        .in('status', ['open', 'pending']) // Apenas atualiza conversas abertas/pendentes\n        .order('created_at', { ascending: false })\n        .limit(1)\n        .single();\n\n    if (convError && convError.code !== 'PGRST116') throw convError;\n\n    if (conversation) {\n        // Atualizar last_activity_at\n        const { error: updateError } = await supabaseAdmin\n            .from('conversations')\n            .update({ last_activity_at: new Date().toISOString() })\n            .eq('id', conversation.id);\n        if (updateError) console.error('Failed to update conversation last_activity_at:', updateError);\n    } else {\n        // Criar nova conversa (simplificado)\n        const { error: createConvError } = await supabaseAdmin\n            .from('conversations')\n            .insert({\n                organization_id: organizationId,\n                channel_id: channelId,\n                contact_id: contactId,\n                status: 'open', // Ou 'pending' se precisar de triagem\n                last_activity_at: new Date().toISOString()\n            });\n        if (createConvError) console.error('Failed to create new conversation on message activity:', createConvError);\n    }\n}\n```\n\n**4. Serviço de Canal (Exemplo WhatsApp)**\n\n**`src/services/channels/whatsapp.channel.service.ts`**\n```typescript\n// import WhatsAppCloudAPI from 'whatsappcloudapi_wrapper'; // Exemplo de biblioteca\nimport { Channel as DbChannel } from '@/types/db.types';\nimport { getSecretFromVault } from '@/core/vault.service';\n\n// Esta função é um placeholder. Você precisará de uma biblioteca ou SDK real\n// para interagir com a API do WhatsApp (ex: WhatsApp Cloud API via Meta, ou Twilio, etc.)\n\ninterface WhatsAppMessagePayload {\n  to: string;\n  text?: string;\n  // ... outros campos como template, interactive, media\n}\n\nexport async function sendMessage(\n  organizationId: string,\n  channel: DbChannel,\n  payload: WhatsAppMessagePayload\n): Promise<string | null> {\n  if (channel.type !== 'whatsapp') {\n    throw new Error('Invalid channel type for WhatsApp service.');\n  }\n\n  // Obter credenciais do Vault\n  // Exemplo: channel.credentials_vault_path_jsonb = { \"accessTokenVaultId\": \"uuid-no-vault\", \"phoneNumberIdVaultId\": \"...\" }\n  const credPaths = channel.credentials_vault_path_jsonb as { accessTokenVaultId?: string, phoneNumberIdVaultId?: string };\n  if (!credPaths?.accessTokenVaultId || !credPaths?.phoneNumberIdVaultId) {\n    throw new Error('WhatsApp credentials (Vault paths) not configured for this channel.');\n  }\n\n  const accessToken = await getSecretFromVault(credPaths.accessTokenVaultId);\n  const phoneNumberId = await getSecretFromVault(credPaths.phoneNumberIdVaultId);\n\n  if (!accessToken || !phoneNumberId) {\n    throw new Error('Failed to retrieve WhatsApp credentials from Vault.');\n  }\n\n  console.log(`WHATSAPP_SERVICE: Sending message via channel ${channel.id} from ${phoneNumberId} to ${payload.to}`);\n  console.log('Payload:', payload);\n  console.log('Using Access Token (first 5 chars):', accessToken.substring(0,5));\n\n\n  // Lógica para chamar a API do WhatsApp\n  // Exemplo usando uma biblioteca hipotética ou fetch:\n  /*\n  const whatsapp = new WhatsAppCloudAPI({\n    accessToken: accessToken,\n    senderPhoneNumberId: phoneNumberId,\n    WABA_ID: 'your_waba_id', // Pode estar no channel.config_jsonb\n  });\n\n  try {\n    let response;\n    if (payload.text) {\n      response = await whatsapp.sendText({\n        message: payload.text,\n        recipientPhoneNumber: payload.to,\n      });\n    } // else if (payload.template) { ... }\n      else {\n      throw new Error('Unsupported WhatsApp message payload type for now.');\n    }\n\n    if (response?.data?.messages?.[0]?.id) {\n      return response.data.messages[0].id; // Retorna o ID da mensagem da plataforma\n    }\n    console.error('WhatsApp API response did not contain message ID:', response);\n    return null;\n  } catch (error: any) {\n    console.error('WhatsApp API send error:', error.response?.data || error.message);\n    throw new Error(`WhatsApp API error: ${error.response?.data?.error?.message || error.message}`);\n  }\n  */\n\n  // Placeholder de sucesso para desenvolvimento (REMOVA EM PRODUÇÃO)\n  console.warn('WHATSAPP_SERVICE: sendMessage is a placeholder. No actual message sent.');\n  return `mock_whatsapp_msg_id_${crypto.randomUUID()}`;\n}\n\n// processInboundWebhook será chamado pelo handler do webhook\nexport async function processInboundWebhook(\n    organizationId: string,\n    channel: DbChannel,\n    webhookPayload: any // Payload bruto do webhook do WhatsApp\n): Promise<void> {\n    // 1. Validar e Parsear o Payload (Meta tem uma estrutura específica)\n    console.log(`WHATSAPP_SERVICE: Processing inbound webhook for channel ${channel.id}`, webhookPayload);\n    // Exemplo: extrair 'from' (número do cliente), 'text.body', 'image.id', message 'id', 'timestamp'\n\n    // Suponha que extraímos:\n    // const clientPhoneNumber = webhookPayload.entry[0].changes[0].value.messages[0].from;\n    // const messageText = webhookPayload.entry[0].changes[0].value.messages[0].text?.body;\n    // const platformMessageId = webhookPayload.entry[0].changes[0].value.messages[0].id;\n    // const platformTimestamp = webhookPayload.entry[0].changes[0].value.messages[0].timestamp;\n\n    // Placeholder - Adapte à estrutura real do payload do WhatsApp\n    const messagesEntry = webhookPayload?.entry?.[0]?.changes?.[0]?.value?.messages?.[0];\n    if (!messagesEntry) {\n        console.warn('WHATSAPP_SERVICE: Inbound webhook payload does not contain expected message structure.');\n        return;\n    }\n\n    const clientPhoneNumber = messagesEntry.from;\n    const messageText = messagesEntry.text?.body;\n    const platformMessageId = messagesEntry.id;\n    const platformTimestamp = messagesEntry.timestamp;\n    let contentType: DbMessage['content_type'] = 'text'; // Default\n    let mediaUrl: string | null = null;\n\n    if (messagesEntry.type === 'image') contentType = 'image'; // Adicionar lógica para obter mediaUrl\n    // ... outros tipos de mensagem\n\n    if (!clientPhoneNumber || !platformMessageId) {\n        console.error('WHATSAPP_SERVICE: Missing client phone number or message ID in webhook.');\n        return;\n    }\n\n    // 2. Encontrar ou Criar Contato\n    const { contact, isNewContact } = await findOrCreateContactByIdentifier(\n        organizationId,\n        'whatsapp',\n        clientPhoneNumber,\n        { full_name: isNewContact ? `WhatsApp ${clientPhoneNumber}` : undefined } // Só preenche nome se for novo\n    );\n\n    // 3. Armazenar a mensagem de entrada usando MessageService.storeInboundMessage\n    const { storeInboundMessage } = await import('../messages/messages.services'); // Lazy import para evitar ciclo\n    await storeInboundMessage(organizationId, channel, contact, {\n        externalMessageId: platformMessageId,\n        textContent: messageText,\n        contentType: contentType,\n        mediaUrl: mediaUrl,\n        timestamp: new Date(parseInt(platformTimestamp, 10) * 1000),\n        additionalPlatformData: messagesEntry // Armazena o payload da mensagem da plataforma\n    });\n\n    console.log(`WHATSAPP_SERVICE: Inbound message from ${clientPhoneNumber} processed for contact ${contact.id}`);\n\n    // 4. Opcional: Disparar Workflows ou outras lógicas de IA aqui\n    // Ex: Chamar TriggerManager do WorkflowEngine\n    // const { triggerWorkflowByEvent } = await import('@/workflow_engine/trigger_manager');\n    // await triggerWorkflowByEvent({\n    //   type: 'channel_message_received',\n    //   organizationId,\n    //   payload: { channel, contact, message: { text: messageText, ... } }\n    // });\n}\n```\n\n**5. Webhook Handler (Exemplo WhatsApp)**\n\n**`src/webhooks/whatsapp.webhook.ts`**\n```typescript\nimport { Hono } from 'hono';\nimport { supabaseAdmin } from '@/core/supabase';\nimport { Channel as DbChannel } from '@/types/db.types';\nimport * as WhatsappChannelService from '@/services/channels/whatsapp.channel.service';\n// import { verifyWhatsappSignature } from './middleware/signatureVerifier'; // Crie este\n\nconst whatsappWebhookApp = new Hono();\n\n// Verificação do Webhook (GET request do Facebook/Meta)\nwhatsappWebhookApp.get('/:channelIdentifier', async (c) => {\n  const { channelIdentifier } = c.req.param();\n  // O channelIdentifier pode ser o ID do canal no seu DB ou um identificador único\n  // que você configurou no Facebook Developers (ex: um UUID).\n\n  // Buscar o canal para obter o WEBHOOK_VERIFY_TOKEN específico dele (armazenado no config_jsonb ou vault)\n  const { data: channel, error: channelError } = await supabaseAdmin\n    .from('channels')\n    .select('id, config_jsonb, credentials_vault_path_jsonb') // Supondo que verify_token está em config_jsonb\n    .eq('type', 'whatsapp')\n    // .eq('config_jsonb->>webhook_identifier', channelIdentifier) // Se usar um ID custom\n    .eq('id', channelIdentifier) // Se o channelIdentifier for o ID do seu canal\n    .single();\n\n  if (channelError || !channel) {\n    console.warn(`WhatsApp Webhook GET: Channel not found for identifier ${channelIdentifier}`);\n    return c.text('Channel not found', 404);\n  }\n\n  const channelConfig = channel.config_jsonb as { webhook_verify_token?: string };\n  const VERIFY_TOKEN = channelConfig?.webhook_verify_token; // Obtenha do Vault se for sensível\n\n  if (!VERIFY_TOKEN) {\n      console.error(`WhatsApp Webhook GET: Verify token not configured for channel ${channel.id}`);\n      return c.text('Configuration error', 500);\n  }\n\n  const mode = c.req.query('hub.mode');\n  const token = c.req.query('hub.verify_token');\n  const challenge = c.req.query('hub.challenge');\n\n  if (mode && token) {\n    if (mode === 'subscribe' && token === VERIFY_TOKEN) {\n      console.log(`WhatsApp Webhook for channel ${channel.id} verified!`);\n      return c.text(challenge!, 200);\n    } else {\n      console.warn(`WhatsApp Webhook verification failed for channel ${channel.id}: Invalid token or mode.`);\n      return c.text('Forbidden: Verification failed', 403);\n    }\n  }\n  return c.text('Missing query parameters for verification', 400);\n});\n\n// Receber eventos de mensagens (POST request do Facebook/Meta)\nwhatsappWebhookApp.post('/:channelIdentifier', async (c) => {\n  const { channelIdentifier } = c.req.param();\n  const body = await c.req.json();\n\n  // 1. Identificar a organização e o canal\n  // (Similar à lógica do GET, mas pode ser otimizado se o channelIdentifier for o ID do canal)\n  const { data: channelConfig, error: channelError } = await supabaseAdmin\n    .from('channels')\n    .select('id, type, organization_id, credentials_vault_path_jsonb, config_jsonb') // Precisa de organization_id e creds/config para assinatura\n    .eq('type', 'whatsapp')\n    .eq('id', channelIdentifier) // Supondo que channelIdentifier é o ID do canal no seu DB\n    .single();\n\n  if (channelError || !channelConfig) {\n    console.error(`WhatsApp Webhook POST: Channel ${channelIdentifier} not found or DB error.`);\n    return c.text('Channel config not found', 404); // Não dar muita info\n  }\n\n  const channel = channelConfig as DbChannel; // Cast para o tipo correto\n\n  // 2. TODO: Verificar a assinatura do Webhook (X-Hub-Signature-256)\n  // const appSecret = await getSecretFromVault((channel.credentials_vault_path_jsonb as any)?.appSecretVaultId);\n  // if (!appSecret || !verifyWhatsappSignature(c.req.raw, c.req.header('X-Hub-Signature-256'), appSecret)) {\n  //   console.warn(`WhatsApp Webhook POST: Invalid signature for channel ${channel.id}`);\n  //   return c.text('Invalid signature', 403);\n  // }\n\n  // 3. Processar o payload de forma assíncrona (para responder rapidamente ao Facebook)\n  // Não usar await aqui intencionalmente para responder 200 OK imediatamente\n  WhatsappChannelService.processInboundWebhook(channel.organization_id, channel, body)\n    .catch(err => {\n      console.error(`Error processing WhatsApp inbound webhook async for channel ${channel.id}:`, err);\n      // Logar o erro, mas não impedir a resposta 200, a menos que seja crítico para Meta\n    });\n\n  return c.text('EVENT_RECEIVED', 200); // Facebook/Meta espera um 200 OK rapidamente\n});\n\nexport default whatsappWebhookApp;\n```\n\n**6. Node Handler (Exemplo `send_message`)**\n\n**`src/workflow_engine/node_handlers/send_message.handler.ts`**\n```typescript\nimport { SupabaseClient } from '@supabase/supabase-js';\nimport { WorkflowNode, HonoEnv } from '@/types'; // Adicione WorkflowNode ao HonoEnv se necessário\nimport { sendMessage as sendOmniMessage } from '@/api/v1/modules/messages/messages.services'; // Usar o serviço de mensagem principal\nimport { interpolateString } from '../utils/interpolation'; // Crie um utilitário de interpolação\n\ninterface SendMessageNodeConfig {\n  channel_id: string; // ID do canal configurado na plataforma\n  contact_id_expression?: string; // Expressão para obter o contact_id do contexto (ex: {{trigger.outputs.contactId}})\n  to_identifier_value_expression?: string; // Expressão para o valor do identificador (ex: {{trigger.outputs.customerPhone}})\n  to_identifier_type?: 'whatsapp' | 'telegram' | 'email'; // Tipo do identificador\n  content_type: 'text' | 'template'; // etc.\n  text_content_expression?: string; // Expressão para o conteúdo (ex: \"Olá {{variables.customerName}}\")\n  template_id_expression?: string;\n  template_data_expression?: string; // Expressão para um objeto JSON de variáveis do template\n}\n\nexport async function handleSendMessage(\n  config: SendMessageNodeConfig,\n  context: Record<string, any>,\n  supabase: SupabaseClient, // O supabase client aqui pode ser o admin client\n  organizationId: string,\n  // agentUserId (quem está \"enviando\" em nome do workflow - pode ser um user_id de sistema/bot)\n  workflowExecutionAgentId?: string // Um ID de usuário especial para 'automation'\n): Promise<Record<string, any>> {\n\n  const agentUserIdForMessage = workflowExecutionAgentId || context.variables?.SYSTEM_AUTOMATION_USER_ID; // Defina um ID de sistema\n\n  if (!agentUserIdForMessage) {\n      console.warn('No agentUserIdForMessage provided for send_message node, message might not be attributed correctly.');\n      // throw new Error('Automation user ID not configured for sending messages.');\n  }\n\n\n  // Interpolar todas as expressões com dados do contexto\n  const channelId = interpolateString(config.channel_id, context);\n  const contactId = config.contact_id_expression ? interpolateString(config.contact_id_expression, context) : undefined;\n  const toIdentifierValue = config.to_identifier_value_expression ? interpolateString(config.to_identifier_value_expression, context) : undefined;\n  const textContent = config.text_content_expression ? interpolateString(config.text_content_expression, context) : undefined;\n  // ... interpolar outros campos como template_id, template_data (este pode ser um objeto JSON)\n\n  if (!channelId) throw new Error('Send Message Node: channel_id is required and could not be resolved.');\n  if (!contactId && !toIdentifierValue) throw new Error('Send Message Node: contact_id or to_identifier_value is required.');\n\n  try {\n    const messagePayload = {\n      channel_id: channelId,\n      contact_id: contactId,\n      to_identifier_value: toIdentifierValue,\n      to_identifier_type: config.to_identifier_type, // Pode precisar de interpolação se for dinâmico\n      content_type: config.content_type,\n      text_content: textContent,\n      // template_data: parsedTemplateData,\n      // ...\n    };\n\n    // Usar o sendMessage do MessageService principal\n    // O organizationId é passado para o MessageService\n    // O agentUserId aqui seria o ID do \"usuário de automação\" se tiver um, ou nulo\n    const sentMessage = await sendOmniMessage(organizationId, agentUserIdForMessage!, messagePayload);\n\n    return { message_id: sentMessage.id, status: sentMessage.status, external_message_id: (sentMessage as any).external_message_id };\n  } catch (error: any) {\n    console.error(`Send Message Node Error (channel ${channelId}):`, error);\n    throw error; // Relançar para o executor do workflow\n  }\n}\n```\n\n**`src/workflow_engine/utils/interpolation.ts` (Simples)**\n```typescript\n// src/workflow_engine/utils/interpolation.ts\n\n// Função de interpolação muito básica.\n// Em produção, você usaria uma biblioteca de templating mais robusta como Handlebars, Mustache, ou Nunjucks.\n// Esta versão lida com {{path.to.value}} e {{path[0].value}}.\nexport function interpolateString(template: string | undefined, context: Record<string, any>): any {\n  if (typeof template !== 'string') return template; // Retorna o valor original se não for string\n\n  // Verifica se o template é APENAS uma variável, ex: \"{{variables.someObject}}\"\n  // Nesse caso, queremos retornar o objeto/array inteiro, não sua stringificação.\n  const singleVarMatch = template.match(/^\\{\\{([\\w.[\\]]+)\\}\\}$/);\n  if (singleVarMatch) {\n      const path = singleVarMatch[1];\n      return getValueFromPath(context, path, template); // Retorna o valor diretamente\n  }\n\n  // Interpolação normal para strings com múltiplas variáveis ou texto misto\n  return template.replace(/\\{\\{([\\w.[\\]]+)\\}\\}/g, (match, path) => {\n    const value = getValueFromPath(context, path);\n    return value !== undefined && value !== null ? String(value) : ''; // Retorna string vazia se não encontrado\n  });\n}\n\nfunction getValueFromPath(obj: Record<string, any>, path: string, originalTemplateIfNotFound?: any): any {\n  const parts = path.split(/\\.|\\[\"?'?|\"?\\]\\.?\"?'?/g).filter(Boolean); // Lida com obj.prop e obj[\"prop\"] e obj[0]\n  let current = obj;\n  for (const part of parts) {\n    if (current && typeof current === 'object' && part in current) {\n      current = current[part];\n    } else {\n      // console.warn(`Interpolation: Path \"${path}\" not found in context.`);\n      return originalTemplateIfNotFound !== undefined ? originalTemplateIfNotFound : undefined; // Retorna template original ou undefined\n    }\n  }\n  return current;\n}\n\n// Exemplo de uso:\n// const context = {\n//   trigger: { outputs: { name: \"John\", details: { age: 30 } } },\n//   variables: { city: \"New York\", items: [{id:1, name:\"A\"}, {id:2, name:\"B\"}] }\n// };\n// console.log(interpolateString(\"Hello {{trigger.outputs.name}} from {{variables.city}}. Age: {{trigger.outputs.details.age}}\", context));\n// console.log(interpolateString(\"First item: {{variables.items[0].name}}\", context));\n// console.log(interpolateString(\"{{variables.items}}\", context)); // Retornaria o array de items\n```\n\n**7. `db/rpc_functions.sql` (Para a função pgvector)**\n```sql\n-- db/rpc_functions.sql\n\n-- Certifique-se que a extensão vector está habilitada: CREATE EXTENSION IF NOT EXISTS vector;\n\n-- Função para buscar documentos/itens similares por organização usando pgvector\n-- Adapte as dimensões do vetor e os nomes das colunas conforme necessário.\nCREATE OR REPLACE FUNCTION match_documents_by_org (\n  p_org_id uuid,\n  p_query_embedding vector(1536), -- Ajuste a dimensão aqui (ex: 1536 para OpenAI ada-002)\n  p_table_name_param text,\n  p_embedding_column_name_param text,\n  p_match_count int,\n  p_select_columns_param text default '*',\n  p_match_threshold float default 0.0 -- Distância de cosseno; 0.0 = mais similar. Para similaridade % use (1 - threshold_pct)\n                                      -- Ex: para 70% de similaridade (0.7), o threshold da distância seria 1 - 0.7 = 0.3\n                                      -- Se p_match_threshold for usado para similaridade, a query mudaria\n) RETURNS TABLE (selected_data jsonb, similarity_score real) -- Retornando como JSONB para flexibilidade\nLANGUAGE plpgsql\nAS $$\nBEGIN\n  -- Validação básica dos nomes da tabela e coluna para evitar SQL Injection simples\n  IF p_table_name_param !~ '^[a-zA-Z0-9_]+$' OR p_embedding_column_name_param !~ '^[a-zA-Z0-9_]+$' THEN\n    RAISE EXCEPTION 'Invalid table or column name';\n  END IF;\n\n  IF p_select_columns_param = '*' THEN\n      p_select_columns_param := 'to_jsonb(tbl)'; -- Converte toda a linha para JSONB\n  ELSE\n      -- Se for uma lista de colunas, precisaria de mais lógica para construir o select JSON\n      -- Por simplicidade, vamos assumir que se não for '*', é um JSON construído corretamente\n      -- Ex: 'json_build_object(''id'', tbl.id, ''name'', tbl.name)'\n      -- Por enquanto, vamos apenas permitir '*' ou assumir que é um row_to_json\n      p_select_columns_param := 'to_jsonb(tbl)'; -- Simplificando\n  END IF;\n\n\n  RETURN QUERY EXECUTE format(\n    'SELECT %s AS selected_data, (tbl.%I <-> $1)::real AS similarity_score ' ||\n    'FROM public.%I AS tbl ' || -- Assume public schema\n    'WHERE tbl.organization_id = $2 ' ||\n    -- Se p_match_threshold for distância (0 é mais similar):\n    -- 'AND (tbl.%I <-> $1) < $4 ' || -- Descomente se quiser filtrar por threshold de distância\n    'ORDER BY similarity_score ASC ' || -- ASC porque menor distância é mais similar\n    'LIMIT $3',\n    p_select_columns_param,          -- Colunas a selecionar (como JSONB)\n    p_embedding_column_name_param,   -- Coluna de embedding para cálculo de distância\n    p_table_name_param,              -- Nome da tabela\n    p_embedding_column_name_param    -- Coluna de embedding para a cláusula WHERE/ORDER BY (repetido para segurança no format)\n    -- Adicionar $4 (p_match_threshold) se o filtro de threshold for usado\n  )\n  USING p_query_embedding, p_org_id, p_match_count; -- , p_match_threshold (se usado)\nEND;\n$$;\n\n-- Exemplo de como chamar no JS:\n-- const { data, error } = await supabaseClient\n--  .rpc('match_documents_by_org', {\n--    p_org_id: \"uuid-da-org\",\n--    p_query_embedding: [0.1, 0.2, ...], // seu vetor de embedding\n--    p_table_name_param: \"contacts\",\n--    p_embedding_column_name_param: \"profile_summary_embedding\",\n--    p_match_count: 5,\n--    p_select_columns_param: \"json_build_object('id', id, 'full_name', full_name)\" // Opcional\n--  });\n```\n\nEste é um conjunto substancial de código inicial. O próximo passo seria preencher os TODOs, implementar os validadores Zod restantes, criar os serviços para cada módulo da API, e continuar construindo o `workflow_engine` com mais `node_handlers`.",
      ],
    },
  ];
  const message: Content = {
    role: "user",
    parts: [
      "INSERT_INPUT_HERE",
    ],
  };

  const chat = model.startChat({ history, });

  const result = await chat.sendMessage(message);
  console.log(result.response.text());
}
